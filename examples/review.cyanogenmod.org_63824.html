<!DOCTYPE html><html><head><title>63824 Alarm: Show a warning toast when alarm volume is set to silent | review.cyanogenmod.org</title><link data-turbolinks-track="true" href="application-1fc39d1097be6574c8b3760190c48582.css" media="all" rel="stylesheet" /><script data-turbolinks-track="true" src="application-0ba414835c483e6765f1f6bcb8bbf814.js"></script><meta content="authenticity_token" name="csrf-param" />
<meta content="jy0k60Wn1uWmwWPRBXDktVTrOMo3NtBPomV/qJztJTo=" name="csrf-token" /></head><body><div id="ChangeViewRoot"></div><script>var changeViewProps = {"branch":"cm-11.0","changeId":"I97edae55351101046def5058a2459ab88edf2d0d","createdAt":"2014-05-11T15:36:54.000Z","host":{"baseUrl":"http://review.cyanogenmod.org"},"notice":null,"number":63824,"owner":{"accountId":8048,"email":"str3l0k@gmail.com","name":"Vladimir Vainer","username":"ferreus"},"project":{"name":"CyanogenMod/android_packages_apps_DeskClock"},"subject":"Alarm: Show a warning toast when alarm volume is set to silent","updatedAt":"2014-06-01T08:14:35.130Z","revisions":[{"author":"Vladimir Vainer \u003cstr3l0k@gmail.com\u003e","committer":"Vladimir Vainer \u003cstr3l0k@gmail.com\u003e","message":"Alarm: Show a warning toast when alarm volume is set to silent\n\nChange-Id: I97edae55351101046def5058a2459ab88edf2d0d\n","parentCommit":"f216d2dbdc47660cd56924fafe94652f311077e1","revisionId":1,"subject":"Alarm: Show a warning toast when alarm volume is set to silent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     f216d2db (DeskClock: Fix NullPointerException in AlarmClockFragment)\nAuthor:     Vladimir Vainer \u003cstr3l0k@gmail.com\u003e\nAuthorDate: 2014-05-11 18:36:09 +0300\nCommit:     Vladimir Vainer \u003cstr3l0k@gmail.com\u003e\nCommitDate: 2014-05-11 18:36:09 +0300\n\nAlarm: Show a warning toast when alarm volume is set to silent\n\nChange-Id: I97edae55351101046def5058a2459ab88edf2d0d","comments":[],"name":"/COMMIT_MSG"},"res/values/cm_strings.xml":{"a":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     Copyright (C) 2012-2014 The CyanogenMod Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n--\u003e\n\u003cresources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"\u003e\n    \u003c!-- Setting title for showing/hiding the alarm status bar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_title\"\u003eShow icon\u003c/string\u003e\n\n    \u003c!-- Setting summary for showing/hiding the alarm statusbar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_summary\"\u003eShow an icon in the status bar when an alarm is set\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Increasing volume on or off --\u003e\n    \u003cstring name=\"alarm_increasing_volume\"\u003eIncreasing volume\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Choose profile --\u003e\n    \u003cstring name=\"profile_description\"\u003eProfile \u003cxliff:g id=\"profile\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- No profile selected label --\u003e\n    \u003cstring name=\"profile_no_selected\"\u003eNo profile selected\u003c/string\u003e\n\n    \u003c!-- User-defined cities --\u003e\n    \u003cstring name=\"menu_item_add\"\u003eAdd\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_title\"\u003eAdd city\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_city\"\u003eCity:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_timezone\"\u003eTimezone:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_gps_cd\"\u003eTap to localize your current city\u003c/string\u003e\n    \u003cstring name=\"cities_add_loading\"\u003eLoading\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_searching\"\u003eSearching\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_no_results\"\u003eGPS query returns no location results\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_not_available\"\u003eGPS not available\u003c/string\u003e\n    \u003cstring name=\"cities_add_already_exists\"\u003eThe city already exists in the database\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_failed\"\u003eCan\\'t create the city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_title\"\u003eDelete city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_msg\"\u003eDo you want to delete \u003cxliff:g id=\"city\"\u003e%s\u003c/xliff:g\u003e?\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_failed\"\u003eCan\\'t delete the city\u003c/string\u003e\n\n    \u003c!-- Setting title for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_title\"\u003eFlip action\u003c/string\u003e\n\n    \u003c!-- Dialog title of the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"tablet\"\u003eFlip the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"default\"\u003eFlip the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"tablet\"\u003eFlipping the tablet down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"default\"\u003eFlipping the phone down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Setting title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_title\"\u003eShake action\u003c/string\u003e\n\n    \u003c!-- Dialog title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"tablet\"\u003eShake the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"default\"\u003eShake the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"tablet\"\u003eShaking the tablet will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"default\"\u003eShaking the phone will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Summary texts for shake and flip actions --\u003e\n    \u003cstring name=\"action_summary_snooze\"\u003esnooze alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_dismiss\"\u003edismiss alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_do_nothing\"\u003edo nothing\u003c/string\u003e\n\n    \u003c!-- Alarm picker dialog title --\u003e\n    \u003cstring name=\"alarm_picker_title\"\u003eChoose alarm type\u003c/string\u003e\n\n    \u003c!-- Alarm types --\u003e\n    \u003cstring name=\"alarm_type_ringtone\"\u003eRingtone\u003c/string\u003e\n    \u003cstring name=\"alarm_type_random\"\u003eRandomly\u003c/string\u003e\n\u003c/resources\u003e","b":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     Copyright (C) 2012-2014 The CyanogenMod Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n--\u003e\n\u003cresources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"\u003e\n    \u003c!-- Setting title for showing/hiding the alarm status bar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_title\"\u003eShow icon\u003c/string\u003e\n\n    \u003c!-- Setting summary for showing/hiding the alarm statusbar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_summary\"\u003eShow an icon in the status bar when an alarm is set\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Increasing volume on or off --\u003e\n    \u003cstring name=\"alarm_increasing_volume\"\u003eIncreasing volume\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Choose profile --\u003e\n    \u003cstring name=\"profile_description\"\u003eProfile \u003cxliff:g id=\"profile\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- No profile selected label --\u003e\n    \u003cstring name=\"profile_no_selected\"\u003eNo profile selected\u003c/string\u003e\n\n    \u003c!-- User-defined cities --\u003e\n    \u003cstring name=\"menu_item_add\"\u003eAdd\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_title\"\u003eAdd city\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_city\"\u003eCity:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_timezone\"\u003eTimezone:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_gps_cd\"\u003eTap to localize your current city\u003c/string\u003e\n    \u003cstring name=\"cities_add_loading\"\u003eLoading\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_searching\"\u003eSearching\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_no_results\"\u003eGPS query returns no location results\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_not_available\"\u003eGPS not available\u003c/string\u003e\n    \u003cstring name=\"cities_add_already_exists\"\u003eThe city already exists in the database\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_failed\"\u003eCan\\'t create the city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_title\"\u003eDelete city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_msg\"\u003eDo you want to delete \u003cxliff:g id=\"city\"\u003e%s\u003c/xliff:g\u003e?\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_failed\"\u003eCan\\'t delete the city\u003c/string\u003e\n\n    \u003c!-- Setting title for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_title\"\u003eFlip action\u003c/string\u003e\n\n    \u003c!-- Dialog title of the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"tablet\"\u003eFlip the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"default\"\u003eFlip the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"tablet\"\u003eFlipping the tablet down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"default\"\u003eFlipping the phone down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Setting title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_title\"\u003eShake action\u003c/string\u003e\n\n    \u003c!-- Dialog title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"tablet\"\u003eShake the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"default\"\u003eShake the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"tablet\"\u003eShaking the tablet will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"default\"\u003eShaking the phone will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Summary texts for shake and flip actions --\u003e\n    \u003cstring name=\"action_summary_snooze\"\u003esnooze alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_dismiss\"\u003edismiss alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_do_nothing\"\u003edo nothing\u003c/string\u003e\n\n    \u003c!-- Alarm picker dialog title --\u003e\n    \u003cstring name=\"alarm_picker_title\"\u003eChoose alarm type\u003c/string\u003e\n\n    \u003c!-- Alarm types --\u003e\n    \u003cstring name=\"alarm_type_ringtone\"\u003eRingtone\u003c/string\u003e\n    \u003cstring name=\"alarm_type_random\"\u003eRandomly\u003c/string\u003e\n\n    \u003c!-- Warn Silent Alarm title --\u003e\n    \u003cstring name=\"warn_silent_alarm_title\"\u003eAlarm volume is silent\u003c/string\u003e\n\u003c/resources\u003e","comments":[],"name":"res/values/cm_strings.xml"},"src/com/android/deskclock/AlarmClockFragment.java":{"a":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.deskclock;\n\nimport android.animation.Animator;\nimport android.animation.Animator.AnimatorListener;\nimport android.animation.AnimatorInflater;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.FragmentTransaction;\nimport android.app.LoaderManager;\nimport android.app.Profile;\nimport android.app.ProfileManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.media.Ringtone;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.text.format.DateFormat;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.Interpolator;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CursorAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport com.android.datetimepicker.time.RadialPickerLayout;\nimport com.android.datetimepicker.time.TimePickerDialog;\nimport com.android.deskclock.alarms.AlarmStateManager;\nimport com.android.deskclock.provider.Alarm;\nimport com.android.deskclock.provider.AlarmInstance;\nimport com.android.deskclock.provider.DaysOfWeek;\nimport com.android.deskclock.widget.ActionableToastBar;\nimport com.android.deskclock.widget.TextTime;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * AlarmClock application.\n */\npublic class AlarmClockFragment extends DeskClockFragment implements\n        LoaderManager.LoaderCallbacks\u003cCursor\u003e,\n        TimePickerDialog.OnTimeSetListener,\n        View.OnTouchListener\n        {\n    private static final float EXPAND_DECELERATION = 1f;\n    private static final float COLLAPSE_DECELERATION = 0.7f;\n    private static final int ANIMATION_DURATION = 300;\n    private static final String KEY_EXPANDED_IDS = \"expandedIds\";\n    private static final String KEY_REPEAT_CHECKED_IDS = \"repeatCheckedIds\";\n    private static final String KEY_RINGTONE_TITLE_CACHE = \"ringtoneTitleCache\";\n    private static final String KEY_SELECTED_ALARMS = \"selectedAlarms\";\n    private static final String KEY_DELETED_ALARM = \"deletedAlarm\";\n    private static final String KEY_UNDO_SHOWING = \"undoShowing\";\n    private static final String KEY_PREVIOUS_DAY_MAP = \"previousDayMap\";\n    private static final String KEY_SELECTED_ALARM = \"selectedAlarm\";\n    private static final String KEY_DELETE_CONFIRMATION = \"deleteConfirmation\";\n\n    private static final int REQUEST_CODE_RINGTONE = 1;\n    private static final int REQUEST_CODE_PROFILE = 2;\n\n    // This extra is used when receiving an intent to create an alarm, but no alarm details\n    // have been passed in, so the alarm page should start the process of creating a new alarm.\n    public static final String ALARM_CREATE_NEW_INTENT_EXTRA = \"deskclock.create.new\";\n\n    // This extra is used when receiving an intent to scroll to specific alarm. If alarm\n    // can not be found, and toast message will pop up that the alarm has be deleted.\n    public static final String SCROLL_TO_ALARM_INTENT_EXTRA = \"deskclock.scroll.to.alarm\";\n\n    private ProfileManager mProfileManager;\n    private ProfilesObserver mProfileObserver;\n\n    private final Uri PROFILES_SETTINGS_URI =\n        Settings.System.getUriFor(Settings.System.SYSTEM_PROFILES_ENABLED);\n\n    private static final int MSG_PROFILE_STATUS_CHANGE = 1000;\n\n    private ListView mAlarmsList;\n    private AlarmItemAdapter mAdapter;\n    private View mEmptyView;\n    private ImageView mAddAlarmButton;\n    private View mAlarmsView;\n    private View mTimelineLayout;\n    private AlarmTimelineView mTimelineView;\n    private View mFooterView;\n\n    private Bundle mRingtoneTitleCache; // Key: ringtone uri, value: ringtone title\n    private ActionableToastBar mUndoBar;\n    private View mUndoFrame;\n\n    private Alarm mSelectedAlarm;\n    private long mScrollToAlarmId = -1;\n\n    private Loader mCursorLoader = null;\n\n    // Saved states for undo\n    private Alarm mDeletedAlarm;\n    private Alarm mAddedAlarm;\n    private boolean mUndoShowing = false;\n\n    private Animator mFadeIn;\n    private Animator mFadeOut;\n\n    private Interpolator mExpandInterpolator;\n    private Interpolator mCollapseInterpolator;\n\n    private int mTimelineViewWidth;\n    private int mUndoBarInitialMargin;\n\n    // Cached layout positions of items in listview prior to add/removal of alarm item\n    private ConcurrentHashMap\u003cLong, Integer\u003e mItemIdTopMap = new ConcurrentHashMap\u003cLong, Integer\u003e();\n\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case MSG_PROFILE_STATUS_CHANGE:\n                    updateProfilesStatus();\n                    break;\n            }\n        }\n    };\n\n    public AlarmClockFragment() {\n        // Basic provider required by Fragment.java\n    }\n\n    @Override\n    public void onCreate(Bundle savedState) {\n        super.onCreate(savedState);\n        mCursorLoader = getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedState) {\n        // Inflate the layout for this fragment\n        final View v = inflater.inflate(R.layout.alarm_clock, container, false);\n\n        long[] expandedIds = null;\n        long[] repeatCheckedIds = null;\n        long[] selectedAlarms = null;\n        Bundle previousDayMap = null;\n        if (savedState != null) {\n            expandedIds = savedState.getLongArray(KEY_EXPANDED_IDS);\n            repeatCheckedIds = savedState.getLongArray(KEY_REPEAT_CHECKED_IDS);\n            mRingtoneTitleCache = savedState.getBundle(KEY_RINGTONE_TITLE_CACHE);\n            mDeletedAlarm = savedState.getParcelable(KEY_DELETED_ALARM);\n            mUndoShowing = savedState.getBoolean(KEY_UNDO_SHOWING);\n            selectedAlarms = savedState.getLongArray(KEY_SELECTED_ALARMS);\n            previousDayMap = savedState.getBundle(KEY_PREVIOUS_DAY_MAP);\n            mSelectedAlarm = savedState.getParcelable(KEY_SELECTED_ALARM);\n        }\n\n        // Register profiles status\n        mProfileManager = (ProfileManager) getActivity().getSystemService(Context.PROFILE_SERVICE);\n        mProfileObserver = new ProfilesObserver(mHandler);\n\n        mExpandInterpolator = new DecelerateInterpolator(EXPAND_DECELERATION);\n        mCollapseInterpolator = new DecelerateInterpolator(COLLAPSE_DECELERATION);\n\n        mAddAlarmButton = (ImageButton) v.findViewById(R.id.alarm_add_alarm);\n        mAddAlarmButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                hideUndoBar(true, null);\n                startCreatingAlarm();\n            }\n        });\n        // For landscape, put the add button on the right and the menu in the actionbar.\n        FrameLayout.LayoutParams layoutParams =\n                (FrameLayout.LayoutParams) mAddAlarmButton.getLayoutParams();\n        boolean isLandscape = getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n        if (isLandscape) {\n            layoutParams.gravity = Gravity.END;\n        } else {\n            layoutParams.gravity = Gravity.CENTER;\n        }\n        mAddAlarmButton.setLayoutParams(layoutParams);\n\n        View menuButton = v.findViewById(R.id.menu_button);\n        if (menuButton != null) {\n            if (isLandscape) {\n                menuButton.setVisibility(View.GONE);\n            } else {\n                menuButton.setVisibility(View.VISIBLE);\n                setupFakeOverflowMenuButton(menuButton);\n            }\n        }\n\n        mEmptyView = v.findViewById(R.id.alarms_empty_view);\n        mEmptyView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startCreatingAlarm();\n            }\n        });\n        mAlarmsList = (ListView) v.findViewById(R.id.alarms_list);\n\n        mFadeIn = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_in);\n        mFadeIn.setDuration(ANIMATION_DURATION);\n        mFadeIn.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator animation) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animation) {\n                // Do nothing.\n            }\n        });\n        mFadeIn.setTarget(mEmptyView);\n        mFadeOut = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_out);\n        mFadeOut.setDuration(ANIMATION_DURATION);\n        mFadeOut.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator arg0) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator arg0) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator arg0) {\n                mEmptyView.setVisibility(View.GONE);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator arg0) {\n                // Do nothing.\n            }\n        });\n        mFadeOut.setTarget(mEmptyView);\n        mAlarmsView = v.findViewById(R.id.alarm_layout);\n        mTimelineLayout = v.findViewById(R.id.timeline_layout);\n\n        mUndoBar = (ActionableToastBar) v.findViewById(R.id.undo_bar);\n        mUndoBarInitialMargin = getActivity().getResources()\n                .getDimensionPixelOffset(R.dimen.alarm_undo_bar_horizontal_margin);\n        mUndoFrame = v.findViewById(R.id.undo_frame);\n        mUndoFrame.setOnTouchListener(this);\n\n        mFooterView = v.findViewById(R.id.alarms_footer_view);\n        mFooterView.setOnTouchListener(this);\n\n        // Timeline layout only exists in tablet landscape mode for now.\n        if (mTimelineLayout != null) {\n            mTimelineView = (AlarmTimelineView) v.findViewById(R.id.alarm_timeline_view);\n            mTimelineViewWidth = getActivity().getResources()\n                    .getDimensionPixelOffset(R.dimen.alarm_timeline_layout_width);\n        }\n\n        mAdapter = new AlarmItemAdapter(getActivity(),\n                expandedIds, repeatCheckedIds, selectedAlarms, previousDayMap, mAlarmsList);\n        mAdapter.registerDataSetObserver(new DataSetObserver() {\n\n            private int prevAdapterCount = -1;\n\n            @Override\n            public void onChanged() {\n\n                final int count = mAdapter.getCount();\n                if (mDeletedAlarm != null \u0026\u0026 prevAdapterCount \u003e count) {\n                    showUndoBar();\n                }\n\n                // If there are no alarms in the adapter...\n                if (count == 0) {\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_red);\n\n                    // ...and if there exists a timeline view (currently only in tablet landscape)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        // ...and if the previous adapter had alarms (indicating a removal)...\n                        if (prevAdapterCount \u003e 0) {\n\n                            // Then animate in the \"no alarms\" icon...\n                            mFadeIn.start();\n\n                            // and animate out the alarm timeline view, expanding the width of the\n                            // alarms list / undo bar.\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mCollapseInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.addListener(new AnimatorListener() {\n\n                                @Override\n                                public void onAnimationCancel(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(false);\n                                }\n\n                                @Override\n                                public void onAnimationRepeat(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationStart(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(true);\n                                }\n\n                            });\n                            animator.start();\n                        } else {\n                            // If the previous adapter did not have alarms, no animation needed,\n                            // just hide the timeline view and show the \"no alarms\" icon.\n                            mTimelineLayout.setVisibility(View.GONE);\n                            mEmptyView.setVisibility(View.VISIBLE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just show the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.VISIBLE);\n                    }\n                } else {\n\n                    // Otherwise, if the adapter DOES contain alarms...\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_normal);\n\n                    // ...and if there exists a timeline view (currently in tablet landscape mode)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        mTimelineLayout.setVisibility(View.VISIBLE);\n                        // ...and if the previous adapter did not have alarms (indicating an add)\n                        if (prevAdapterCount == 0) {\n\n                            // Then, animate to hide the \"no alarms\" icon...\n                            mFadeOut.start();\n\n                            // and animate to show the timeline view, reducing the width of the\n                            // alarms list / undo bar.\n                            ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mExpandInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    ((FrameLayout.LayoutParams) mAlarmsView.getLayoutParams())\n                                        .setMargins(0, 0, (int) -rightOffset, 0);\n                                    mAlarmsView.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.start();\n                        } else {\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            mEmptyView.setVisibility(View.GONE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin + mTimelineViewWidth);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just hide the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.GONE);\n                    }\n                }\n\n                // Cache this adapter's count for when the adapter changes.\n                prevAdapterCount = count;\n                super.onChanged();\n            }\n        });\n\n        if (mRingtoneTitleCache == null) {\n            mRingtoneTitleCache = new Bundle();\n        }\n\n        mAlarmsList.setAdapter(mAdapter);\n        mAlarmsList.setVerticalScrollBarEnabled(true);\n        mAlarmsList.setOnCreateContextMenuListener(this);\n\n        if (mUndoShowing) {\n            showUndoBar();\n        }\n        return v;\n    }\n\n    private void setUndoBarRightMargin(int margin) {\n        FrameLayout.LayoutParams params =\n                (FrameLayout.LayoutParams) mUndoBar.getLayoutParams();\n        ((FrameLayout.LayoutParams) mUndoBar.getLayoutParams())\n            .setMargins(params.leftMargin, params.topMargin, margin, params.bottomMargin);\n        mUndoBar.requestLayout();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Check if another app asked us to create a blank new alarm.\n        final Intent intent = getActivity().getIntent();\n        if (intent.hasExtra(ALARM_CREATE_NEW_INTENT_EXTRA)) {\n            if (intent.getBooleanExtra(ALARM_CREATE_NEW_INTENT_EXTRA, false)) {\n                // An external app asked us to create a blank alarm.\n                startCreatingAlarm();\n            }\n\n            // Remove the CREATE_NEW extra now that we've processed it.\n            intent.removeExtra(ALARM_CREATE_NEW_INTENT_EXTRA);\n        } else if (intent.hasExtra(SCROLL_TO_ALARM_INTENT_EXTRA)) {\n            long alarmId = intent.getLongExtra(SCROLL_TO_ALARM_INTENT_EXTRA, Alarm.INVALID_ID);\n            if (alarmId != Alarm.INVALID_ID) {\n                mScrollToAlarmId = alarmId;\n                if (mCursorLoader != null \u0026\u0026 mCursorLoader.isStarted()) {\n                    // We need to force a reload here to make sure we have the latest view\n                    // of the data to scroll to.\n                    mCursorLoader.forceLoad();\n                }\n            }\n\n            // Remove the SCROLL_TO_ALARM extra now that we've processed it.\n            intent.removeExtra(SCROLL_TO_ALARM_INTENT_EXTRA);\n        }\n\n        // Make sure to use the child FragmentManager. We have to use that one for the\n        // case where an intent comes in telling the activity to load the timepicker,\n        // which means we have to use that one everywhere so that the fragment can get\n        // correctly picked up here if it's open.\n        TimePickerDialog tpd = (TimePickerDialog) getChildFragmentManager().\n                findFragmentByTag(AlarmUtils.FRAG_TAG_TIME_PICKER);\n        if (tpd != null) {\n            // The dialog is already open so we need to set the listener again.\n            tpd.setOnTimeSetListener(this);\n        }\n\n        // Update the profile status and register the profile observer\n        getActivity().getContentResolver().registerContentObserver(\n                PROFILES_SETTINGS_URI, false, mProfileObserver);\n        updateProfilesStatus();\n    }\n\n    private void hideUndoBar(boolean animate, MotionEvent event) {\n        if (mUndoBar != null) {\n            mUndoFrame.setVisibility(View.GONE);\n            if (event != null \u0026\u0026 mUndoBar.isEventInToastBar(event)) {\n                // Avoid touches inside the undo bar.\n                return;\n            }\n            mUndoBar.hide(animate);\n        }\n        mDeletedAlarm = null;\n        mUndoShowing = false;\n    }\n\n    private void showUndoBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                asyncAddAlarm(mDeletedAlarm);\n                mDeletedAlarm = null;\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.alarm_deleted), true, R.string.alarm_undo, true);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLongArray(KEY_EXPANDED_IDS, mAdapter.getExpandedArray());\n        outState.putLongArray(KEY_REPEAT_CHECKED_IDS, mAdapter.getRepeatArray());\n        outState.putLongArray(KEY_SELECTED_ALARMS, mAdapter.getSelectedAlarmsArray());\n        outState.putBundle(KEY_RINGTONE_TITLE_CACHE, mRingtoneTitleCache);\n        outState.putParcelable(KEY_DELETED_ALARM, mDeletedAlarm);\n        outState.putBoolean(KEY_UNDO_SHOWING, mUndoShowing);\n        outState.putBundle(KEY_PREVIOUS_DAY_MAP, mAdapter.getPreviousDaysOfWeekMap());\n        outState.putParcelable(KEY_SELECTED_ALARM, mSelectedAlarm);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        ToastMaster.cancelToast();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        // When the user places the app in the background by pressing \"home\",\n        // dismiss the toast bar. However, since there is no way to determine if\n        // home was pressed, just dismiss any existing toast bar when restarting\n        // the app.\n        hideUndoBar(false, null);\n\n        // Unregister the profile observer\n        getActivity().getContentResolver().unregisterContentObserver(mProfileObserver);\n    }\n\n    // Callback used by TimePickerDialog\n    @Override\n    public void onTimeSet(RadialPickerLayout view, int hourOfDay, int minute) {\n        if (mSelectedAlarm == null) {\n            // If mSelectedAlarm is null then we're creating a new alarm.\n            Alarm a = new Alarm();\n            a.alert = RingtoneManager.getActualDefaultRingtoneUri(getActivity(),\n                    RingtoneManager.TYPE_ALARM);\n            if (a.alert == null) {\n                a.alert = Uri.parse(\"content://settings/system/alarm_alert\");\n            }\n            a.hour = hourOfDay;\n            a.minutes = minute;\n            a.enabled = true;\n            asyncAddAlarm(a);\n        } else {\n            mSelectedAlarm.hour = hourOfDay;\n            mSelectedAlarm.minutes = minute;\n            mSelectedAlarm.enabled = true;\n            mScrollToAlarmId = mSelectedAlarm.id;\n            asyncUpdateAlarm(mSelectedAlarm, true);\n            mSelectedAlarm = null;\n        }\n    }\n\n    private void showLabelDialog(final Alarm alarm) {\n        final FragmentTransaction ft = getFragmentManager().beginTransaction();\n        final Fragment prev = getFragmentManager().findFragmentByTag(\"label_dialog\");\n        if (prev != null) {\n            ft.remove(prev);\n        }\n        ft.addToBackStack(null);\n\n        // Create and show the dialog.\n        final LabelDialogFragment newFragment =\n                LabelDialogFragment.newInstance(alarm, alarm.label, getTag());\n        newFragment.show(ft, \"label_dialog\");\n    }\n\n    public void setLabel(Alarm alarm, String label) {\n        alarm.label = label;\n        asyncUpdateAlarm(alarm, false);\n    }\n\n    @Override\n    public Loader\u003cCursor\u003e onCreateLoader(int id, Bundle args) {\n        return Alarm.getAlarmsCursorLoader(getActivity());\n    }\n\n    @Override\n    public void onLoadFinished(Loader\u003cCursor\u003e cursorLoader, final Cursor data) {\n        mAdapter.swapCursor(data);\n        if (mScrollToAlarmId != -1) {\n            scrollToAlarm(mScrollToAlarmId);\n            mScrollToAlarmId = -1;\n        }\n    }\n\n    /**\n     * Scroll to alarm with given alarm id.\n     *\n     * @param alarmId The alarm id to scroll to.\n     */\n    private void scrollToAlarm(long alarmId) {\n        int alarmPosition = -1;\n        for (int i = 0; i \u003c mAdapter.getCount(); i++) {\n            long id = mAdapter.getItemId(i);\n            if (id == alarmId) {\n                alarmPosition = i;\n                break;\n            }\n        }\n\n        if (alarmPosition \u003e= 0) {\n            mAdapter.setNewAlarm(alarmId);\n            mAlarmsList.smoothScrollToPositionFromTop(alarmPosition, 0);\n        } else {\n            // Trying to display a deleted alarm should only happen from a missed notification for\n            // an alarm that has been marked deleted after use.\n            Context context = getActivity().getApplicationContext();\n            Toast toast = Toast.makeText(context, R.string.missed_alarm_has_been_deleted,\n                    Toast.LENGTH_LONG);\n            ToastMaster.setToast(toast);\n            toast.show();\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader\u003cCursor\u003e cursorLoader) {\n        mAdapter.swapCursor(null);\n    }\n\n    private void launchRingTonePicker(final Alarm alarm) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.alarm_picker_title).setItems(\n                R.array.ringtone_picker_entries,\n\n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        switch (which) {\n                            case 0:\n                                launchSingleRingTonePicker(alarm);\n                                break;\n                            case 1:\n                                alarm.alert = MultiPlayer.RANDOM_URI;\n                                asyncUpdateAlarm(alarm, false);\n                                break;\n                        }\n                    }\n                });\n        AlertDialog d = builder.create();\n        d.show();\n    }\n\n    private void launchSingleRingTonePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;\n        final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, oldRingtone);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, false);\n        startActivityForResult(intent, REQUEST_CODE_RINGTONE);\n    }\n\n    private void launchProfilePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        final Intent intent = new Intent(ProfileManager.ACTION_PROFILE_PICKER);\n\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_EXISTING_UUID, alarm.profile.toString());\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_SHOW_NONE, true);\n        startActivityForResult(intent, REQUEST_CODE_PROFILE);\n    }\n\n    private void saveRingtoneUri(Intent intent) {\n        Uri uri = intent.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);\n        if (uri == null) {\n            uri = Alarm.NO_RINGTONE_URI;\n        }\n        mSelectedAlarm.alert = uri;\n\n        // Save the last selected ringtone as the default for new alarms\n        if (!Alarm.NO_RINGTONE_URI.equals(uri)) {\n            RingtoneManager.setActualDefaultRingtoneUri(\n                    getActivity(), RingtoneManager.TYPE_ALARM, uri);\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private void saveProfile(Intent intent) {\n        final String uuid = intent.getStringExtra(ProfileManager.EXTRA_PROFILE_PICKED_UUID);\n        if (uuid != null) {\n            try {\n                mSelectedAlarm.profile = UUID.fromString(uuid);\n            } catch (IllegalArgumentException ex) {\n                mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n            }\n        } else {\n            mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private boolean isProfilesEnabled() {\n        return Settings.System.getInt(getActivity().getContentResolver(),\n                Settings.System.SYSTEM_PROFILES_ENABLED, 1) == 1;\n    }\n\n    private String getProfileName(Alarm alarm) {\n        if (!isProfilesEnabled() || alarm.profile.equals(ProfileManager.NO_PROFILE)) {\n            return getString(R.string.profile_no_selected);\n        }\n        Profile profile = mProfileManager.getProfile(alarm.profile);\n        if (profile == null) {\n            return getString(R.string.profile_no_selected);\n        }\n        return profile.getName();\n    }\n\n    private void updateProfilesStatus() {\n        // Need to refresh the data\n        if (mAdapter != null) {\n            mAdapter.notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == Activity.RESULT_OK) {\n            switch (requestCode) {\n                case REQUEST_CODE_RINGTONE:\n                    saveRingtoneUri(data);\n                    break;\n                case REQUEST_CODE_PROFILE:\n                    saveProfile(data);\n                default:\n                    Log.w(\"Unhandled request code in onActivityResult: \" + requestCode);\n            }\n        }\n    }\n\n    private class ProfilesObserver extends ContentObserver {\n        public ProfilesObserver(Handler handler) {\n            super(handler);\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n            onChange(selfChange, null);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            if (uri == null) return;\n            if (PROFILES_SETTINGS_URI.equals(uri)) {\n                mHandler.removeMessages(MSG_PROFILE_STATUS_CHANGE);\n                mHandler.sendEmptyMessage(MSG_PROFILE_STATUS_CHANGE);\n            }\n        }\n    }\n\n    public class AlarmItemAdapter extends CursorAdapter {\n        private static final int EXPAND_DURATION = 300;\n        private static final int COLLAPSE_DURATION = 250;\n\n        private final Context mContext;\n        private final LayoutInflater mFactory;\n        private final String[] mShortWeekDayStrings;\n        private final String[] mLongWeekDayStrings;\n        private final int mColorLit;\n        private final int mColorDim;\n        private final int mBackgroundColorExpanded;\n        private final int mBackgroundColor;\n        private final Typeface mRobotoNormal;\n        private final Typeface mRobotoBold;\n        private final ListView mList;\n\n        private final HashSet\u003cLong\u003e mExpanded = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mRepeatChecked = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mSelectedAlarms = new HashSet\u003cLong\u003e();\n        private Bundle mPreviousDaysOfWeekMap = new Bundle();\n\n        private final boolean mHasVibrator;\n        private final int mCollapseExpandHeight;\n\n        // This determines the order in which it is shown and processed in the UI.\n        // The array is filled when the adapter is created\n        private final int[] DAY_ORDER = new int[7];\n\n        public class ItemHolder {\n\n            // views for optimization\n            LinearLayout alarmItem;\n            TextTime clock;\n            Switch onoff;\n            TextView daysOfWeek;\n            TextView label;\n            ImageView delete;\n            View expandArea;\n            View summary;\n            TextView clickableLabel;\n            CheckBox repeat;\n            LinearLayout repeatDays;\n            ViewGroup[] dayButtonParents = new ViewGroup[7];\n            ToggleButton[] dayButtons = new ToggleButton[7];\n            CheckBox vibrate;\n            CheckBox increasingVolume;\n            TextView ringtone;\n            TextView profile;\n            View hairLine;\n            View arrow;\n            View collapseExpandArea;\n            View footerFiller;\n\n            // Other states\n            Alarm alarm;\n        }\n\n        // Used for scrolling an expanded item in the list to make sure it is fully visible.\n        private long mScrollAlarmId = -1;\n        private final Runnable mScrollRunnable = new Runnable() {\n            @Override\n            public void run() {\n                if (mScrollAlarmId != -1) {\n                    View v = getViewById(mScrollAlarmId);\n                    if (v != null) {\n                        Rect rect = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n                        mList.requestChildRectangleOnScreen(v, rect, false);\n                    }\n                    mScrollAlarmId = -1;\n                }\n            }\n        };\n\n        public AlarmItemAdapter(Context context, long[] expandedIds, long[] repeatCheckedIds,\n                long[] selectedAlarms, Bundle previousDaysOfWeekMap, ListView list) {\n            super(context, null, 0);\n            mContext = context;\n            mFactory = LayoutInflater.from(context);\n            mList = list;\n\n            DateFormatSymbols dfs = new DateFormatSymbols();\n            mShortWeekDayStrings = dfs.getShortWeekdays();\n            mLongWeekDayStrings = dfs.getWeekdays();\n            int firstDayOfWeek = Calendar.getInstance(Locale.getDefault()).getFirstDayOfWeek();\n            int j = 0;\n            for (int i = firstDayOfWeek; i \u003c= DAY_ORDER.length; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n            for (int i = Calendar.SUNDAY; i \u003c firstDayOfWeek; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n\n            Resources res = mContext.getResources();\n            mColorLit = res.getColor(R.color.clock_white);\n            mColorDim = res.getColor(R.color.clock_gray);\n            mBackgroundColorExpanded = res.getColor(R.color.alarm_whiteish);\n            mBackgroundColor = R.drawable.alarm_background_normal;\n\n            mRobotoBold = Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\n            mRobotoNormal = Typeface.create(\"sans-serif-condensed\", Typeface.NORMAL);\n\n            if (expandedIds != null) {\n                buildHashSetFromArray(expandedIds, mExpanded);\n            }\n            if (repeatCheckedIds != null) {\n                buildHashSetFromArray(repeatCheckedIds, mRepeatChecked);\n            }\n            if (previousDaysOfWeekMap != null) {\n                mPreviousDaysOfWeekMap = previousDaysOfWeekMap;\n            }\n            if (selectedAlarms != null) {\n                buildHashSetFromArray(selectedAlarms, mSelectedAlarms);\n            }\n\n            mHasVibrator = ((Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE))\n                    .hasVibrator();\n\n            mCollapseExpandHeight = (int) res.getDimension(R.dimen.collapse_expand_height);\n        }\n\n        public void removeSelectedId(int id) {\n            mSelectedAlarms.remove(id);\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (!getCursor().moveToPosition(position)) {\n                // May happen if the last alarm was deleted and the cursor refreshed while the\n                // list is updated.\n                Log.v(\"couldn't move cursor to position \" + position);\n                return null;\n            }\n            View v;\n            if (convertView == null) {\n                v = newView(mContext, getCursor(), parent);\n            } else {\n                // TODO temporary hack to prevent the convertView from not having stuff we need.\n                boolean badConvertView = convertView.findViewById(R.id.digital_clock) == null;\n                // Do a translation check to test for animation. Change this to something more\n                // reliable and robust in the future.\n                if (convertView.getTranslationX() != 0 || convertView.getTranslationY() != 0 ||\n                        badConvertView) {\n                    // view was animated, reset\n                    v = newView(mContext, getCursor(), parent);\n                } else {\n                    v = convertView;\n                }\n            }\n            bindView(v, mContext, getCursor());\n            ItemHolder holder = (ItemHolder) v.getTag();\n\n            // We need the footer for the last element of the array to allow the user to scroll\n            // the item beyond the bottom button bar, which obscures the view.\n            holder.footerFiller.setVisibility(position \u003c getCount() - 1 ? View.GONE : View.VISIBLE);\n            return v;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            final View view = mFactory.inflate(R.layout.alarm_time, parent, false);\n            setNewHolder(view);\n            return view;\n        }\n\n        /**\n         * In addition to changing the data set for the alarm list, swapCursor is now also\n         * responsible for preparing the list view's pre-draw operation for any animations that\n         * need to occur if an alarm was removed or added.\n         */\n        @Override\n        public synchronized Cursor swapCursor(Cursor cursor) {\n            Cursor c = super.swapCursor(cursor);\n\n            if (mItemIdTopMap.isEmpty() \u0026\u0026 mAddedAlarm == null) {\n                return c;\n            }\n\n            final ListView list = mAlarmsList;\n            final ViewTreeObserver observer = list.getViewTreeObserver();\n\n            /*\n             * Add a pre-draw listener to the observer to prepare for any possible animations to\n             * the alarms within the list view.  The animations will occur if an alarm has been\n             * removed or added.\n             *\n             * For alarm removal, the remaining children should all retain their initial starting\n             * positions, and transition to their new positions.\n             *\n             * For alarm addition, the other children should all retain their initial starting\n             * positions, transition to their new positions, and at the end of that transition, the\n             * newly added alarm should appear in the designated space.\n             */\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n\n                private View mAddedView;\n\n                @Override\n                public boolean onPreDraw() {\n                    // Remove the pre-draw listener, as this only needs to occur once.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    boolean firstAnimation = true;\n                    int firstVisiblePosition = list.getFirstVisiblePosition();\n\n                    // Iterate through the children to prepare the add/remove animation.\n                    for (int i = 0; i\u003c list.getChildCount(); i++) {\n                        final View child = list.getChildAt(i);\n\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n\n                        // If this is the added alarm, set it invisible for now, and animate later.\n                        if (mAddedAlarm != null \u0026\u0026 itemId == mAddedAlarm.id) {\n                            mAddedView = child;\n                            mAddedView.setAlpha(0.0f);\n                            continue;\n                        }\n\n                        // The cached starting position of the child view.\n                        Integer startTop = mItemIdTopMap.get(itemId);\n                        // The new starting position of the child view.\n                        int top = child.getTop();\n\n                        // If there is no cached starting position, determine whether the item has\n                        // come from the top of bottom of the list view.\n                        if (startTop == null) {\n                            int childHeight = child.getHeight() + list.getDividerHeight();\n                            startTop = top + (i \u003e 0 ? childHeight : -childHeight);\n                        }\n\n                        Log.d(\"Start Top: \" + startTop + \", Top: \" + top);\n                        // If the starting position of the child view is different from the\n                        // current position, animate the child.\n                        if (startTop != top) {\n                            int delta = startTop - top;\n                            child.setTranslationY(delta);\n                            child.animate().setDuration(ANIMATION_DURATION).translationY(0);\n                            final View addedView = mAddedView;\n                            if (firstAnimation) {\n\n                                // If this is the first child being animated, then after the\n                                // animation is complete, and animate in the added alarm (if one\n                                // exists).\n                                child.animate().withEndAction(new Runnable() {\n\n                                    @Override\n                                    public void run() {\n\n\n                                        // If there was an added view, animate it in after\n                                        // the other views have animated.\n                                        if (addedView != null) {\n                                            addedView.animate().alpha(1.0f)\n                                                .setDuration(ANIMATION_DURATION)\n                                                .withEndAction(new Runnable() {\n\n                                                    @Override\n                                                    public void run() {\n                                                        // Re-enable the list after the add\n                                                        // animation is complete.\n                                                        list.setEnabled(true);\n                                                    }\n\n                                                });\n                                        } else {\n                                            // Re-enable the list after animations are complete.\n                                            list.setEnabled(true);\n                                        }\n                                    }\n\n                                });\n                                firstAnimation = false;\n                            }\n                        }\n                    }\n\n                    // If there were no child views (outside of a possible added view)\n                    // that require animation...\n                    if (firstAnimation) {\n                        if (mAddedView != null) {\n                            // If there is an added view, prepare animation for the added view.\n                            Log.d(\"Animating added view...\");\n                            mAddedView.animate().alpha(1.0f)\n                                .setDuration(ANIMATION_DURATION)\n                                .withEndAction(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        // Re-enable the list after animations are complete.\n                                        list.setEnabled(true);\n                                    }\n                                });\n                        } else {\n                            // Re-enable the list after animations are complete.\n                            list.setEnabled(true);\n                        }\n                    }\n\n                    mAddedAlarm = null;\n                    mItemIdTopMap.clear();\n                    return true;\n                }\n            });\n            return c;\n        }\n\n        private void setNewHolder(View view) {\n            // standard view holder optimization\n            final ItemHolder holder = new ItemHolder();\n            holder.alarmItem = (LinearLayout) view.findViewById(R.id.alarm_item);\n            holder.clock = (TextTime) view.findViewById(R.id.digital_clock);\n            holder.onoff = (Switch) view.findViewById(R.id.onoff);\n            holder.onoff.setTypeface(mRobotoNormal);\n            holder.daysOfWeek = (TextView) view.findViewById(R.id.daysOfWeek);\n            holder.label = (TextView) view.findViewById(R.id.label);\n            holder.delete = (ImageView) view.findViewById(R.id.delete);\n            holder.summary = view.findViewById(R.id.summary);\n            holder.expandArea = view.findViewById(R.id.expand_area);\n            holder.hairLine = view.findViewById(R.id.hairline);\n            holder.arrow = view.findViewById(R.id.arrow);\n            holder.repeat = (CheckBox) view.findViewById(R.id.repeat_onoff);\n            holder.clickableLabel = (TextView) view.findViewById(R.id.edit_label);\n            holder.repeatDays = (LinearLayout) view.findViewById(R.id.repeat_days);\n            holder.collapseExpandArea = view.findViewById(R.id.collapse_expand);\n            holder.footerFiller = view.findViewById(R.id.alarm_footer_filler);\n            holder.footerFiller.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // Do nothing.\n                }\n            });\n\n            // Build button for each day.\n            for (int i = 0; i \u003c 7; i++) {\n                final ViewGroup viewgroup = (ViewGroup) mFactory.inflate(R.layout.day_button,\n                        holder.repeatDays, false);\n                final ToggleButton button = (ToggleButton) viewgroup.getChildAt(0);\n                final int dayToShowIndex = DAY_ORDER[i];\n                button.setText(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOn(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOff(mShortWeekDayStrings[dayToShowIndex]);\n                button.setContentDescription(mLongWeekDayStrings[dayToShowIndex]);\n                holder.repeatDays.addView(viewgroup);\n                holder.dayButtons[i] = button;\n                holder.dayButtonParents[i] = viewgroup;\n            }\n            holder.vibrate = (CheckBox) view.findViewById(R.id.vibrate_onoff);\n            holder.increasingVolume = (CheckBox) view.findViewById(R.id.increasing_volume_onoff);\n            holder.ringtone = (TextView) view.findViewById(R.id.choose_ringtone);\n            holder.profile = (TextView) view.findViewById(R.id.choose_profile);\n\n            view.setTag(holder);\n        }\n\n        @Override\n        public void bindView(final View view, Context context, final Cursor cursor) {\n            final Alarm alarm = new Alarm(cursor);\n            Object tag = view.getTag();\n            if (tag == null) {\n                // The view was converted but somehow lost its tag.\n                setNewHolder(view);\n            }\n            final ItemHolder itemHolder = (ItemHolder) tag;\n            itemHolder.alarm = alarm;\n\n            // We must unset the listener first because this maybe a recycled view so changing the\n            // state would affect the wrong alarm.\n            itemHolder.onoff.setOnCheckedChangeListener(null);\n            itemHolder.onoff.setChecked(alarm.enabled);\n\n            if (mSelectedAlarms.contains(itemHolder.alarm.id)) {\n                itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n                setItemAlpha(itemHolder, true);\n                itemHolder.onoff.setEnabled(false);\n            } else {\n                itemHolder.onoff.setEnabled(true);\n                itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n                setItemAlpha(itemHolder, itemHolder.onoff.isChecked());\n            }\n            itemHolder.clock.setFormat(\n                    (int)mContext.getResources().getDimension(R.dimen.alarm_label_size));\n            itemHolder.clock.setTime(alarm.hour, alarm.minutes);\n            itemHolder.clock.setClickable(true);\n            itemHolder.clock.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    mSelectedAlarm = itemHolder.alarm;\n                    AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                            alarm, AlarmClockFragment.this\n                            , DateFormat.is24HourFormat(getActivity()));\n                    expandAlarm(itemHolder, true);\n                    itemHolder.alarmItem.post(mScrollRunnable);\n                }\n            });\n\n            final CompoundButton.OnCheckedChangeListener onOffListener =\n                    new CompoundButton.OnCheckedChangeListener() {\n                        @Override\n                        public void onCheckedChanged(CompoundButton compoundButton,\n                                boolean checked) {\n                            if (checked != alarm.enabled) {\n                                setItemAlpha(itemHolder, checked);\n                                alarm.enabled = checked;\n                                asyncUpdateAlarm(alarm, alarm.enabled);\n                            }\n                        }\n                    };\n\n            itemHolder.onoff.setOnCheckedChangeListener(onOffListener);\n\n            boolean expanded = isAlarmExpanded(alarm);\n            itemHolder.expandArea.setVisibility(expanded? View.VISIBLE : View.GONE);\n            itemHolder.summary.setVisibility(expanded? View.GONE : View.VISIBLE);\n\n            String labelSpace = \"\";\n            // Set the repeat text or leave it blank if it does not repeat.\n            final String daysOfWeekStr =\n                    alarm.daysOfWeek.toString(AlarmClockFragment.this.getActivity(), false);\n            if (daysOfWeekStr != null \u0026\u0026 daysOfWeekStr.length() != 0) {\n                itemHolder.daysOfWeek.setText(daysOfWeekStr);\n                itemHolder.daysOfWeek.setContentDescription(alarm.daysOfWeek.toAccessibilityString(\n                        AlarmClockFragment.this.getActivity()));\n                itemHolder.daysOfWeek.setVisibility(View.VISIBLE);\n                labelSpace = \"  \";\n                itemHolder.daysOfWeek.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n\n            } else {\n                itemHolder.daysOfWeek.setVisibility(View.GONE);\n            }\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() != 0) {\n                itemHolder.label.setText(alarm.label + labelSpace);\n                itemHolder.label.setVisibility(View.VISIBLE);\n                itemHolder.label.setContentDescription(\n                        mContext.getResources().getString(R.string.label_description) + \" \"\n                        + alarm.label);\n                itemHolder.label.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n            } else {\n                itemHolder.label.setVisibility(View.GONE);\n            }\n\n            itemHolder.delete.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    mDeletedAlarm = alarm;\n\n                    view.animate().setDuration(ANIMATION_DURATION).alpha(0).translationY(-1)\n                    .withEndAction(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            asyncDeleteAlarm(mDeletedAlarm, view);\n                        }\n                    });\n                }\n            });\n\n            if (expanded) {\n                expandAlarm(itemHolder, false);\n            } else {\n                collapseAlarm(itemHolder, false);\n            }\n\n            itemHolder.alarmItem.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    if (isAlarmExpanded(alarm)) {\n                        collapseAlarm(itemHolder, true);\n                    } else {\n                        expandAlarm(itemHolder, true);\n                    }\n                }\n            });\n\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n        }\n\n        private void bindExpandArea(final ItemHolder itemHolder, final Alarm alarm) {\n            // Views in here are not bound until the item is expanded.\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() \u003e 0) {\n                itemHolder.clickableLabel.setText(alarm.label);\n                itemHolder.clickableLabel.setTextColor(mColorLit);\n            } else {\n                itemHolder.clickableLabel.setText(R.string.label);\n                itemHolder.clickableLabel.setTextColor(mColorDim);\n            }\n            itemHolder.clickableLabel.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    showLabelDialog(alarm);\n                }\n            });\n\n            if (mRepeatChecked.contains(alarm.id) || itemHolder.alarm.daysOfWeek.isRepeating()) {\n                itemHolder.repeat.setChecked(true);\n                itemHolder.repeatDays.setVisibility(View.VISIBLE);\n            } else {\n                itemHolder.repeat.setChecked(false);\n                itemHolder.repeatDays.setVisibility(View.GONE);\n            }\n            itemHolder.repeat.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    final boolean checked = ((CheckBox) view).isChecked();\n                    if (checked) {\n                        // Show days\n                        itemHolder.repeatDays.setVisibility(View.VISIBLE);\n                        mRepeatChecked.add(alarm.id);\n\n                        // Set all previously set days\n                        // or\n                        // Set all days if no previous.\n                        final int bitSet = mPreviousDaysOfWeekMap.getInt(\"\" + alarm.id);\n                        alarm.daysOfWeek.setBitSet(bitSet);\n                        if (!alarm.daysOfWeek.isRepeating()) {\n                            alarm.daysOfWeek.setDaysOfWeek(true, DAY_ORDER);\n                        }\n                        updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n                    } else {\n                        itemHolder.repeatDays.setVisibility(View.GONE);\n                        mRepeatChecked.remove(alarm.id);\n\n                        // Remember the set days in case the user wants it back.\n                        final int bitSet = alarm.daysOfWeek.getBitSet();\n                        mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id, bitSet);\n\n                        // Remove all repeat days\n                        alarm.daysOfWeek.clearAllDays();\n                    }\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n            for (int i = 0; i \u003c 7; i++) {\n                final int buttonIndex = i;\n\n                itemHolder.dayButtonParents[i].setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        itemHolder.dayButtons[buttonIndex].toggle();\n                        final boolean checked = itemHolder.dayButtons[buttonIndex].isChecked();\n                        int day = DAY_ORDER[buttonIndex];\n                        alarm.daysOfWeek.setDaysOfWeek(checked, day);\n                        if (checked) {\n                            turnOnDayOfWeek(itemHolder, buttonIndex);\n                        } else {\n                            turnOffDayOfWeek(itemHolder, buttonIndex);\n\n                            // See if this was the last day, if so, un-check the repeat box.\n                            if (!alarm.daysOfWeek.isRepeating()) {\n                                itemHolder.repeatDays.setVisibility(View.GONE);\n                                itemHolder.repeat.setTextColor(mColorDim);\n                                mRepeatChecked.remove(alarm.id);\n\n                                // Set history to no days, so it will be everyday when repeat is\n                                // turned back on\n                                mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id,\n                                        DaysOfWeek.NO_DAYS_SET);\n                            }\n                        }\n                        asyncUpdateAlarm(alarm, false);\n                    }\n                });\n            }\n\n\n            if (!mHasVibrator) {\n                itemHolder.vibrate.setVisibility(View.INVISIBLE);\n            } else {\n                itemHolder.vibrate.setVisibility(View.VISIBLE);\n                if (!alarm.vibrate) {\n                    itemHolder.vibrate.setChecked(false);\n                    itemHolder.vibrate.setTextColor(mColorDim);\n                } else {\n                    itemHolder.vibrate.setChecked(true);\n                    itemHolder.vibrate.setTextColor(mColorLit);\n                }\n            }\n\n            itemHolder.vibrate.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    if (checked) {\n                        itemHolder.vibrate.setTextColor(mColorLit);\n                    } else {\n                        itemHolder.vibrate.setTextColor(mColorDim);\n                    }\n                    alarm.vibrate = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String ringtone;\n            final String ringtitle;\n            if (Alarm.NO_RINGTONE_URI.equals(alarm.alert)) {\n                ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n            } else {\n                ringtitle = getRingToneTitle(alarm.alert);\n                if (ringtitle != null) {\n                    ringtone = ringtitle;\n                } else {\n                    ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n                }\n            }\n            itemHolder.ringtone.setText(ringtone);\n            itemHolder.ringtone.setContentDescription(\n                    mContext.getResources().getString(R.string.ringtone_description) + \" \"\n                            + ringtone);\n            itemHolder.ringtone.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchRingTonePicker(alarm);\n                }\n            });\n\n\n            itemHolder.increasingVolume.setVisibility(View.VISIBLE);\n            itemHolder.increasingVolume.setChecked(alarm.increasingVolume);\n            itemHolder.increasingVolume.setTextColor(\n                    alarm.increasingVolume ? mColorLit : mColorDim);\n            itemHolder.increasingVolume.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    //When action mode is on - simulate long click\n                    itemHolder.increasingVolume.setTextColor(checked ? mColorLit : mColorDim);\n                    alarm.increasingVolume = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String profile = getProfileName(alarm);\n            itemHolder.profile.setText(profile);\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n            itemHolder.profile.setContentDescription(\n                    mContext.getResources().getString(R.string.profile_description, profile));\n            itemHolder.profile.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchProfilePicker(alarm);\n                }\n            });\n        }\n\n        // Sets the alpha of the item except the on/off switch. This gives a visual effect\n        // for enabled/disabled alarm while leaving the on/off switch more visible\n        private void setItemAlpha(ItemHolder holder, boolean enabled) {\n            float alpha = enabled ? 1f : 0.5f;\n            holder.clock.setAlpha(alpha);\n            holder.summary.setAlpha(alpha);\n            holder.expandArea.setAlpha(alpha);\n            holder.delete.setAlpha(alpha);\n            holder.daysOfWeek.setAlpha(alpha);\n        }\n\n        private void updateDaysOfWeekButtons(ItemHolder holder, DaysOfWeek daysOfWeek) {\n            HashSet\u003cInteger\u003e setDays = daysOfWeek.getSetDays();\n            for (int i = 0; i \u003c 7; i++) {\n                if (setDays.contains(DAY_ORDER[i])) {\n                    turnOnDayOfWeek(holder, i);\n                } else {\n                    turnOffDayOfWeek(holder, i);\n                }\n            }\n        }\n\n        public void toggleSelectState(View v) {\n            // long press could be on the parent view or one of its childs, so find the parent view\n            v = getTopParent(v);\n            if (v != null) {\n                long id = ((ItemHolder)v.getTag()).alarm.id;\n                if (mSelectedAlarms.contains(id)) {\n                    mSelectedAlarms.remove(id);\n                } else {\n                    mSelectedAlarms.add(id);\n                }\n            }\n        }\n\n        private View getTopParent(View v) {\n            while (v != null \u0026\u0026 v.getId() != R.id.alarm_item) {\n                v = (View) v.getParent();\n            }\n            return v;\n        }\n\n        public int getSelectedItemsNum() {\n            return mSelectedAlarms.size();\n        }\n\n        private void turnOffDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(false);\n            holder.dayButtons[dayIndex].setTextColor(mColorDim);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoNormal);\n        }\n\n        private void turnOnDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(true);\n            holder.dayButtons[dayIndex].setTextColor(mColorLit);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoBold);\n        }\n\n\n        /**\n         * Does a read-through cache for ringtone titles.\n         *\n         * @param uri The uri of the ringtone.\n         * @return The ringtone title. {@literal null} if no matching ringtone found.\n         */\n        private String getRingToneTitle(Uri uri) {\n            // Try the cache first\n            String title = mRingtoneTitleCache.getString(uri.toString());\n            if (title == null) {\n                if (uri.equals(MultiPlayer.RANDOM_URI)) {\n                    title = mContext.getResources().getString(R.string.alarm_type_random);\n                } else {\n                    // This is slow because a media player is created during Ringtone object creation.\n                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);\n                    if (ringTone != null) {\n                        title = ringTone.getTitle(mContext);\n                    }\n                }\n                if (title != null) {\n                    mRingtoneTitleCache.putString(uri.toString(), title);\n                }\n            }\n            return title;\n        }\n\n        public void setNewAlarm(long alarmId) {\n            mExpanded.add(alarmId);\n        }\n\n        /**\n         * Expands the alarm for editing.\n         *\n         * @param itemHolder The item holder instance.\n         */\n        private void expandAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.add(itemHolder.alarm.id);\n            bindExpandArea(itemHolder, itemHolder.alarm);\n            // Scroll the view to make sure it is fully viewed\n            mScrollAlarmId = itemHolder.alarm.id;\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to visible so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n            itemHolder.expandArea.setVisibility(View.VISIBLE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(180);\n                // We need to translate the hairline up, so the height of the collapseArea\n                // needs to be measured to know how high to translate it.\n                final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n                observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                    @Override\n                    public boolean onPreDraw() {\n                        // We don't want to continue getting called for every listview drawing.\n                        if (observer.isAlive()) {\n                            observer.removeOnPreDrawListener(this);\n                        }\n                        int hairlineHeight = itemHolder.hairLine.getHeight();\n                        int collapseHeight =\n                                itemHolder.collapseExpandArea.getHeight() - hairlineHeight;\n                        itemHolder.hairLine.setTranslationY(-collapseHeight);\n                        return true;\n                    }\n                });\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to VISIBLE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * the height is set back to the starting point so it can be animated down.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    // We don't want to continue getting called for every listview drawing.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    final int collapseHeight = itemHolder.collapseExpandArea.getHeight();\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = collapseHeight - hairlineHeight;\n\n                    // Set the height back to the start state of the animation.\n                    itemHolder.alarmItem.getLayoutParams().height = startingHeight;\n                    // To allow the expandArea to glide in with the expansion animation, set a\n                    // negative top margin, which will animate down to a margin of 0 as the height\n                    // is increased.\n                    // Note that we need to maintain the bottom margin as a fixed value (instead of\n                    // just using a listview, to allow for a flatter hierarchy) to fit the bottom\n                    // bar underneath.\n                    FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                            itemHolder.expandArea.getLayoutParams();\n                    expandParams.setMargins(0, -distance, 0, collapseHeight);\n                    itemHolder.alarmItem.requestLayout();\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(EXPAND_DURATION);\n                    animator.setInterpolator(mExpandInterpolator);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) -((1 - value) * distance), 0, collapseHeight);\n                            itemHolder.arrow.setRotation(180 * value);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * value);\n                            itemHolder.summary.setAlpha(1 - value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n                            itemHolder.arrow.setRotation(180);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance);\n                            itemHolder.summary.setVisibility(View.GONE);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    // Return false so this draw does not occur to prevent the final frame from\n                    // being drawn for the single frame before the animations start.\n                    return false;\n                }\n            });\n        }\n\n        private boolean isAlarmExpanded(Alarm alarm) {\n            return mExpanded.contains(alarm.id);\n        }\n\n        private void collapseAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.remove(itemHolder.alarm.id);\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to gone so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n            itemHolder.expandArea.setVisibility(View.GONE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(0);\n                itemHolder.hairLine.setTranslationY(0);\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to GONE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * expandArea is set to VISIBLE again so it can be shown animating.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = mCollapseExpandHeight - hairlineHeight;\n\n                    // Re-set the visibilities for the start state of the animation.\n                    itemHolder.expandArea.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setAlpha(1);\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(COLLAPSE_DURATION);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) (value * distance), 0, mCollapseExpandHeight);\n                            itemHolder.arrow.setRotation(180 * (1 - value));\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * (1 - value));\n                            itemHolder.summary.setAlpha(value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    animator.setInterpolator(mCollapseInterpolator);\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(0, 0, 0, mCollapseExpandHeight);\n\n                            itemHolder.expandArea.setVisibility(View.GONE);\n                            itemHolder.arrow.setRotation(0);\n                            itemHolder.hairLine.setTranslationY(0);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    return false;\n                }\n            });\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            return 1;\n        }\n\n        private View getViewById(long id) {\n            for (int i = 0; i \u003c mList.getCount(); i++) {\n                View v = mList.getChildAt(i);\n                if (v != null) {\n                    ItemHolder h = (ItemHolder)(v.getTag());\n                    if (h != null \u0026\u0026 h.alarm.id == id) {\n                        return v;\n                    }\n                }\n            }\n            return null;\n        }\n\n        public long[] getExpandedArray() {\n            int index = 0;\n            long[] ids = new long[mExpanded.size()];\n            for (long id : mExpanded) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getSelectedAlarmsArray() {\n            int index = 0;\n            long[] ids = new long[mSelectedAlarms.size()];\n            for (long id : mSelectedAlarms) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getRepeatArray() {\n            int index = 0;\n            long[] ids = new long[mRepeatChecked.size()];\n            for (long id : mRepeatChecked) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public Bundle getPreviousDaysOfWeekMap() {\n            return mPreviousDaysOfWeekMap;\n        }\n\n        private void buildHashSetFromArray(long[] ids, HashSet\u003cLong\u003e set) {\n            for (long id : ids) {\n                set.add(id);\n            }\n        }\n    }\n\n    private void startCreatingAlarm() {\n        // Set the \"selected\" alarm as null, and we'll create the new one when the timepicker\n        // comes back.\n        mSelectedAlarm = null;\n        AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                null, AlarmClockFragment.this, DateFormat.is24HourFormat(getActivity()));\n    }\n\n    private static AlarmInstance setupAlarmInstance(Context context, Alarm alarm) {\n        ContentResolver cr = context.getContentResolver();\n        AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());\n        newInstance = AlarmInstance.addInstance(cr, newInstance);\n        // Register instance to state manager\n        AlarmStateManager.registerInstance(context, newInstance, true);\n        return newInstance;\n    }\n\n    private void asyncDeleteAlarm(final Alarm alarm, final View viewToRemove) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, Void\u003e deleteTask = new AsyncTask\u003cVoid, Void, Void\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                if (viewToRemove == null) {\n                    return;\n                }\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                final ListView list = mAlarmsList;\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    if (child != viewToRemove) {\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n                        mItemIdTopMap.put(itemId, child.getTop());\n                    }\n                }\n            }\n\n            @Override\n            protected Void doInBackground(Void... parameters) {\n                // Activity may be closed at this point , make sure data is still valid\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n                    AlarmStateManager.deleteAllInstances(context, alarm.id);\n                    Alarm.deleteAlarm(cr, alarm.id);\n                }\n                return null;\n            }\n        };\n        mUndoShowing = true;\n        deleteTask.execute();\n    }\n\n    private void asyncAddAlarm(final Alarm alarm) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                final ListView list = mAlarmsList;\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    int position = firstVisiblePosition + i;\n                    long itemId = mAdapter.getItemId(position);\n                    mItemIdTopMap.put(itemId, child.getTop());\n                }\n            }\n\n            @Override\n            protected AlarmInstance doInBackground(Void... parameters) {\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n\n                    // Add alarm to db\n                    Alarm newAlarm = Alarm.addAlarm(cr, alarm);\n                    mScrollToAlarmId = newAlarm.id;\n\n                    // Create and add instance to db\n                    if (newAlarm.enabled) {\n                        return setupAlarmInstance(context, newAlarm);\n                    }\n                }\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    private void asyncUpdateAlarm(final Alarm alarm, final boolean popToast) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            protected AlarmInstance doInBackground(Void ... parameters) {\n                ContentResolver cr = context.getContentResolver();\n\n                // Dismiss all old instances\n                AlarmStateManager.deleteAllInstances(context, alarm.id);\n\n                // Update alarm\n                Alarm.updateAlarm(cr, alarm);\n                if (alarm.enabled) {\n                    return setupAlarmInstance(context, alarm);\n                }\n\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (popToast \u0026\u0026 instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        hideUndoBar(true, event);\n        return false;\n    }\n}","b":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.deskclock;\n\nimport android.animation.Animator;\nimport android.animation.Animator.AnimatorListener;\nimport android.animation.AnimatorInflater;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.FragmentTransaction;\nimport android.app.LoaderManager;\nimport android.app.Profile;\nimport android.app.ProfileManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.media.AudioManager;\nimport android.media.Ringtone;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.text.format.DateFormat;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.Interpolator;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CursorAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport com.android.datetimepicker.time.RadialPickerLayout;\nimport com.android.datetimepicker.time.TimePickerDialog;\nimport com.android.deskclock.alarms.AlarmStateManager;\nimport com.android.deskclock.provider.Alarm;\nimport com.android.deskclock.provider.AlarmInstance;\nimport com.android.deskclock.provider.DaysOfWeek;\nimport com.android.deskclock.widget.ActionableToastBar;\nimport com.android.deskclock.widget.TextTime;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * AlarmClock application.\n */\npublic class AlarmClockFragment extends DeskClockFragment implements\n        LoaderManager.LoaderCallbacks\u003cCursor\u003e,\n        TimePickerDialog.OnTimeSetListener,\n        View.OnTouchListener\n        {\n    private static final float EXPAND_DECELERATION = 1f;\n    private static final float COLLAPSE_DECELERATION = 0.7f;\n    private static final int ANIMATION_DURATION = 300;\n    private static final String KEY_EXPANDED_IDS = \"expandedIds\";\n    private static final String KEY_REPEAT_CHECKED_IDS = \"repeatCheckedIds\";\n    private static final String KEY_RINGTONE_TITLE_CACHE = \"ringtoneTitleCache\";\n    private static final String KEY_SELECTED_ALARMS = \"selectedAlarms\";\n    private static final String KEY_DELETED_ALARM = \"deletedAlarm\";\n    private static final String KEY_UNDO_SHOWING = \"undoShowing\";\n    private static final String KEY_PREVIOUS_DAY_MAP = \"previousDayMap\";\n    private static final String KEY_SELECTED_ALARM = \"selectedAlarm\";\n    private static final String KEY_DELETE_CONFIRMATION = \"deleteConfirmation\";\n\n    private static final int REQUEST_CODE_RINGTONE = 1;\n    private static final int REQUEST_CODE_PROFILE = 2;\n\n    // This extra is used when receiving an intent to create an alarm, but no alarm details\n    // have been passed in, so the alarm page should start the process of creating a new alarm.\n    public static final String ALARM_CREATE_NEW_INTENT_EXTRA = \"deskclock.create.new\";\n\n    // This extra is used when receiving an intent to scroll to specific alarm. If alarm\n    // can not be found, and toast message will pop up that the alarm has be deleted.\n    public static final String SCROLL_TO_ALARM_INTENT_EXTRA = \"deskclock.scroll.to.alarm\";\n\n    private ProfileManager mProfileManager;\n    private ProfilesObserver mProfileObserver;\n    private AudioManager mAudioManager;\n\n    private final Uri PROFILES_SETTINGS_URI =\n        Settings.System.getUriFor(Settings.System.SYSTEM_PROFILES_ENABLED);\n\n    private static final int MSG_PROFILE_STATUS_CHANGE = 1000;\n\n    private ListView mAlarmsList;\n    private AlarmItemAdapter mAdapter;\n    private View mEmptyView;\n    private ImageView mAddAlarmButton;\n    private View mAlarmsView;\n    private View mTimelineLayout;\n    private AlarmTimelineView mTimelineView;\n    private View mFooterView;\n\n    private Bundle mRingtoneTitleCache; // Key: ringtone uri, value: ringtone title\n    private ActionableToastBar mUndoBar;\n    private View mUndoFrame;\n\n    private Alarm mSelectedAlarm;\n    private long mScrollToAlarmId = -1;\n\n    private Loader mCursorLoader = null;\n\n    // Saved states for undo\n    private Alarm mDeletedAlarm;\n    private Alarm mAddedAlarm;\n    private boolean mUndoShowing = false;\n\n    private Animator mFadeIn;\n    private Animator mFadeOut;\n\n    private Interpolator mExpandInterpolator;\n    private Interpolator mCollapseInterpolator;\n\n    private int mTimelineViewWidth;\n    private int mUndoBarInitialMargin;\n\n    // Cached layout positions of items in listview prior to add/removal of alarm item\n    private ConcurrentHashMap\u003cLong, Integer\u003e mItemIdTopMap = new ConcurrentHashMap\u003cLong, Integer\u003e();\n\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case MSG_PROFILE_STATUS_CHANGE:\n                    updateProfilesStatus();\n                    break;\n            }\n        }\n    };\n\n    public AlarmClockFragment() {\n        // Basic provider required by Fragment.java\n    }\n\n    @Override\n    public void onCreate(Bundle savedState) {\n        super.onCreate(savedState);\n        mCursorLoader = getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedState) {\n        // Inflate the layout for this fragment\n        final View v = inflater.inflate(R.layout.alarm_clock, container, false);\n\n        long[] expandedIds = null;\n        long[] repeatCheckedIds = null;\n        long[] selectedAlarms = null;\n        Bundle previousDayMap = null;\n        if (savedState != null) {\n            expandedIds = savedState.getLongArray(KEY_EXPANDED_IDS);\n            repeatCheckedIds = savedState.getLongArray(KEY_REPEAT_CHECKED_IDS);\n            mRingtoneTitleCache = savedState.getBundle(KEY_RINGTONE_TITLE_CACHE);\n            mDeletedAlarm = savedState.getParcelable(KEY_DELETED_ALARM);\n            mUndoShowing = savedState.getBoolean(KEY_UNDO_SHOWING);\n            selectedAlarms = savedState.getLongArray(KEY_SELECTED_ALARMS);\n            previousDayMap = savedState.getBundle(KEY_PREVIOUS_DAY_MAP);\n            mSelectedAlarm = savedState.getParcelable(KEY_SELECTED_ALARM);\n        }\n\n        // Register profiles status\n        mProfileManager = (ProfileManager) getActivity().getSystemService(Context.PROFILE_SERVICE);\n        mProfileObserver = new ProfilesObserver(mHandler);\n\n        mExpandInterpolator = new DecelerateInterpolator(EXPAND_DECELERATION);\n        mCollapseInterpolator = new DecelerateInterpolator(COLLAPSE_DECELERATION);\n\n        mAddAlarmButton = (ImageButton) v.findViewById(R.id.alarm_add_alarm);\n        mAddAlarmButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                hideUndoBar(true, null);\n                startCreatingAlarm();\n            }\n        });\n        // For landscape, put the add button on the right and the menu in the actionbar.\n        FrameLayout.LayoutParams layoutParams =\n                (FrameLayout.LayoutParams) mAddAlarmButton.getLayoutParams();\n        boolean isLandscape = getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n        if (isLandscape) {\n            layoutParams.gravity = Gravity.END;\n        } else {\n            layoutParams.gravity = Gravity.CENTER;\n        }\n        mAddAlarmButton.setLayoutParams(layoutParams);\n\n        View menuButton = v.findViewById(R.id.menu_button);\n        if (menuButton != null) {\n            if (isLandscape) {\n                menuButton.setVisibility(View.GONE);\n            } else {\n                menuButton.setVisibility(View.VISIBLE);\n                setupFakeOverflowMenuButton(menuButton);\n            }\n        }\n\n        mEmptyView = v.findViewById(R.id.alarms_empty_view);\n        mEmptyView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startCreatingAlarm();\n            }\n        });\n        mAlarmsList = (ListView) v.findViewById(R.id.alarms_list);\n\n        mFadeIn = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_in);\n        mFadeIn.setDuration(ANIMATION_DURATION);\n        mFadeIn.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator animation) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animation) {\n                // Do nothing.\n            }\n        });\n        mFadeIn.setTarget(mEmptyView);\n        mFadeOut = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_out);\n        mFadeOut.setDuration(ANIMATION_DURATION);\n        mFadeOut.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator arg0) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator arg0) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator arg0) {\n                mEmptyView.setVisibility(View.GONE);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator arg0) {\n                // Do nothing.\n            }\n        });\n        mFadeOut.setTarget(mEmptyView);\n        mAlarmsView = v.findViewById(R.id.alarm_layout);\n        mTimelineLayout = v.findViewById(R.id.timeline_layout);\n\n        mUndoBar = (ActionableToastBar) v.findViewById(R.id.undo_bar);\n        mUndoBarInitialMargin = getActivity().getResources()\n                .getDimensionPixelOffset(R.dimen.alarm_undo_bar_horizontal_margin);\n        mUndoFrame = v.findViewById(R.id.undo_frame);\n        mUndoFrame.setOnTouchListener(this);\n\n        mFooterView = v.findViewById(R.id.alarms_footer_view);\n        mFooterView.setOnTouchListener(this);\n\n        // Timeline layout only exists in tablet landscape mode for now.\n        if (mTimelineLayout != null) {\n            mTimelineView = (AlarmTimelineView) v.findViewById(R.id.alarm_timeline_view);\n            mTimelineViewWidth = getActivity().getResources()\n                    .getDimensionPixelOffset(R.dimen.alarm_timeline_layout_width);\n        }\n\n        mAdapter = new AlarmItemAdapter(getActivity(),\n                expandedIds, repeatCheckedIds, selectedAlarms, previousDayMap, mAlarmsList);\n        mAdapter.registerDataSetObserver(new DataSetObserver() {\n\n            private int prevAdapterCount = -1;\n\n            @Override\n            public void onChanged() {\n\n                final int count = mAdapter.getCount();\n                if (mDeletedAlarm != null \u0026\u0026 prevAdapterCount \u003e count) {\n                    showUndoBar();\n                }\n\n                // If there are no alarms in the adapter...\n                if (count == 0) {\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_red);\n\n                    // ...and if there exists a timeline view (currently only in tablet landscape)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        // ...and if the previous adapter had alarms (indicating a removal)...\n                        if (prevAdapterCount \u003e 0) {\n\n                            // Then animate in the \"no alarms\" icon...\n                            mFadeIn.start();\n\n                            // and animate out the alarm timeline view, expanding the width of the\n                            // alarms list / undo bar.\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mCollapseInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.addListener(new AnimatorListener() {\n\n                                @Override\n                                public void onAnimationCancel(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(false);\n                                }\n\n                                @Override\n                                public void onAnimationRepeat(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationStart(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(true);\n                                }\n\n                            });\n                            animator.start();\n                        } else {\n                            // If the previous adapter did not have alarms, no animation needed,\n                            // just hide the timeline view and show the \"no alarms\" icon.\n                            mTimelineLayout.setVisibility(View.GONE);\n                            mEmptyView.setVisibility(View.VISIBLE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just show the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.VISIBLE);\n                    }\n                } else {\n\n                    // Otherwise, if the adapter DOES contain alarms...\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_normal);\n\n                    // ...and if there exists a timeline view (currently in tablet landscape mode)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        mTimelineLayout.setVisibility(View.VISIBLE);\n                        // ...and if the previous adapter did not have alarms (indicating an add)\n                        if (prevAdapterCount == 0) {\n\n                            // Then, animate to hide the \"no alarms\" icon...\n                            mFadeOut.start();\n\n                            // and animate to show the timeline view, reducing the width of the\n                            // alarms list / undo bar.\n                            ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mExpandInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    ((FrameLayout.LayoutParams) mAlarmsView.getLayoutParams())\n                                        .setMargins(0, 0, (int) -rightOffset, 0);\n                                    mAlarmsView.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.start();\n                        } else {\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            mEmptyView.setVisibility(View.GONE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin + mTimelineViewWidth);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just hide the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.GONE);\n                    }\n                }\n\n                // Cache this adapter's count for when the adapter changes.\n                prevAdapterCount = count;\n                super.onChanged();\n            }\n        });\n\n        if (mRingtoneTitleCache == null) {\n            mRingtoneTitleCache = new Bundle();\n        }\n\n        mAlarmsList.setAdapter(mAdapter);\n        mAlarmsList.setVerticalScrollBarEnabled(true);\n        mAlarmsList.setOnCreateContextMenuListener(this);\n\n        mAudioManager = (AudioManager)getActivity().getSystemService(Context.AUDIO_SERVICE);\n\n\n        if (mUndoShowing) {\n            showUndoBar();\n        }\n        return v;\n    }\n\n    private void setUndoBarRightMargin(int margin) {\n        FrameLayout.LayoutParams params =\n                (FrameLayout.LayoutParams) mUndoBar.getLayoutParams();\n        ((FrameLayout.LayoutParams) mUndoBar.getLayoutParams())\n            .setMargins(params.leftMargin, params.topMargin, margin, params.bottomMargin);\n        mUndoBar.requestLayout();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Check if another app asked us to create a blank new alarm.\n        final Intent intent = getActivity().getIntent();\n        if (intent.hasExtra(ALARM_CREATE_NEW_INTENT_EXTRA)) {\n            if (intent.getBooleanExtra(ALARM_CREATE_NEW_INTENT_EXTRA, false)) {\n                // An external app asked us to create a blank alarm.\n                startCreatingAlarm();\n            }\n\n            // Remove the CREATE_NEW extra now that we've processed it.\n            intent.removeExtra(ALARM_CREATE_NEW_INTENT_EXTRA);\n        } else if (intent.hasExtra(SCROLL_TO_ALARM_INTENT_EXTRA)) {\n            long alarmId = intent.getLongExtra(SCROLL_TO_ALARM_INTENT_EXTRA, Alarm.INVALID_ID);\n            if (alarmId != Alarm.INVALID_ID) {\n                mScrollToAlarmId = alarmId;\n                if (mCursorLoader != null \u0026\u0026 mCursorLoader.isStarted()) {\n                    // We need to force a reload here to make sure we have the latest view\n                    // of the data to scroll to.\n                    mCursorLoader.forceLoad();\n                }\n            }\n\n            // Remove the SCROLL_TO_ALARM extra now that we've processed it.\n            intent.removeExtra(SCROLL_TO_ALARM_INTENT_EXTRA);\n        } else {\n            // If alarm stream volume is 0, show a warning\n            if (mAudioManager.getStreamVolume(AudioManager.STREAM_ALARM) == 0) {\n                showSilentWarningBar();\n            }\n\n        }\n\n        // Make sure to use the child FragmentManager. We have to use that one for the\n        // case where an intent comes in telling the activity to load the timepicker,\n        // which means we have to use that one everywhere so that the fragment can get\n        // correctly picked up here if it's open.\n        TimePickerDialog tpd = (TimePickerDialog) getChildFragmentManager().\n                findFragmentByTag(AlarmUtils.FRAG_TAG_TIME_PICKER);\n        if (tpd != null) {\n            // The dialog is already open so we need to set the listener again.\n            tpd.setOnTimeSetListener(this);\n        }\n\n        // Update the profile status and register the profile observer\n        getActivity().getContentResolver().registerContentObserver(\n                PROFILES_SETTINGS_URI, false, mProfileObserver);\n        updateProfilesStatus();\n    }\n\n    private void hideUndoBar(boolean animate, MotionEvent event) {\n        if (mUndoBar != null) {\n            mUndoFrame.setVisibility(View.GONE);\n            if (event != null \u0026\u0026 mUndoBar.isEventInToastBar(event)) {\n                // Avoid touches inside the undo bar.\n                return;\n            }\n            mUndoBar.hide(animate);\n        }\n        mDeletedAlarm = null;\n        mUndoShowing = false;\n    }\n\n    private void showUndoBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                asyncAddAlarm(mDeletedAlarm);\n                mDeletedAlarm = null;\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.alarm_deleted), true,0, R.string.alarm_undo, true);\n    }\n\n    private void showSilentWarningBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                mAudioManager.adjustStreamVolume(AudioManager.STREAM_ALARM, AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.warn_silent_alarm_title), true, R.drawable.ic_menu_alarms,\n        0, true);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLongArray(KEY_EXPANDED_IDS, mAdapter.getExpandedArray());\n        outState.putLongArray(KEY_REPEAT_CHECKED_IDS, mAdapter.getRepeatArray());\n        outState.putLongArray(KEY_SELECTED_ALARMS, mAdapter.getSelectedAlarmsArray());\n        outState.putBundle(KEY_RINGTONE_TITLE_CACHE, mRingtoneTitleCache);\n        outState.putParcelable(KEY_DELETED_ALARM, mDeletedAlarm);\n        outState.putBoolean(KEY_UNDO_SHOWING, mUndoShowing);\n        outState.putBundle(KEY_PREVIOUS_DAY_MAP, mAdapter.getPreviousDaysOfWeekMap());\n        outState.putParcelable(KEY_SELECTED_ALARM, mSelectedAlarm);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        ToastMaster.cancelToast();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        // When the user places the app in the background by pressing \"home\",\n        // dismiss the toast bar. However, since there is no way to determine if\n        // home was pressed, just dismiss any existing toast bar when restarting\n        // the app.\n        hideUndoBar(false, null);\n\n        // Unregister the profile observer\n        getActivity().getContentResolver().unregisterContentObserver(mProfileObserver);\n    }\n\n    // Callback used by TimePickerDialog\n    @Override\n    public void onTimeSet(RadialPickerLayout view, int hourOfDay, int minute) {\n        if (mSelectedAlarm == null) {\n            // If mSelectedAlarm is null then we're creating a new alarm.\n            Alarm a = new Alarm();\n            a.alert = RingtoneManager.getActualDefaultRingtoneUri(getActivity(),\n                    RingtoneManager.TYPE_ALARM);\n            if (a.alert == null) {\n                a.alert = Uri.parse(\"content://settings/system/alarm_alert\");\n            }\n            a.hour = hourOfDay;\n            a.minutes = minute;\n            a.enabled = true;\n            asyncAddAlarm(a);\n        } else {\n            mSelectedAlarm.hour = hourOfDay;\n            mSelectedAlarm.minutes = minute;\n            mSelectedAlarm.enabled = true;\n            mScrollToAlarmId = mSelectedAlarm.id;\n            asyncUpdateAlarm(mSelectedAlarm, true);\n            mSelectedAlarm = null;\n        }\n    }\n\n    private void showLabelDialog(final Alarm alarm) {\n        final FragmentTransaction ft = getFragmentManager().beginTransaction();\n        final Fragment prev = getFragmentManager().findFragmentByTag(\"label_dialog\");\n        if (prev != null) {\n            ft.remove(prev);\n        }\n        ft.addToBackStack(null);\n\n        // Create and show the dialog.\n        final LabelDialogFragment newFragment =\n                LabelDialogFragment.newInstance(alarm, alarm.label, getTag());\n        newFragment.show(ft, \"label_dialog\");\n    }\n\n    public void setLabel(Alarm alarm, String label) {\n        alarm.label = label;\n        asyncUpdateAlarm(alarm, false);\n    }\n\n    @Override\n    public Loader\u003cCursor\u003e onCreateLoader(int id, Bundle args) {\n        return Alarm.getAlarmsCursorLoader(getActivity());\n    }\n\n    @Override\n    public void onLoadFinished(Loader\u003cCursor\u003e cursorLoader, final Cursor data) {\n        mAdapter.swapCursor(data);\n        if (mScrollToAlarmId != -1) {\n            scrollToAlarm(mScrollToAlarmId);\n            mScrollToAlarmId = -1;\n        }\n    }\n\n    /**\n     * Scroll to alarm with given alarm id.\n     *\n     * @param alarmId The alarm id to scroll to.\n     */\n    private void scrollToAlarm(long alarmId) {\n        int alarmPosition = -1;\n        for (int i = 0; i \u003c mAdapter.getCount(); i++) {\n            long id = mAdapter.getItemId(i);\n            if (id == alarmId) {\n                alarmPosition = i;\n                break;\n            }\n        }\n\n        if (alarmPosition \u003e= 0) {\n            mAdapter.setNewAlarm(alarmId);\n            mAlarmsList.smoothScrollToPositionFromTop(alarmPosition, 0);\n        } else {\n            // Trying to display a deleted alarm should only happen from a missed notification for\n            // an alarm that has been marked deleted after use.\n            Context context = getActivity().getApplicationContext();\n            Toast toast = Toast.makeText(context, R.string.missed_alarm_has_been_deleted,\n                    Toast.LENGTH_LONG);\n            ToastMaster.setToast(toast);\n            toast.show();\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader\u003cCursor\u003e cursorLoader) {\n        mAdapter.swapCursor(null);\n    }\n\n    private void launchRingTonePicker(final Alarm alarm) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.alarm_picker_title).setItems(\n                R.array.ringtone_picker_entries,\n\n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        switch (which) {\n                            case 0:\n                                launchSingleRingTonePicker(alarm);\n                                break;\n                            case 1:\n                                alarm.alert = MultiPlayer.RANDOM_URI;\n                                asyncUpdateAlarm(alarm, false);\n                                break;\n                        }\n                    }\n                });\n        AlertDialog d = builder.create();\n        d.show();\n    }\n\n    private void launchSingleRingTonePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;\n        final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, oldRingtone);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, false);\n        startActivityForResult(intent, REQUEST_CODE_RINGTONE);\n    }\n\n    private void launchProfilePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        final Intent intent = new Intent(ProfileManager.ACTION_PROFILE_PICKER);\n\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_EXISTING_UUID, alarm.profile.toString());\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_SHOW_NONE, true);\n        startActivityForResult(intent, REQUEST_CODE_PROFILE);\n    }\n\n    private void saveRingtoneUri(Intent intent) {\n        Uri uri = intent.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);\n        if (uri == null) {\n            uri = Alarm.NO_RINGTONE_URI;\n        }\n        mSelectedAlarm.alert = uri;\n\n        // Save the last selected ringtone as the default for new alarms\n        if (!Alarm.NO_RINGTONE_URI.equals(uri)) {\n            RingtoneManager.setActualDefaultRingtoneUri(\n                    getActivity(), RingtoneManager.TYPE_ALARM, uri);\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private void saveProfile(Intent intent) {\n        final String uuid = intent.getStringExtra(ProfileManager.EXTRA_PROFILE_PICKED_UUID);\n        if (uuid != null) {\n            try {\n                mSelectedAlarm.profile = UUID.fromString(uuid);\n            } catch (IllegalArgumentException ex) {\n                mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n            }\n        } else {\n            mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private boolean isProfilesEnabled() {\n        return Settings.System.getInt(getActivity().getContentResolver(),\n                Settings.System.SYSTEM_PROFILES_ENABLED, 1) == 1;\n    }\n\n    private String getProfileName(Alarm alarm) {\n        if (!isProfilesEnabled() || alarm.profile.equals(ProfileManager.NO_PROFILE)) {\n            return getString(R.string.profile_no_selected);\n        }\n        Profile profile = mProfileManager.getProfile(alarm.profile);\n        if (profile == null) {\n            return getString(R.string.profile_no_selected);\n        }\n        return profile.getName();\n    }\n\n    private void updateProfilesStatus() {\n        // Need to refresh the data\n        if (mAdapter != null) {\n            mAdapter.notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == Activity.RESULT_OK) {\n            switch (requestCode) {\n                case REQUEST_CODE_RINGTONE:\n                    saveRingtoneUri(data);\n                    break;\n                case REQUEST_CODE_PROFILE:\n                    saveProfile(data);\n                default:\n                    Log.w(\"Unhandled request code in onActivityResult: \" + requestCode);\n            }\n        }\n    }\n\n    private class ProfilesObserver extends ContentObserver {\n        public ProfilesObserver(Handler handler) {\n            super(handler);\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n            onChange(selfChange, null);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            if (uri == null) return;\n            if (PROFILES_SETTINGS_URI.equals(uri)) {\n                mHandler.removeMessages(MSG_PROFILE_STATUS_CHANGE);\n                mHandler.sendEmptyMessage(MSG_PROFILE_STATUS_CHANGE);\n            }\n        }\n    }\n\n    public class AlarmItemAdapter extends CursorAdapter {\n        private static final int EXPAND_DURATION = 300;\n        private static final int COLLAPSE_DURATION = 250;\n\n        private final Context mContext;\n        private final LayoutInflater mFactory;\n        private final String[] mShortWeekDayStrings;\n        private final String[] mLongWeekDayStrings;\n        private final int mColorLit;\n        private final int mColorDim;\n        private final int mBackgroundColorExpanded;\n        private final int mBackgroundColor;\n        private final Typeface mRobotoNormal;\n        private final Typeface mRobotoBold;\n        private final ListView mList;\n\n        private final HashSet\u003cLong\u003e mExpanded = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mRepeatChecked = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mSelectedAlarms = new HashSet\u003cLong\u003e();\n        private Bundle mPreviousDaysOfWeekMap = new Bundle();\n\n        private final boolean mHasVibrator;\n        private final int mCollapseExpandHeight;\n\n        // This determines the order in which it is shown and processed in the UI.\n        // The array is filled when the adapter is created\n        private final int[] DAY_ORDER = new int[7];\n\n        public class ItemHolder {\n\n            // views for optimization\n            LinearLayout alarmItem;\n            TextTime clock;\n            Switch onoff;\n            TextView daysOfWeek;\n            TextView label;\n            ImageView delete;\n            View expandArea;\n            View summary;\n            TextView clickableLabel;\n            CheckBox repeat;\n            LinearLayout repeatDays;\n            ViewGroup[] dayButtonParents = new ViewGroup[7];\n            ToggleButton[] dayButtons = new ToggleButton[7];\n            CheckBox vibrate;\n            CheckBox increasingVolume;\n            TextView ringtone;\n            TextView profile;\n            View hairLine;\n            View arrow;\n            View collapseExpandArea;\n            View footerFiller;\n\n            // Other states\n            Alarm alarm;\n        }\n\n        // Used for scrolling an expanded item in the list to make sure it is fully visible.\n        private long mScrollAlarmId = -1;\n        private final Runnable mScrollRunnable = new Runnable() {\n            @Override\n            public void run() {\n                if (mScrollAlarmId != -1) {\n                    View v = getViewById(mScrollAlarmId);\n                    if (v != null) {\n                        Rect rect = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n                        mList.requestChildRectangleOnScreen(v, rect, false);\n                    }\n                    mScrollAlarmId = -1;\n                }\n            }\n        };\n\n        public AlarmItemAdapter(Context context, long[] expandedIds, long[] repeatCheckedIds,\n                long[] selectedAlarms, Bundle previousDaysOfWeekMap, ListView list) {\n            super(context, null, 0);\n            mContext = context;\n            mFactory = LayoutInflater.from(context);\n            mList = list;\n\n            DateFormatSymbols dfs = new DateFormatSymbols();\n            mShortWeekDayStrings = dfs.getShortWeekdays();\n            mLongWeekDayStrings = dfs.getWeekdays();\n            int firstDayOfWeek = Calendar.getInstance(Locale.getDefault()).getFirstDayOfWeek();\n            int j = 0;\n            for (int i = firstDayOfWeek; i \u003c= DAY_ORDER.length; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n            for (int i = Calendar.SUNDAY; i \u003c firstDayOfWeek; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n\n            Resources res = mContext.getResources();\n            mColorLit = res.getColor(R.color.clock_white);\n            mColorDim = res.getColor(R.color.clock_gray);\n            mBackgroundColorExpanded = res.getColor(R.color.alarm_whiteish);\n            mBackgroundColor = R.drawable.alarm_background_normal;\n\n            mRobotoBold = Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\n            mRobotoNormal = Typeface.create(\"sans-serif-condensed\", Typeface.NORMAL);\n\n            if (expandedIds != null) {\n                buildHashSetFromArray(expandedIds, mExpanded);\n            }\n            if (repeatCheckedIds != null) {\n                buildHashSetFromArray(repeatCheckedIds, mRepeatChecked);\n            }\n            if (previousDaysOfWeekMap != null) {\n                mPreviousDaysOfWeekMap = previousDaysOfWeekMap;\n            }\n            if (selectedAlarms != null) {\n                buildHashSetFromArray(selectedAlarms, mSelectedAlarms);\n            }\n\n            mHasVibrator = ((Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE))\n                    .hasVibrator();\n\n            mCollapseExpandHeight = (int) res.getDimension(R.dimen.collapse_expand_height);\n        }\n\n        public void removeSelectedId(int id) {\n            mSelectedAlarms.remove(id);\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (!getCursor().moveToPosition(position)) {\n                // May happen if the last alarm was deleted and the cursor refreshed while the\n                // list is updated.\n                Log.v(\"couldn't move cursor to position \" + position);\n                return null;\n            }\n            View v;\n            if (convertView == null) {\n                v = newView(mContext, getCursor(), parent);\n            } else {\n                // TODO temporary hack to prevent the convertView from not having stuff we need.\n                boolean badConvertView = convertView.findViewById(R.id.digital_clock) == null;\n                // Do a translation check to test for animation. Change this to something more\n                // reliable and robust in the future.\n                if (convertView.getTranslationX() != 0 || convertView.getTranslationY() != 0 ||\n                        badConvertView) {\n                    // view was animated, reset\n                    v = newView(mContext, getCursor(), parent);\n                } else {\n                    v = convertView;\n                }\n            }\n            bindView(v, mContext, getCursor());\n            ItemHolder holder = (ItemHolder) v.getTag();\n\n            // We need the footer for the last element of the array to allow the user to scroll\n            // the item beyond the bottom button bar, which obscures the view.\n            holder.footerFiller.setVisibility(position \u003c getCount() - 1 ? View.GONE : View.VISIBLE);\n            return v;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            final View view = mFactory.inflate(R.layout.alarm_time, parent, false);\n            setNewHolder(view);\n            return view;\n        }\n\n        /**\n         * In addition to changing the data set for the alarm list, swapCursor is now also\n         * responsible for preparing the list view's pre-draw operation for any animations that\n         * need to occur if an alarm was removed or added.\n         */\n        @Override\n        public synchronized Cursor swapCursor(Cursor cursor) {\n            Cursor c = super.swapCursor(cursor);\n\n            if (mItemIdTopMap.isEmpty() \u0026\u0026 mAddedAlarm == null) {\n                return c;\n            }\n\n            final ListView list = mAlarmsList;\n            final ViewTreeObserver observer = list.getViewTreeObserver();\n\n            /*\n             * Add a pre-draw listener to the observer to prepare for any possible animations to\n             * the alarms within the list view.  The animations will occur if an alarm has been\n             * removed or added.\n             *\n             * For alarm removal, the remaining children should all retain their initial starting\n             * positions, and transition to their new positions.\n             *\n             * For alarm addition, the other children should all retain their initial starting\n             * positions, transition to their new positions, and at the end of that transition, the\n             * newly added alarm should appear in the designated space.\n             */\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n\n                private View mAddedView;\n\n                @Override\n                public boolean onPreDraw() {\n                    // Remove the pre-draw listener, as this only needs to occur once.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    boolean firstAnimation = true;\n                    int firstVisiblePosition = list.getFirstVisiblePosition();\n\n                    // Iterate through the children to prepare the add/remove animation.\n                    for (int i = 0; i\u003c list.getChildCount(); i++) {\n                        final View child = list.getChildAt(i);\n\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n\n                        // If this is the added alarm, set it invisible for now, and animate later.\n                        if (mAddedAlarm != null \u0026\u0026 itemId == mAddedAlarm.id) {\n                            mAddedView = child;\n                            mAddedView.setAlpha(0.0f);\n                            continue;\n                        }\n\n                        // The cached starting position of the child view.\n                        Integer startTop = mItemIdTopMap.get(itemId);\n                        // The new starting position of the child view.\n                        int top = child.getTop();\n\n                        // If there is no cached starting position, determine whether the item has\n                        // come from the top of bottom of the list view.\n                        if (startTop == null) {\n                            int childHeight = child.getHeight() + list.getDividerHeight();\n                            startTop = top + (i \u003e 0 ? childHeight : -childHeight);\n                        }\n\n                        Log.d(\"Start Top: \" + startTop + \", Top: \" + top);\n                        // If the starting position of the child view is different from the\n                        // current position, animate the child.\n                        if (startTop != top) {\n                            int delta = startTop - top;\n                            child.setTranslationY(delta);\n                            child.animate().setDuration(ANIMATION_DURATION).translationY(0);\n                            final View addedView = mAddedView;\n                            if (firstAnimation) {\n\n                                // If this is the first child being animated, then after the\n                                // animation is complete, and animate in the added alarm (if one\n                                // exists).\n                                child.animate().withEndAction(new Runnable() {\n\n                                    @Override\n                                    public void run() {\n\n\n                                        // If there was an added view, animate it in after\n                                        // the other views have animated.\n                                        if (addedView != null) {\n                                            addedView.animate().alpha(1.0f)\n                                                .setDuration(ANIMATION_DURATION)\n                                                .withEndAction(new Runnable() {\n\n                                                    @Override\n                                                    public void run() {\n                                                        // Re-enable the list after the add\n                                                        // animation is complete.\n                                                        list.setEnabled(true);\n                                                    }\n\n                                                });\n                                        } else {\n                                            // Re-enable the list after animations are complete.\n                                            list.setEnabled(true);\n                                        }\n                                    }\n\n                                });\n                                firstAnimation = false;\n                            }\n                        }\n                    }\n\n                    // If there were no child views (outside of a possible added view)\n                    // that require animation...\n                    if (firstAnimation) {\n                        if (mAddedView != null) {\n                            // If there is an added view, prepare animation for the added view.\n                            Log.d(\"Animating added view...\");\n                            mAddedView.animate().alpha(1.0f)\n                                .setDuration(ANIMATION_DURATION)\n                                .withEndAction(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        // Re-enable the list after animations are complete.\n                                        list.setEnabled(true);\n                                    }\n                                });\n                        } else {\n                            // Re-enable the list after animations are complete.\n                            list.setEnabled(true);\n                        }\n                    }\n\n                    mAddedAlarm = null;\n                    mItemIdTopMap.clear();\n                    return true;\n                }\n            });\n            return c;\n        }\n\n        private void setNewHolder(View view) {\n            // standard view holder optimization\n            final ItemHolder holder = new ItemHolder();\n            holder.alarmItem = (LinearLayout) view.findViewById(R.id.alarm_item);\n            holder.clock = (TextTime) view.findViewById(R.id.digital_clock);\n            holder.onoff = (Switch) view.findViewById(R.id.onoff);\n            holder.onoff.setTypeface(mRobotoNormal);\n            holder.daysOfWeek = (TextView) view.findViewById(R.id.daysOfWeek);\n            holder.label = (TextView) view.findViewById(R.id.label);\n            holder.delete = (ImageView) view.findViewById(R.id.delete);\n            holder.summary = view.findViewById(R.id.summary);\n            holder.expandArea = view.findViewById(R.id.expand_area);\n            holder.hairLine = view.findViewById(R.id.hairline);\n            holder.arrow = view.findViewById(R.id.arrow);\n            holder.repeat = (CheckBox) view.findViewById(R.id.repeat_onoff);\n            holder.clickableLabel = (TextView) view.findViewById(R.id.edit_label);\n            holder.repeatDays = (LinearLayout) view.findViewById(R.id.repeat_days);\n            holder.collapseExpandArea = view.findViewById(R.id.collapse_expand);\n            holder.footerFiller = view.findViewById(R.id.alarm_footer_filler);\n            holder.footerFiller.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // Do nothing.\n                }\n            });\n\n            // Build button for each day.\n            for (int i = 0; i \u003c 7; i++) {\n                final ViewGroup viewgroup = (ViewGroup) mFactory.inflate(R.layout.day_button,\n                        holder.repeatDays, false);\n                final ToggleButton button = (ToggleButton) viewgroup.getChildAt(0);\n                final int dayToShowIndex = DAY_ORDER[i];\n                button.setText(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOn(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOff(mShortWeekDayStrings[dayToShowIndex]);\n                button.setContentDescription(mLongWeekDayStrings[dayToShowIndex]);\n                holder.repeatDays.addView(viewgroup);\n                holder.dayButtons[i] = button;\n                holder.dayButtonParents[i] = viewgroup;\n            }\n            holder.vibrate = (CheckBox) view.findViewById(R.id.vibrate_onoff);\n            holder.increasingVolume = (CheckBox) view.findViewById(R.id.increasing_volume_onoff);\n            holder.ringtone = (TextView) view.findViewById(R.id.choose_ringtone);\n            holder.profile = (TextView) view.findViewById(R.id.choose_profile);\n\n            view.setTag(holder);\n        }\n\n        @Override\n        public void bindView(final View view, Context context, final Cursor cursor) {\n            final Alarm alarm = new Alarm(cursor);\n            Object tag = view.getTag();\n            if (tag == null) {\n                // The view was converted but somehow lost its tag.\n                setNewHolder(view);\n            }\n            final ItemHolder itemHolder = (ItemHolder) tag;\n            itemHolder.alarm = alarm;\n\n            // We must unset the listener first because this maybe a recycled view so changing the\n            // state would affect the wrong alarm.\n            itemHolder.onoff.setOnCheckedChangeListener(null);\n            itemHolder.onoff.setChecked(alarm.enabled);\n\n            if (mSelectedAlarms.contains(itemHolder.alarm.id)) {\n                itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n                setItemAlpha(itemHolder, true);\n                itemHolder.onoff.setEnabled(false);\n            } else {\n                itemHolder.onoff.setEnabled(true);\n                itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n                setItemAlpha(itemHolder, itemHolder.onoff.isChecked());\n            }\n            itemHolder.clock.setFormat(\n                    (int)mContext.getResources().getDimension(R.dimen.alarm_label_size));\n            itemHolder.clock.setTime(alarm.hour, alarm.minutes);\n            itemHolder.clock.setClickable(true);\n            itemHolder.clock.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    mSelectedAlarm = itemHolder.alarm;\n                    AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                            alarm, AlarmClockFragment.this\n                            , DateFormat.is24HourFormat(getActivity()));\n                    expandAlarm(itemHolder, true);\n                    itemHolder.alarmItem.post(mScrollRunnable);\n                }\n            });\n\n            final CompoundButton.OnCheckedChangeListener onOffListener =\n                    new CompoundButton.OnCheckedChangeListener() {\n                        @Override\n                        public void onCheckedChanged(CompoundButton compoundButton,\n                                boolean checked) {\n                            if (checked != alarm.enabled) {\n                                setItemAlpha(itemHolder, checked);\n                                alarm.enabled = checked;\n                                asyncUpdateAlarm(alarm, alarm.enabled);\n                            }\n                        }\n                    };\n\n            itemHolder.onoff.setOnCheckedChangeListener(onOffListener);\n\n            boolean expanded = isAlarmExpanded(alarm);\n            itemHolder.expandArea.setVisibility(expanded? View.VISIBLE : View.GONE);\n            itemHolder.summary.setVisibility(expanded? View.GONE : View.VISIBLE);\n\n            String labelSpace = \"\";\n            // Set the repeat text or leave it blank if it does not repeat.\n            final String daysOfWeekStr =\n                    alarm.daysOfWeek.toString(AlarmClockFragment.this.getActivity(), false);\n            if (daysOfWeekStr != null \u0026\u0026 daysOfWeekStr.length() != 0) {\n                itemHolder.daysOfWeek.setText(daysOfWeekStr);\n                itemHolder.daysOfWeek.setContentDescription(alarm.daysOfWeek.toAccessibilityString(\n                        AlarmClockFragment.this.getActivity()));\n                itemHolder.daysOfWeek.setVisibility(View.VISIBLE);\n                labelSpace = \"  \";\n                itemHolder.daysOfWeek.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n\n            } else {\n                itemHolder.daysOfWeek.setVisibility(View.GONE);\n            }\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() != 0) {\n                itemHolder.label.setText(alarm.label + labelSpace);\n                itemHolder.label.setVisibility(View.VISIBLE);\n                itemHolder.label.setContentDescription(\n                        mContext.getResources().getString(R.string.label_description) + \" \"\n                        + alarm.label);\n                itemHolder.label.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n            } else {\n                itemHolder.label.setVisibility(View.GONE);\n            }\n\n            itemHolder.delete.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    mDeletedAlarm = alarm;\n\n                    view.animate().setDuration(ANIMATION_DURATION).alpha(0).translationY(-1)\n                    .withEndAction(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            asyncDeleteAlarm(mDeletedAlarm, view);\n                        }\n                    });\n                }\n            });\n\n            if (expanded) {\n                expandAlarm(itemHolder, false);\n            } else {\n                collapseAlarm(itemHolder, false);\n            }\n\n            itemHolder.alarmItem.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    if (isAlarmExpanded(alarm)) {\n                        collapseAlarm(itemHolder, true);\n                    } else {\n                        expandAlarm(itemHolder, true);\n                    }\n                }\n            });\n\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n        }\n\n        private void bindExpandArea(final ItemHolder itemHolder, final Alarm alarm) {\n            // Views in here are not bound until the item is expanded.\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() \u003e 0) {\n                itemHolder.clickableLabel.setText(alarm.label);\n                itemHolder.clickableLabel.setTextColor(mColorLit);\n            } else {\n                itemHolder.clickableLabel.setText(R.string.label);\n                itemHolder.clickableLabel.setTextColor(mColorDim);\n            }\n            itemHolder.clickableLabel.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    showLabelDialog(alarm);\n                }\n            });\n\n            if (mRepeatChecked.contains(alarm.id) || itemHolder.alarm.daysOfWeek.isRepeating()) {\n                itemHolder.repeat.setChecked(true);\n                itemHolder.repeatDays.setVisibility(View.VISIBLE);\n            } else {\n                itemHolder.repeat.setChecked(false);\n                itemHolder.repeatDays.setVisibility(View.GONE);\n            }\n            itemHolder.repeat.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    final boolean checked = ((CheckBox) view).isChecked();\n                    if (checked) {\n                        // Show days\n                        itemHolder.repeatDays.setVisibility(View.VISIBLE);\n                        mRepeatChecked.add(alarm.id);\n\n                        // Set all previously set days\n                        // or\n                        // Set all days if no previous.\n                        final int bitSet = mPreviousDaysOfWeekMap.getInt(\"\" + alarm.id);\n                        alarm.daysOfWeek.setBitSet(bitSet);\n                        if (!alarm.daysOfWeek.isRepeating()) {\n                            alarm.daysOfWeek.setDaysOfWeek(true, DAY_ORDER);\n                        }\n                        updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n                    } else {\n                        itemHolder.repeatDays.setVisibility(View.GONE);\n                        mRepeatChecked.remove(alarm.id);\n\n                        // Remember the set days in case the user wants it back.\n                        final int bitSet = alarm.daysOfWeek.getBitSet();\n                        mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id, bitSet);\n\n                        // Remove all repeat days\n                        alarm.daysOfWeek.clearAllDays();\n                    }\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n            for (int i = 0; i \u003c 7; i++) {\n                final int buttonIndex = i;\n\n                itemHolder.dayButtonParents[i].setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        itemHolder.dayButtons[buttonIndex].toggle();\n                        final boolean checked = itemHolder.dayButtons[buttonIndex].isChecked();\n                        int day = DAY_ORDER[buttonIndex];\n                        alarm.daysOfWeek.setDaysOfWeek(checked, day);\n                        if (checked) {\n                            turnOnDayOfWeek(itemHolder, buttonIndex);\n                        } else {\n                            turnOffDayOfWeek(itemHolder, buttonIndex);\n\n                            // See if this was the last day, if so, un-check the repeat box.\n                            if (!alarm.daysOfWeek.isRepeating()) {\n                                itemHolder.repeatDays.setVisibility(View.GONE);\n                                itemHolder.repeat.setTextColor(mColorDim);\n                                mRepeatChecked.remove(alarm.id);\n\n                                // Set history to no days, so it will be everyday when repeat is\n                                // turned back on\n                                mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id,\n                                        DaysOfWeek.NO_DAYS_SET);\n                            }\n                        }\n                        asyncUpdateAlarm(alarm, false);\n                    }\n                });\n            }\n\n\n            if (!mHasVibrator) {\n                itemHolder.vibrate.setVisibility(View.INVISIBLE);\n            } else {\n                itemHolder.vibrate.setVisibility(View.VISIBLE);\n                if (!alarm.vibrate) {\n                    itemHolder.vibrate.setChecked(false);\n                    itemHolder.vibrate.setTextColor(mColorDim);\n                } else {\n                    itemHolder.vibrate.setChecked(true);\n                    itemHolder.vibrate.setTextColor(mColorLit);\n                }\n            }\n\n            itemHolder.vibrate.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    if (checked) {\n                        itemHolder.vibrate.setTextColor(mColorLit);\n                    } else {\n                        itemHolder.vibrate.setTextColor(mColorDim);\n                    }\n                    alarm.vibrate = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String ringtone;\n            final String ringtitle;\n            if (Alarm.NO_RINGTONE_URI.equals(alarm.alert)) {\n                ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n            } else {\n                ringtitle = getRingToneTitle(alarm.alert);\n                if (ringtitle != null) {\n                    ringtone = ringtitle;\n                } else {\n                    ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n                }\n            }\n            itemHolder.ringtone.setText(ringtone);\n            itemHolder.ringtone.setContentDescription(\n                    mContext.getResources().getString(R.string.ringtone_description) + \" \"\n                            + ringtone);\n            itemHolder.ringtone.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchRingTonePicker(alarm);\n                }\n            });\n\n\n            itemHolder.increasingVolume.setVisibility(View.VISIBLE);\n            itemHolder.increasingVolume.setChecked(alarm.increasingVolume);\n            itemHolder.increasingVolume.setTextColor(\n                    alarm.increasingVolume ? mColorLit : mColorDim);\n            itemHolder.increasingVolume.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    //When action mode is on - simulate long click\n                    itemHolder.increasingVolume.setTextColor(checked ? mColorLit : mColorDim);\n                    alarm.increasingVolume = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String profile = getProfileName(alarm);\n            itemHolder.profile.setText(profile);\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n            itemHolder.profile.setContentDescription(\n                    mContext.getResources().getString(R.string.profile_description, profile));\n            itemHolder.profile.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchProfilePicker(alarm);\n                }\n            });\n        }\n\n        // Sets the alpha of the item except the on/off switch. This gives a visual effect\n        // for enabled/disabled alarm while leaving the on/off switch more visible\n        private void setItemAlpha(ItemHolder holder, boolean enabled) {\n            float alpha = enabled ? 1f : 0.5f;\n            holder.clock.setAlpha(alpha);\n            holder.summary.setAlpha(alpha);\n            holder.expandArea.setAlpha(alpha);\n            holder.delete.setAlpha(alpha);\n            holder.daysOfWeek.setAlpha(alpha);\n        }\n\n        private void updateDaysOfWeekButtons(ItemHolder holder, DaysOfWeek daysOfWeek) {\n            HashSet\u003cInteger\u003e setDays = daysOfWeek.getSetDays();\n            for (int i = 0; i \u003c 7; i++) {\n                if (setDays.contains(DAY_ORDER[i])) {\n                    turnOnDayOfWeek(holder, i);\n                } else {\n                    turnOffDayOfWeek(holder, i);\n                }\n            }\n        }\n\n        public void toggleSelectState(View v) {\n            // long press could be on the parent view or one of its childs, so find the parent view\n            v = getTopParent(v);\n            if (v != null) {\n                long id = ((ItemHolder)v.getTag()).alarm.id;\n                if (mSelectedAlarms.contains(id)) {\n                    mSelectedAlarms.remove(id);\n                } else {\n                    mSelectedAlarms.add(id);\n                }\n            }\n        }\n\n        private View getTopParent(View v) {\n            while (v != null \u0026\u0026 v.getId() != R.id.alarm_item) {\n                v = (View) v.getParent();\n            }\n            return v;\n        }\n\n        public int getSelectedItemsNum() {\n            return mSelectedAlarms.size();\n        }\n\n        private void turnOffDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(false);\n            holder.dayButtons[dayIndex].setTextColor(mColorDim);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoNormal);\n        }\n\n        private void turnOnDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(true);\n            holder.dayButtons[dayIndex].setTextColor(mColorLit);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoBold);\n        }\n\n\n        /**\n         * Does a read-through cache for ringtone titles.\n         *\n         * @param uri The uri of the ringtone.\n         * @return The ringtone title. {@literal null} if no matching ringtone found.\n         */\n        private String getRingToneTitle(Uri uri) {\n            // Try the cache first\n            String title = mRingtoneTitleCache.getString(uri.toString());\n            if (title == null) {\n                if (uri.equals(MultiPlayer.RANDOM_URI)) {\n                    title = mContext.getResources().getString(R.string.alarm_type_random);\n                } else {\n                    // This is slow because a media player is created during Ringtone object creation.\n                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);\n                    if (ringTone != null) {\n                        title = ringTone.getTitle(mContext);\n                    }\n                }\n                if (title != null) {\n                    mRingtoneTitleCache.putString(uri.toString(), title);\n                }\n            }\n            return title;\n        }\n\n        public void setNewAlarm(long alarmId) {\n            mExpanded.add(alarmId);\n        }\n\n        /**\n         * Expands the alarm for editing.\n         *\n         * @param itemHolder The item holder instance.\n         */\n        private void expandAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.add(itemHolder.alarm.id);\n            bindExpandArea(itemHolder, itemHolder.alarm);\n            // Scroll the view to make sure it is fully viewed\n            mScrollAlarmId = itemHolder.alarm.id;\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to visible so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n            itemHolder.expandArea.setVisibility(View.VISIBLE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(180);\n                // We need to translate the hairline up, so the height of the collapseArea\n                // needs to be measured to know how high to translate it.\n                final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n                observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                    @Override\n                    public boolean onPreDraw() {\n                        // We don't want to continue getting called for every listview drawing.\n                        if (observer.isAlive()) {\n                            observer.removeOnPreDrawListener(this);\n                        }\n                        int hairlineHeight = itemHolder.hairLine.getHeight();\n                        int collapseHeight =\n                                itemHolder.collapseExpandArea.getHeight() - hairlineHeight;\n                        itemHolder.hairLine.setTranslationY(-collapseHeight);\n                        return true;\n                    }\n                });\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to VISIBLE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * the height is set back to the starting point so it can be animated down.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    // We don't want to continue getting called for every listview drawing.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    final int collapseHeight = itemHolder.collapseExpandArea.getHeight();\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = collapseHeight - hairlineHeight;\n\n                    // Set the height back to the start state of the animation.\n                    itemHolder.alarmItem.getLayoutParams().height = startingHeight;\n                    // To allow the expandArea to glide in with the expansion animation, set a\n                    // negative top margin, which will animate down to a margin of 0 as the height\n                    // is increased.\n                    // Note that we need to maintain the bottom margin as a fixed value (instead of\n                    // just using a listview, to allow for a flatter hierarchy) to fit the bottom\n                    // bar underneath.\n                    FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                            itemHolder.expandArea.getLayoutParams();\n                    expandParams.setMargins(0, -distance, 0, collapseHeight);\n                    itemHolder.alarmItem.requestLayout();\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(EXPAND_DURATION);\n                    animator.setInterpolator(mExpandInterpolator);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) -((1 - value) * distance), 0, collapseHeight);\n                            itemHolder.arrow.setRotation(180 * value);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * value);\n                            itemHolder.summary.setAlpha(1 - value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n                            itemHolder.arrow.setRotation(180);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance);\n                            itemHolder.summary.setVisibility(View.GONE);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    // Return false so this draw does not occur to prevent the final frame from\n                    // being drawn for the single frame before the animations start.\n                    return false;\n                }\n            });\n        }\n\n        private boolean isAlarmExpanded(Alarm alarm) {\n            return mExpanded.contains(alarm.id);\n        }\n\n        private void collapseAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.remove(itemHolder.alarm.id);\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to gone so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n            itemHolder.expandArea.setVisibility(View.GONE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(0);\n                itemHolder.hairLine.setTranslationY(0);\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to GONE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * expandArea is set to VISIBLE again so it can be shown animating.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = mCollapseExpandHeight - hairlineHeight;\n\n                    // Re-set the visibilities for the start state of the animation.\n                    itemHolder.expandArea.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setAlpha(1);\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(COLLAPSE_DURATION);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) (value * distance), 0, mCollapseExpandHeight);\n                            itemHolder.arrow.setRotation(180 * (1 - value));\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * (1 - value));\n                            itemHolder.summary.setAlpha(value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    animator.setInterpolator(mCollapseInterpolator);\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(0, 0, 0, mCollapseExpandHeight);\n\n                            itemHolder.expandArea.setVisibility(View.GONE);\n                            itemHolder.arrow.setRotation(0);\n                            itemHolder.hairLine.setTranslationY(0);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    return false;\n                }\n            });\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            return 1;\n        }\n\n        private View getViewById(long id) {\n            for (int i = 0; i \u003c mList.getCount(); i++) {\n                View v = mList.getChildAt(i);\n                if (v != null) {\n                    ItemHolder h = (ItemHolder)(v.getTag());\n                    if (h != null \u0026\u0026 h.alarm.id == id) {\n                        return v;\n                    }\n                }\n            }\n            return null;\n        }\n\n        public long[] getExpandedArray() {\n            int index = 0;\n            long[] ids = new long[mExpanded.size()];\n            for (long id : mExpanded) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getSelectedAlarmsArray() {\n            int index = 0;\n            long[] ids = new long[mSelectedAlarms.size()];\n            for (long id : mSelectedAlarms) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getRepeatArray() {\n            int index = 0;\n            long[] ids = new long[mRepeatChecked.size()];\n            for (long id : mRepeatChecked) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public Bundle getPreviousDaysOfWeekMap() {\n            return mPreviousDaysOfWeekMap;\n        }\n\n        private void buildHashSetFromArray(long[] ids, HashSet\u003cLong\u003e set) {\n            for (long id : ids) {\n                set.add(id);\n            }\n        }\n    }\n\n    private void startCreatingAlarm() {\n        // Set the \"selected\" alarm as null, and we'll create the new one when the timepicker\n        // comes back.\n        mSelectedAlarm = null;\n        AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                null, AlarmClockFragment.this, DateFormat.is24HourFormat(getActivity()));\n    }\n\n    private static AlarmInstance setupAlarmInstance(Context context, Alarm alarm) {\n        ContentResolver cr = context.getContentResolver();\n        AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());\n        newInstance = AlarmInstance.addInstance(cr, newInstance);\n        // Register instance to state manager\n        AlarmStateManager.registerInstance(context, newInstance, true);\n        return newInstance;\n    }\n\n    private void asyncDeleteAlarm(final Alarm alarm, final View viewToRemove) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, Void\u003e deleteTask = new AsyncTask\u003cVoid, Void, Void\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                if (viewToRemove == null) {\n                    return;\n                }\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                final ListView list = mAlarmsList;\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    if (child != viewToRemove) {\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n                        mItemIdTopMap.put(itemId, child.getTop());\n                    }\n                }\n            }\n\n            @Override\n            protected Void doInBackground(Void... parameters) {\n                // Activity may be closed at this point , make sure data is still valid\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n                    AlarmStateManager.deleteAllInstances(context, alarm.id);\n                    Alarm.deleteAlarm(cr, alarm.id);\n                }\n                return null;\n            }\n        };\n        mUndoShowing = true;\n        deleteTask.execute();\n    }\n\n    private void asyncAddAlarm(final Alarm alarm) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                final ListView list = mAlarmsList;\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    int position = firstVisiblePosition + i;\n                    long itemId = mAdapter.getItemId(position);\n                    mItemIdTopMap.put(itemId, child.getTop());\n                }\n            }\n\n            @Override\n            protected AlarmInstance doInBackground(Void... parameters) {\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n\n                    // Add alarm to db\n                    Alarm newAlarm = Alarm.addAlarm(cr, alarm);\n                    mScrollToAlarmId = newAlarm.id;\n\n                    // Create and add instance to db\n                    if (newAlarm.enabled) {\n                        return setupAlarmInstance(context, newAlarm);\n                    }\n                }\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    private void asyncUpdateAlarm(final Alarm alarm, final boolean popToast) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            protected AlarmInstance doInBackground(Void ... parameters) {\n                ContentResolver cr = context.getContentResolver();\n\n                // Dismiss all old instances\n                AlarmStateManager.deleteAllInstances(context, alarm.id);\n\n                // Update alarm\n                Alarm.updateAlarm(cr, alarm);\n                if (alarm.enabled) {\n                    return setupAlarmInstance(context, alarm);\n                }\n\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (popToast \u0026\u0026 instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        hideUndoBar(true, event);\n        return false;\n    }\n}","comments":[],"name":"src/com/android/deskclock/AlarmClockFragment.java"},"src/com/android/deskclock/widget/ActionableToastBar.java":{"a":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.deskclock.widget;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorInflater;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.android.deskclock.R;\n\n/**\n * A custom {@link View} that exposes an action to the user.\n * \u003cp\u003e\n * This is a copy of packages/apps/UnifiedEmail/src/com/android/mail/ui/ActionableToastBar.java\n * with minor modifications.\n */\npublic class ActionableToastBar extends LinearLayout {\n    private boolean mHidden = false;\n    private Animator mShowAnimation;\n    private Animator mHideAnimation;\n    private final int mBottomMarginSizeInConversation;\n\n    /** Icon for the description. */\n    private ImageView mActionDescriptionIcon;\n    /** The clickable view */\n    private View mActionButton;\n    /** Icon for the action button. */\n    private View mActionIcon;\n    /** The view that contains the description. */\n    private TextView mActionDescriptionView;\n    /** The view that contains the text for the action button. */\n    private TextView mActionText;\n    //private ToastBarOperation mOperation;\n\n    public ActionableToastBar(Context context) {\n        this(context, null);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mBottomMarginSizeInConversation = context.getResources().getDimensionPixelSize(\n                R.dimen.toast_bar_bottom_margin_in_conversation);\n        LayoutInflater.from(context).inflate(R.layout.actionable_toast_row, this, true);\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        mActionDescriptionIcon = (ImageView) findViewById(R.id.description_icon);\n        mActionDescriptionView = (TextView) findViewById(R.id.description_text);\n        mActionButton = findViewById(R.id.action_button);\n        mActionIcon = findViewById(R.id.action_icon);\n        mActionText = (TextView) findViewById(R.id.action_text);\n    }\n\n    /**\n     * Tells the view that it will be appearing in the conversation pane\n     * and should adjust its layout parameters accordingly.\n     * @param isInConversationMode true if the view will be shown in the conversation view\n     */\n    public void setConversationMode(boolean isInConversationMode) {\n        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams();\n        params.bottomMargin = isInConversationMode ? mBottomMarginSizeInConversation : 0;\n        setLayoutParams(params);\n    }\n\n    /**\n     * Displays the toast bar and makes it visible. Allows the setting of\n     * parameters to customize the display.\n     * @param listener performs some action when the action button is clicked\n     * @param descriptionIconResourceId resource ID for the description icon or\n     * 0 if no icon should be shown\n     * @param descriptionText a description text to show in the toast bar\n     * @param showActionIcon if true, the action button icon should be shown\n     * @param actionTextResource resource ID for the text to show in the action button\n     * @param replaceVisibleToast if true, this toast should replace any currently visible toast.\n     * Otherwise, skip showing this toast.\n     */\n    public void show(final ActionClickedListener listener, int descriptionIconResourceId,\n            CharSequence descriptionText, boolean showActionIcon, int actionTextResource,\n            boolean replaceVisibleToast) {\n\n        if (!mHidden \u0026\u0026 !replaceVisibleToast) {\n            return;\n        }\n\n        mActionButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View widget) {\n                if (listener != null) {\n                    listener.onActionClicked();\n                }\n                hide(true);\n            }\n        });\n\n        // Set description icon.\n        if (descriptionIconResourceId == 0) {\n            mActionDescriptionIcon.setVisibility(GONE);\n        } else {\n            mActionDescriptionIcon.setVisibility(VISIBLE);\n            mActionDescriptionIcon.setImageResource(descriptionIconResourceId);\n        }\n\n        mActionDescriptionView.setText(descriptionText);\n        mActionIcon.setVisibility(showActionIcon ? VISIBLE : GONE);\n        mActionText.setText(actionTextResource);\n\n        mHidden = false;\n        getShowAnimation().start();\n    }\n\n    /**\n     * Hides the view and resets the state.\n     */\n    public void hide(boolean animate) {\n        // Prevent multiple call to hide.\n        // Also prevent hiding if show animation is going on.\n        if (!mHidden \u0026\u0026 !getShowAnimation().isRunning()) {\n            mHidden = true;\n            if (getVisibility() == View.VISIBLE) {\n                mActionDescriptionView.setText(\"\");\n                mActionButton.setOnClickListener(null);\n                // Hide view once it's clicked.\n                if (animate) {\n                    getHideAnimation().start();\n                } else {\n                    setAlpha(0);\n                    setVisibility(View.GONE);\n                }\n            }\n        }\n    }\n\n    private Animator getShowAnimation() {\n        if (mShowAnimation == null) {\n            mShowAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_in);\n            mShowAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    // There is a tiny change that and hide animation could have finished right\n                    // before the show animation finished.  In that case, the hide will mark the\n                    // view as GONE.  We need to make sure the last one wins.\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n            });\n            mShowAnimation.setTarget(this);\n        }\n        return mShowAnimation;\n    }\n\n    private Animator getHideAnimation() {\n        if (mHideAnimation == null) {\n            mHideAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_out);\n            mHideAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    setVisibility(View.GONE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n            });\n            mHideAnimation.setTarget(this);\n        }\n        return mHideAnimation;\n    }\n\n    public boolean isEventInToastBar(MotionEvent event) {\n        if (!isShown()) {\n            return false;\n        }\n        int[] xy = new int[2];\n        float x = event.getX();\n        float y = event.getY();\n        getLocationOnScreen(xy);\n        return (x \u003e xy[0] \u0026\u0026 x \u003c (xy[0] + getWidth()) \u0026\u0026 y \u003e xy[1] \u0026\u0026 y \u003c xy[1] + getHeight());\n    }\n\n    /**\n     * Classes that wish to perform some action when the action button is clicked\n     * should implement this interface.\n     */\n    public interface ActionClickedListener {\n        public void onActionClicked();\n    }\n}","b":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.deskclock.widget;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorInflater;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.android.deskclock.R;\n\n/**\n * A custom {@link View} that exposes an action to the user.\n * \u003cp\u003e\n * This is a copy of packages/apps/UnifiedEmail/src/com/android/mail/ui/ActionableToastBar.java\n * with minor modifications.\n */\npublic class ActionableToastBar extends LinearLayout {\n    private boolean mHidden = false;\n    private Animator mShowAnimation;\n    private Animator mHideAnimation;\n    private final int mBottomMarginSizeInConversation;\n\n    /** Icon for the description. */\n    private ImageView mActionDescriptionIcon;\n    /** The clickable view */\n    private View mActionButton;\n    /** Icon for the action button. */\n    private ImageView mActionIcon;\n    /** The view that contains the description. */\n    private TextView mActionDescriptionView;\n    /** The view that contains the text for the action button. */\n    private TextView mActionText;\n    //private ToastBarOperation mOperation;\n\n    public ActionableToastBar(Context context) {\n        this(context, null);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mBottomMarginSizeInConversation = context.getResources().getDimensionPixelSize(\n                R.dimen.toast_bar_bottom_margin_in_conversation);\n        LayoutInflater.from(context).inflate(R.layout.actionable_toast_row, this, true);\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        mActionDescriptionIcon = (ImageView) findViewById(R.id.description_icon);\n        mActionDescriptionView = (TextView) findViewById(R.id.description_text);\n        mActionButton = findViewById(R.id.action_button);\n        mActionIcon = (ImageView)findViewById(R.id.action_icon);\n        mActionText = (TextView) findViewById(R.id.action_text);\n    }\n\n    /**\n     * Tells the view that it will be appearing in the conversation pane\n     * and should adjust its layout parameters accordingly.\n     * @param isInConversationMode true if the view will be shown in the conversation view\n     */\n    public void setConversationMode(boolean isInConversationMode) {\n        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams();\n        params.bottomMargin = isInConversationMode ? mBottomMarginSizeInConversation : 0;\n        setLayoutParams(params);\n    }\n\n    /**\n     * Displays the toast bar and makes it visible. Allows the setting of\n     * parameters to customize the display.\n     * @param listener performs some action when the action button is clicked\n     * @param descriptionIconResourceId resource ID for the description icon or\n     * 0 if no icon should be shown\n     * @param descriptionText a description text to show in the toast bar\n     * @param showActionIcon if true, the action button icon should be shown\n     * @param actionTextResource resource ID for the text to show in the action button\n     * @param replaceVisibleToast if true, this toast should replace any currently visible toast.\n     * Otherwise, skip showing this toast.\n     */\n    public void show(final ActionClickedListener listener, int descriptionIconResourceId,\n            CharSequence descriptionText, boolean showActionIcon, int actionIconResourceId,\n            int actionTextResource, boolean replaceVisibleToast) {\n\n        if (!mHidden \u0026\u0026 !replaceVisibleToast) {\n            return;\n        }\n\n        mActionButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View widget) {\n                if (listener != null) {\n                    listener.onActionClicked();\n                }\n                hide(true);\n            }\n        });\n\n        // Set description icon.\n        if (descriptionIconResourceId == 0) {\n            mActionDescriptionIcon.setVisibility(GONE);\n        } else {\n            mActionDescriptionIcon.setVisibility(VISIBLE);\n            mActionDescriptionIcon.setImageResource(descriptionIconResourceId);\n        }\n\n        // Set action icon\n        if (showActionIcon) {\n            mActionIcon.setVisibility(VISIBLE);\n            mActionIcon.setImageResource(actionIconResourceId == 0 ? R.drawable.ic_menu_revert_holo_dark : actionIconResourceId);\n        } else {\n            mActionIcon.setVisibility(GONE);\n        }\n\n        mActionDescriptionView.setText(descriptionText);\n        if (actionTextResource == 0) {\n            mActionText.setVisibility(GONE);\n        } else {\n            mActionText.setVisibility(VISIBLE);\n            mActionText.setText(actionTextResource);\n        }\n\n        mHidden = false;\n        getShowAnimation().start();\n    }\n\n    /**\n     * Hides the view and resets the state.\n     */\n    public void hide(boolean animate) {\n        // Prevent multiple call to hide.\n        // Also prevent hiding if show animation is going on.\n        if (!mHidden \u0026\u0026 !getShowAnimation().isRunning()) {\n            mHidden = true;\n            if (getVisibility() == View.VISIBLE) {\n                mActionDescriptionView.setText(\"\");\n                mActionButton.setOnClickListener(null);\n                // Hide view once it's clicked.\n                if (animate) {\n                    getHideAnimation().start();\n                } else {\n                    setAlpha(0);\n                    setVisibility(View.GONE);\n                }\n            }\n        }\n    }\n\n    private Animator getShowAnimation() {\n        if (mShowAnimation == null) {\n            mShowAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_in);\n            mShowAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    // There is a tiny change that and hide animation could have finished right\n                    // before the show animation finished.  In that case, the hide will mark the\n                    // view as GONE.  We need to make sure the last one wins.\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n            });\n            mShowAnimation.setTarget(this);\n        }\n        return mShowAnimation;\n    }\n\n    private Animator getHideAnimation() {\n        if (mHideAnimation == null) {\n            mHideAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_out);\n            mHideAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    setVisibility(View.GONE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n            });\n            mHideAnimation.setTarget(this);\n        }\n        return mHideAnimation;\n    }\n\n    public boolean isEventInToastBar(MotionEvent event) {\n        if (!isShown()) {\n            return false;\n        }\n        int[] xy = new int[2];\n        float x = event.getX();\n        float y = event.getY();\n        getLocationOnScreen(xy);\n        return (x \u003e xy[0] \u0026\u0026 x \u003c (xy[0] + getWidth()) \u0026\u0026 y \u003e xy[1] \u0026\u0026 y \u003c xy[1] + getHeight());\n    }\n\n    /**\n     * Classes that wish to perform some action when the action button is clicked\n     * should implement this interface.\n     */\n    public interface ActionClickedListener {\n        public void onActionClicked();\n    }\n}","comments":[],"name":"src/com/android/deskclock/widget/ActionableToastBar.java"}}},{"author":"Vladimir Vainer \u003cstr3l0k@gmail.com\u003e","committer":"Michael Bestas \u003cmikeioannina@gmail.com\u003e","message":"Alarm: Show a warning toast when alarm volume is set to silent\n\nChange-Id: I97edae55351101046def5058a2459ab88edf2d0d\n","parentCommit":"ee6e33866f3659abfab9d041ed3abe3bb73d0c7e","revisionId":2,"subject":"Alarm: Show a warning toast when alarm volume is set to silent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     ee6e3386 (Automatic translation import)\nAuthor:     Vladimir Vainer \u003cstr3l0k@gmail.com\u003e\nAuthorDate: 2014-05-11 18:36:09 +0300\nCommit:     Michael Bestas \u003cmikeioannina@gmail.com\u003e\nCommitDate: 2014-05-24 22:22:16 +0300\n\nAlarm: Show a warning toast when alarm volume is set to silent\n\nChange-Id: I97edae55351101046def5058a2459ab88edf2d0d","comments":[],"name":"/COMMIT_MSG"},"res/values/cm_strings.xml":{"a":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     Copyright (C) 2012-2014 The CyanogenMod Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n--\u003e\n\u003cresources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"\u003e\n    \u003c!-- Setting title for showing/hiding the alarm status bar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_title\"\u003eShow icon\u003c/string\u003e\n\n    \u003c!-- Setting summary for showing/hiding the alarm statusbar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_summary\"\u003eShow an icon in the status bar when an alarm is set\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Increasing volume on or off --\u003e\n    \u003cstring name=\"alarm_increasing_volume\"\u003eIncreasing volume\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Choose profile --\u003e\n    \u003cstring name=\"profile_description\"\u003eProfile \u003cxliff:g id=\"profile\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- No profile selected label --\u003e\n    \u003cstring name=\"profile_no_selected\"\u003eNo profile selected\u003c/string\u003e\n\n    \u003c!-- User-defined cities --\u003e\n    \u003cstring name=\"menu_item_add\"\u003eAdd\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_title\"\u003eAdd city\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_city\"\u003eCity:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_timezone\"\u003eTimezone:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_gps_cd\"\u003eTap to localize your current city\u003c/string\u003e\n    \u003cstring name=\"cities_add_loading\"\u003eLoading\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_searching\"\u003eSearching\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_no_results\"\u003eGPS query returns no location results\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_not_available\"\u003eGPS not available\u003c/string\u003e\n    \u003cstring name=\"cities_add_already_exists\"\u003eThe city already exists in the database\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_failed\"\u003eCan\\'t create the city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_title\"\u003eDelete city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_msg\"\u003eDo you want to delete \u003cxliff:g id=\"city\"\u003e%s\u003c/xliff:g\u003e?\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_failed\"\u003eCan\\'t delete the city\u003c/string\u003e\n\n    \u003c!-- Setting title for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_title\"\u003eFlip action\u003c/string\u003e\n\n    \u003c!-- Dialog title of the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"tablet\"\u003eFlip the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"default\"\u003eFlip the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"tablet\"\u003eFlipping the tablet down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"default\"\u003eFlipping the phone down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Setting title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_title\"\u003eShake action\u003c/string\u003e\n\n    \u003c!-- Dialog title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"tablet\"\u003eShake the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"default\"\u003eShake the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"tablet\"\u003eShaking the tablet will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"default\"\u003eShaking the phone will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Summary texts for shake and flip actions --\u003e\n    \u003cstring name=\"action_summary_snooze\"\u003esnooze alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_dismiss\"\u003edismiss alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_do_nothing\"\u003edo nothing\u003c/string\u003e\n\n    \u003c!-- Alarm picker dialog title --\u003e\n    \u003cstring name=\"alarm_picker_title\"\u003eChoose alarm type\u003c/string\u003e\n\n    \u003c!-- Alarm types --\u003e\n    \u003cstring name=\"alarm_type_ringtone\"\u003eRingtone\u003c/string\u003e\n    \u003cstring name=\"alarm_type_random\"\u003eRandomly\u003c/string\u003e\n\u003c/resources\u003e","b":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     Copyright (C) 2012-2014 The CyanogenMod Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n--\u003e\n\u003cresources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"\u003e\n    \u003c!-- Setting title for showing/hiding the alarm status bar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_title\"\u003eShow icon\u003c/string\u003e\n\n    \u003c!-- Setting summary for showing/hiding the alarm statusbar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_summary\"\u003eShow an icon in the status bar when an alarm is set\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Increasing volume on or off --\u003e\n    \u003cstring name=\"alarm_increasing_volume\"\u003eIncreasing volume\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Choose profile --\u003e\n    \u003cstring name=\"profile_description\"\u003eProfile \u003cxliff:g id=\"profile\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- No profile selected label --\u003e\n    \u003cstring name=\"profile_no_selected\"\u003eNo profile selected\u003c/string\u003e\n\n    \u003c!-- User-defined cities --\u003e\n    \u003cstring name=\"menu_item_add\"\u003eAdd\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_title\"\u003eAdd city\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_city\"\u003eCity:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_timezone\"\u003eTimezone:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_gps_cd\"\u003eTap to localize your current city\u003c/string\u003e\n    \u003cstring name=\"cities_add_loading\"\u003eLoading\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_searching\"\u003eSearching\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_no_results\"\u003eGPS query returns no location results\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_not_available\"\u003eGPS not available\u003c/string\u003e\n    \u003cstring name=\"cities_add_already_exists\"\u003eThe city already exists in the database\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_failed\"\u003eCan\\'t create the city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_title\"\u003eDelete city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_msg\"\u003eDo you want to delete \u003cxliff:g id=\"city\"\u003e%s\u003c/xliff:g\u003e?\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_failed\"\u003eCan\\'t delete the city\u003c/string\u003e\n\n    \u003c!-- Setting title for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_title\"\u003eFlip action\u003c/string\u003e\n\n    \u003c!-- Dialog title of the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"tablet\"\u003eFlip the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"default\"\u003eFlip the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"tablet\"\u003eFlipping the tablet down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"default\"\u003eFlipping the phone down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Setting title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_title\"\u003eShake action\u003c/string\u003e\n\n    \u003c!-- Dialog title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"tablet\"\u003eShake the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"default\"\u003eShake the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"tablet\"\u003eShaking the tablet will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"default\"\u003eShaking the phone will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Summary texts for shake and flip actions --\u003e\n    \u003cstring name=\"action_summary_snooze\"\u003esnooze alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_dismiss\"\u003edismiss alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_do_nothing\"\u003edo nothing\u003c/string\u003e\n\n    \u003c!-- Alarm picker dialog title --\u003e\n    \u003cstring name=\"alarm_picker_title\"\u003eChoose alarm type\u003c/string\u003e\n\n    \u003c!-- Alarm types --\u003e\n    \u003cstring name=\"alarm_type_ringtone\"\u003eRingtone\u003c/string\u003e\n    \u003cstring name=\"alarm_type_random\"\u003eRandomly\u003c/string\u003e\n\n    \u003c!-- Warn Silent Alarm title --\u003e\n    \u003cstring name=\"warn_silent_alarm_title\"\u003eAlarm volume is silent\u003c/string\u003e\n\u003c/resources\u003e","comments":[],"name":"res/values/cm_strings.xml"},"src/com/android/deskclock/AlarmClockFragment.java":{"a":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.deskclock;\n\nimport android.animation.Animator;\nimport android.animation.Animator.AnimatorListener;\nimport android.animation.AnimatorInflater;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.FragmentTransaction;\nimport android.app.LoaderManager;\nimport android.app.Profile;\nimport android.app.ProfileManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.media.Ringtone;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.text.format.DateFormat;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.Interpolator;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CursorAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport com.android.datetimepicker.time.RadialPickerLayout;\nimport com.android.datetimepicker.time.TimePickerDialog;\nimport com.android.deskclock.alarms.AlarmStateManager;\nimport com.android.deskclock.provider.Alarm;\nimport com.android.deskclock.provider.AlarmInstance;\nimport com.android.deskclock.provider.DaysOfWeek;\nimport com.android.deskclock.widget.ActionableToastBar;\nimport com.android.deskclock.widget.TextTime;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * AlarmClock application.\n */\npublic class AlarmClockFragment extends DeskClockFragment implements\n        LoaderManager.LoaderCallbacks\u003cCursor\u003e,\n        TimePickerDialog.OnTimeSetListener,\n        View.OnTouchListener\n        {\n    private static final float EXPAND_DECELERATION = 1f;\n    private static final float COLLAPSE_DECELERATION = 0.7f;\n    private static final int ANIMATION_DURATION = 300;\n    private static final String KEY_EXPANDED_IDS = \"expandedIds\";\n    private static final String KEY_REPEAT_CHECKED_IDS = \"repeatCheckedIds\";\n    private static final String KEY_RINGTONE_TITLE_CACHE = \"ringtoneTitleCache\";\n    private static final String KEY_SELECTED_ALARMS = \"selectedAlarms\";\n    private static final String KEY_DELETED_ALARM = \"deletedAlarm\";\n    private static final String KEY_UNDO_SHOWING = \"undoShowing\";\n    private static final String KEY_PREVIOUS_DAY_MAP = \"previousDayMap\";\n    private static final String KEY_SELECTED_ALARM = \"selectedAlarm\";\n    private static final String KEY_DELETE_CONFIRMATION = \"deleteConfirmation\";\n\n    private static final int REQUEST_CODE_RINGTONE = 1;\n    private static final int REQUEST_CODE_PROFILE = 2;\n\n    // This extra is used when receiving an intent to create an alarm, but no alarm details\n    // have been passed in, so the alarm page should start the process of creating a new alarm.\n    public static final String ALARM_CREATE_NEW_INTENT_EXTRA = \"deskclock.create.new\";\n\n    // This extra is used when receiving an intent to scroll to specific alarm. If alarm\n    // can not be found, and toast message will pop up that the alarm has be deleted.\n    public static final String SCROLL_TO_ALARM_INTENT_EXTRA = \"deskclock.scroll.to.alarm\";\n\n    private ProfileManager mProfileManager;\n    private ProfilesObserver mProfileObserver;\n\n    private final Uri PROFILES_SETTINGS_URI =\n        Settings.System.getUriFor(Settings.System.SYSTEM_PROFILES_ENABLED);\n\n    private static final int MSG_PROFILE_STATUS_CHANGE = 1000;\n\n    private ListView mAlarmsList;\n    private AlarmItemAdapter mAdapter;\n    private View mEmptyView;\n    private ImageView mAddAlarmButton;\n    private View mAlarmsView;\n    private View mTimelineLayout;\n    private AlarmTimelineView mTimelineView;\n    private View mFooterView;\n\n    private Bundle mRingtoneTitleCache; // Key: ringtone uri, value: ringtone title\n    private ActionableToastBar mUndoBar;\n    private View mUndoFrame;\n\n    private Alarm mSelectedAlarm;\n    private long mScrollToAlarmId = -1;\n\n    private Loader mCursorLoader = null;\n\n    // Saved states for undo\n    private Alarm mDeletedAlarm;\n    private Alarm mAddedAlarm;\n    private boolean mUndoShowing = false;\n\n    private Animator mFadeIn;\n    private Animator mFadeOut;\n\n    private Interpolator mExpandInterpolator;\n    private Interpolator mCollapseInterpolator;\n\n    private int mTimelineViewWidth;\n    private int mUndoBarInitialMargin;\n\n    // Cached layout positions of items in listview prior to add/removal of alarm item\n    private ConcurrentHashMap\u003cLong, Integer\u003e mItemIdTopMap = new ConcurrentHashMap\u003cLong, Integer\u003e();\n\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case MSG_PROFILE_STATUS_CHANGE:\n                    updateProfilesStatus();\n                    break;\n            }\n        }\n    };\n\n    public AlarmClockFragment() {\n        // Basic provider required by Fragment.java\n    }\n\n    @Override\n    public void onCreate(Bundle savedState) {\n        super.onCreate(savedState);\n        mCursorLoader = getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedState) {\n        // Inflate the layout for this fragment\n        final View v = inflater.inflate(R.layout.alarm_clock, container, false);\n\n        long[] expandedIds = null;\n        long[] repeatCheckedIds = null;\n        long[] selectedAlarms = null;\n        Bundle previousDayMap = null;\n        if (savedState != null) {\n            expandedIds = savedState.getLongArray(KEY_EXPANDED_IDS);\n            repeatCheckedIds = savedState.getLongArray(KEY_REPEAT_CHECKED_IDS);\n            mRingtoneTitleCache = savedState.getBundle(KEY_RINGTONE_TITLE_CACHE);\n            mDeletedAlarm = savedState.getParcelable(KEY_DELETED_ALARM);\n            mUndoShowing = savedState.getBoolean(KEY_UNDO_SHOWING);\n            selectedAlarms = savedState.getLongArray(KEY_SELECTED_ALARMS);\n            previousDayMap = savedState.getBundle(KEY_PREVIOUS_DAY_MAP);\n            mSelectedAlarm = savedState.getParcelable(KEY_SELECTED_ALARM);\n        }\n\n        // Register profiles status\n        mProfileManager = (ProfileManager) getActivity().getSystemService(Context.PROFILE_SERVICE);\n        mProfileObserver = new ProfilesObserver(mHandler);\n\n        mExpandInterpolator = new DecelerateInterpolator(EXPAND_DECELERATION);\n        mCollapseInterpolator = new DecelerateInterpolator(COLLAPSE_DECELERATION);\n\n        mAddAlarmButton = (ImageButton) v.findViewById(R.id.alarm_add_alarm);\n        mAddAlarmButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                hideUndoBar(true, null);\n                startCreatingAlarm();\n            }\n        });\n        // For landscape, put the add button on the right and the menu in the actionbar.\n        FrameLayout.LayoutParams layoutParams =\n                (FrameLayout.LayoutParams) mAddAlarmButton.getLayoutParams();\n        boolean isLandscape = getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n        if (isLandscape) {\n            layoutParams.gravity = Gravity.END;\n        } else {\n            layoutParams.gravity = Gravity.CENTER;\n        }\n        mAddAlarmButton.setLayoutParams(layoutParams);\n\n        View menuButton = v.findViewById(R.id.menu_button);\n        if (menuButton != null) {\n            if (isLandscape) {\n                menuButton.setVisibility(View.GONE);\n            } else {\n                menuButton.setVisibility(View.VISIBLE);\n                setupFakeOverflowMenuButton(menuButton);\n            }\n        }\n\n        mEmptyView = v.findViewById(R.id.alarms_empty_view);\n        mEmptyView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startCreatingAlarm();\n            }\n        });\n        mAlarmsList = (ListView) v.findViewById(R.id.alarms_list);\n\n        mFadeIn = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_in);\n        mFadeIn.setDuration(ANIMATION_DURATION);\n        mFadeIn.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator animation) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animation) {\n                // Do nothing.\n            }\n        });\n        mFadeIn.setTarget(mEmptyView);\n        mFadeOut = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_out);\n        mFadeOut.setDuration(ANIMATION_DURATION);\n        mFadeOut.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator arg0) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator arg0) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator arg0) {\n                mEmptyView.setVisibility(View.GONE);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator arg0) {\n                // Do nothing.\n            }\n        });\n        mFadeOut.setTarget(mEmptyView);\n        mAlarmsView = v.findViewById(R.id.alarm_layout);\n        mTimelineLayout = v.findViewById(R.id.timeline_layout);\n\n        mUndoBar = (ActionableToastBar) v.findViewById(R.id.undo_bar);\n        mUndoBarInitialMargin = getActivity().getResources()\n                .getDimensionPixelOffset(R.dimen.alarm_undo_bar_horizontal_margin);\n        mUndoFrame = v.findViewById(R.id.undo_frame);\n        mUndoFrame.setOnTouchListener(this);\n\n        mFooterView = v.findViewById(R.id.alarms_footer_view);\n        mFooterView.setOnTouchListener(this);\n\n        // Timeline layout only exists in tablet landscape mode for now.\n        if (mTimelineLayout != null) {\n            mTimelineView = (AlarmTimelineView) v.findViewById(R.id.alarm_timeline_view);\n            mTimelineViewWidth = getActivity().getResources()\n                    .getDimensionPixelOffset(R.dimen.alarm_timeline_layout_width);\n        }\n\n        mAdapter = new AlarmItemAdapter(getActivity(),\n                expandedIds, repeatCheckedIds, selectedAlarms, previousDayMap, mAlarmsList);\n        mAdapter.registerDataSetObserver(new DataSetObserver() {\n\n            private int prevAdapterCount = -1;\n\n            @Override\n            public void onChanged() {\n\n                final int count = mAdapter.getCount();\n                if (mDeletedAlarm != null \u0026\u0026 prevAdapterCount \u003e count) {\n                    showUndoBar();\n                }\n\n                // If there are no alarms in the adapter...\n                if (count == 0) {\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_red);\n\n                    // ...and if there exists a timeline view (currently only in tablet landscape)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        // ...and if the previous adapter had alarms (indicating a removal)...\n                        if (prevAdapterCount \u003e 0) {\n\n                            // Then animate in the \"no alarms\" icon...\n                            mFadeIn.start();\n\n                            // and animate out the alarm timeline view, expanding the width of the\n                            // alarms list / undo bar.\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mCollapseInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.addListener(new AnimatorListener() {\n\n                                @Override\n                                public void onAnimationCancel(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(false);\n                                }\n\n                                @Override\n                                public void onAnimationRepeat(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationStart(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(true);\n                                }\n\n                            });\n                            animator.start();\n                        } else {\n                            // If the previous adapter did not have alarms, no animation needed,\n                            // just hide the timeline view and show the \"no alarms\" icon.\n                            mTimelineLayout.setVisibility(View.GONE);\n                            mEmptyView.setVisibility(View.VISIBLE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just show the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.VISIBLE);\n                    }\n                } else {\n\n                    // Otherwise, if the adapter DOES contain alarms...\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_normal);\n\n                    // ...and if there exists a timeline view (currently in tablet landscape mode)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        mTimelineLayout.setVisibility(View.VISIBLE);\n                        // ...and if the previous adapter did not have alarms (indicating an add)\n                        if (prevAdapterCount == 0) {\n\n                            // Then, animate to hide the \"no alarms\" icon...\n                            mFadeOut.start();\n\n                            // and animate to show the timeline view, reducing the width of the\n                            // alarms list / undo bar.\n                            ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mExpandInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    ((FrameLayout.LayoutParams) mAlarmsView.getLayoutParams())\n                                        .setMargins(0, 0, (int) -rightOffset, 0);\n                                    mAlarmsView.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.start();\n                        } else {\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            mEmptyView.setVisibility(View.GONE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin + mTimelineViewWidth);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just hide the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.GONE);\n                    }\n                }\n\n                // Cache this adapter's count for when the adapter changes.\n                prevAdapterCount = count;\n                super.onChanged();\n            }\n        });\n\n        if (mRingtoneTitleCache == null) {\n            mRingtoneTitleCache = new Bundle();\n        }\n\n        mAlarmsList.setAdapter(mAdapter);\n        mAlarmsList.setVerticalScrollBarEnabled(true);\n        mAlarmsList.setOnCreateContextMenuListener(this);\n\n        if (mUndoShowing) {\n            showUndoBar();\n        }\n        return v;\n    }\n\n    private void setUndoBarRightMargin(int margin) {\n        FrameLayout.LayoutParams params =\n                (FrameLayout.LayoutParams) mUndoBar.getLayoutParams();\n        ((FrameLayout.LayoutParams) mUndoBar.getLayoutParams())\n            .setMargins(params.leftMargin, params.topMargin, margin, params.bottomMargin);\n        mUndoBar.requestLayout();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Check if another app asked us to create a blank new alarm.\n        final Intent intent = getActivity().getIntent();\n        if (intent.hasExtra(ALARM_CREATE_NEW_INTENT_EXTRA)) {\n            if (intent.getBooleanExtra(ALARM_CREATE_NEW_INTENT_EXTRA, false)) {\n                // An external app asked us to create a blank alarm.\n                startCreatingAlarm();\n            }\n\n            // Remove the CREATE_NEW extra now that we've processed it.\n            intent.removeExtra(ALARM_CREATE_NEW_INTENT_EXTRA);\n        } else if (intent.hasExtra(SCROLL_TO_ALARM_INTENT_EXTRA)) {\n            long alarmId = intent.getLongExtra(SCROLL_TO_ALARM_INTENT_EXTRA, Alarm.INVALID_ID);\n            if (alarmId != Alarm.INVALID_ID) {\n                mScrollToAlarmId = alarmId;\n                if (mCursorLoader != null \u0026\u0026 mCursorLoader.isStarted()) {\n                    // We need to force a reload here to make sure we have the latest view\n                    // of the data to scroll to.\n                    mCursorLoader.forceLoad();\n                }\n            }\n\n            // Remove the SCROLL_TO_ALARM extra now that we've processed it.\n            intent.removeExtra(SCROLL_TO_ALARM_INTENT_EXTRA);\n        }\n\n        // Make sure to use the child FragmentManager. We have to use that one for the\n        // case where an intent comes in telling the activity to load the timepicker,\n        // which means we have to use that one everywhere so that the fragment can get\n        // correctly picked up here if it's open.\n        TimePickerDialog tpd = (TimePickerDialog) getChildFragmentManager().\n                findFragmentByTag(AlarmUtils.FRAG_TAG_TIME_PICKER);\n        if (tpd != null) {\n            // The dialog is already open so we need to set the listener again.\n            tpd.setOnTimeSetListener(this);\n        }\n\n        // Update the profile status and register the profile observer\n        getActivity().getContentResolver().registerContentObserver(\n                PROFILES_SETTINGS_URI, false, mProfileObserver);\n        updateProfilesStatus();\n    }\n\n    private void hideUndoBar(boolean animate, MotionEvent event) {\n        if (mUndoBar != null) {\n            mUndoFrame.setVisibility(View.GONE);\n            if (event != null \u0026\u0026 mUndoBar.isEventInToastBar(event)) {\n                // Avoid touches inside the undo bar.\n                return;\n            }\n            mUndoBar.hide(animate);\n        }\n        mDeletedAlarm = null;\n        mUndoShowing = false;\n    }\n\n    private void showUndoBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                asyncAddAlarm(mDeletedAlarm);\n                mDeletedAlarm = null;\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.alarm_deleted), true, R.string.alarm_undo, true);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLongArray(KEY_EXPANDED_IDS, mAdapter.getExpandedArray());\n        outState.putLongArray(KEY_REPEAT_CHECKED_IDS, mAdapter.getRepeatArray());\n        outState.putLongArray(KEY_SELECTED_ALARMS, mAdapter.getSelectedAlarmsArray());\n        outState.putBundle(KEY_RINGTONE_TITLE_CACHE, mRingtoneTitleCache);\n        outState.putParcelable(KEY_DELETED_ALARM, mDeletedAlarm);\n        outState.putBoolean(KEY_UNDO_SHOWING, mUndoShowing);\n        outState.putBundle(KEY_PREVIOUS_DAY_MAP, mAdapter.getPreviousDaysOfWeekMap());\n        outState.putParcelable(KEY_SELECTED_ALARM, mSelectedAlarm);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        ToastMaster.cancelToast();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        // When the user places the app in the background by pressing \"home\",\n        // dismiss the toast bar. However, since there is no way to determine if\n        // home was pressed, just dismiss any existing toast bar when restarting\n        // the app.\n        hideUndoBar(false, null);\n\n        // Unregister the profile observer\n        getActivity().getContentResolver().unregisterContentObserver(mProfileObserver);\n    }\n\n    // Callback used by TimePickerDialog\n    @Override\n    public void onTimeSet(RadialPickerLayout view, int hourOfDay, int minute) {\n        if (mSelectedAlarm == null) {\n            // If mSelectedAlarm is null then we're creating a new alarm.\n            Alarm a = new Alarm();\n            a.alert = RingtoneManager.getActualDefaultRingtoneUri(getActivity(),\n                    RingtoneManager.TYPE_ALARM);\n            if (a.alert == null) {\n                a.alert = Uri.parse(\"content://settings/system/alarm_alert\");\n            }\n            a.hour = hourOfDay;\n            a.minutes = minute;\n            a.enabled = true;\n            asyncAddAlarm(a);\n        } else {\n            mSelectedAlarm.hour = hourOfDay;\n            mSelectedAlarm.minutes = minute;\n            mSelectedAlarm.enabled = true;\n            mScrollToAlarmId = mSelectedAlarm.id;\n            asyncUpdateAlarm(mSelectedAlarm, true);\n            mSelectedAlarm = null;\n        }\n    }\n\n    private void showLabelDialog(final Alarm alarm) {\n        final FragmentTransaction ft = getFragmentManager().beginTransaction();\n        final Fragment prev = getFragmentManager().findFragmentByTag(\"label_dialog\");\n        if (prev != null) {\n            ft.remove(prev);\n        }\n        ft.addToBackStack(null);\n\n        // Create and show the dialog.\n        final LabelDialogFragment newFragment =\n                LabelDialogFragment.newInstance(alarm, alarm.label, getTag());\n        newFragment.show(ft, \"label_dialog\");\n    }\n\n    public void setLabel(Alarm alarm, String label) {\n        alarm.label = label;\n        asyncUpdateAlarm(alarm, false);\n    }\n\n    @Override\n    public Loader\u003cCursor\u003e onCreateLoader(int id, Bundle args) {\n        return Alarm.getAlarmsCursorLoader(getActivity());\n    }\n\n    @Override\n    public void onLoadFinished(Loader\u003cCursor\u003e cursorLoader, final Cursor data) {\n        mAdapter.swapCursor(data);\n        if (mScrollToAlarmId != -1) {\n            scrollToAlarm(mScrollToAlarmId);\n            mScrollToAlarmId = -1;\n        }\n    }\n\n    /**\n     * Scroll to alarm with given alarm id.\n     *\n     * @param alarmId The alarm id to scroll to.\n     */\n    private void scrollToAlarm(long alarmId) {\n        int alarmPosition = -1;\n        for (int i = 0; i \u003c mAdapter.getCount(); i++) {\n            long id = mAdapter.getItemId(i);\n            if (id == alarmId) {\n                alarmPosition = i;\n                break;\n            }\n        }\n\n        if (alarmPosition \u003e= 0) {\n            mAdapter.setNewAlarm(alarmId);\n            mAlarmsList.smoothScrollToPositionFromTop(alarmPosition, 0);\n        } else {\n            // Trying to display a deleted alarm should only happen from a missed notification for\n            // an alarm that has been marked deleted after use.\n            Context context = getActivity().getApplicationContext();\n            Toast toast = Toast.makeText(context, R.string.missed_alarm_has_been_deleted,\n                    Toast.LENGTH_LONG);\n            ToastMaster.setToast(toast);\n            toast.show();\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader\u003cCursor\u003e cursorLoader) {\n        mAdapter.swapCursor(null);\n    }\n\n    private void launchRingTonePicker(final Alarm alarm) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.alarm_picker_title).setItems(\n                R.array.ringtone_picker_entries,\n\n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        switch (which) {\n                            case 0:\n                                launchSingleRingTonePicker(alarm);\n                                break;\n                            case 1:\n                                alarm.alert = MultiPlayer.RANDOM_URI;\n                                asyncUpdateAlarm(alarm, false);\n                                break;\n                        }\n                    }\n                });\n        AlertDialog d = builder.create();\n        d.show();\n    }\n\n    private void launchSingleRingTonePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;\n        final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, oldRingtone);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, false);\n        startActivityForResult(intent, REQUEST_CODE_RINGTONE);\n    }\n\n    private void launchProfilePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        final Intent intent = new Intent(ProfileManager.ACTION_PROFILE_PICKER);\n\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_EXISTING_UUID, alarm.profile.toString());\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_SHOW_NONE, true);\n        startActivityForResult(intent, REQUEST_CODE_PROFILE);\n    }\n\n    private void saveRingtoneUri(Intent intent) {\n        Uri uri = intent.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);\n        if (uri == null) {\n            uri = Alarm.NO_RINGTONE_URI;\n        }\n        mSelectedAlarm.alert = uri;\n\n        // Save the last selected ringtone as the default for new alarms\n        if (!Alarm.NO_RINGTONE_URI.equals(uri)) {\n            RingtoneManager.setActualDefaultRingtoneUri(\n                    getActivity(), RingtoneManager.TYPE_ALARM, uri);\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private void saveProfile(Intent intent) {\n        final String uuid = intent.getStringExtra(ProfileManager.EXTRA_PROFILE_PICKED_UUID);\n        if (uuid != null) {\n            try {\n                mSelectedAlarm.profile = UUID.fromString(uuid);\n            } catch (IllegalArgumentException ex) {\n                mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n            }\n        } else {\n            mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private boolean isProfilesEnabled() {\n        return Settings.System.getInt(getActivity().getContentResolver(),\n                Settings.System.SYSTEM_PROFILES_ENABLED, 1) == 1;\n    }\n\n    private String getProfileName(Alarm alarm) {\n        if (!isProfilesEnabled() || alarm.profile.equals(ProfileManager.NO_PROFILE)) {\n            return getString(R.string.profile_no_selected);\n        }\n        Profile profile = mProfileManager.getProfile(alarm.profile);\n        if (profile == null) {\n            return getString(R.string.profile_no_selected);\n        }\n        return profile.getName();\n    }\n\n    private void updateProfilesStatus() {\n        // Need to refresh the data\n        if (mAdapter != null) {\n            mAdapter.notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == Activity.RESULT_OK) {\n            switch (requestCode) {\n                case REQUEST_CODE_RINGTONE:\n                    saveRingtoneUri(data);\n                    break;\n                case REQUEST_CODE_PROFILE:\n                    saveProfile(data);\n                default:\n                    Log.w(\"Unhandled request code in onActivityResult: \" + requestCode);\n            }\n        }\n    }\n\n    private class ProfilesObserver extends ContentObserver {\n        public ProfilesObserver(Handler handler) {\n            super(handler);\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n            onChange(selfChange, null);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            if (uri == null) return;\n            if (PROFILES_SETTINGS_URI.equals(uri)) {\n                mHandler.removeMessages(MSG_PROFILE_STATUS_CHANGE);\n                mHandler.sendEmptyMessage(MSG_PROFILE_STATUS_CHANGE);\n            }\n        }\n    }\n\n    public class AlarmItemAdapter extends CursorAdapter {\n        private static final int EXPAND_DURATION = 300;\n        private static final int COLLAPSE_DURATION = 250;\n\n        private final Context mContext;\n        private final LayoutInflater mFactory;\n        private final String[] mShortWeekDayStrings;\n        private final String[] mLongWeekDayStrings;\n        private final int mColorLit;\n        private final int mColorDim;\n        private final int mBackgroundColorExpanded;\n        private final int mBackgroundColor;\n        private final Typeface mRobotoNormal;\n        private final Typeface mRobotoBold;\n        private final ListView mList;\n\n        private final HashSet\u003cLong\u003e mExpanded = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mRepeatChecked = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mSelectedAlarms = new HashSet\u003cLong\u003e();\n        private Bundle mPreviousDaysOfWeekMap = new Bundle();\n\n        private final boolean mHasVibrator;\n        private final int mCollapseExpandHeight;\n\n        // This determines the order in which it is shown and processed in the UI.\n        // The array is filled when the adapter is created\n        private final int[] DAY_ORDER = new int[7];\n\n        public class ItemHolder {\n\n            // views for optimization\n            LinearLayout alarmItem;\n            TextTime clock;\n            Switch onoff;\n            TextView daysOfWeek;\n            TextView label;\n            ImageView delete;\n            View expandArea;\n            View summary;\n            TextView clickableLabel;\n            CheckBox repeat;\n            LinearLayout repeatDays;\n            ViewGroup[] dayButtonParents = new ViewGroup[7];\n            ToggleButton[] dayButtons = new ToggleButton[7];\n            CheckBox vibrate;\n            CheckBox increasingVolume;\n            TextView ringtone;\n            TextView profile;\n            View hairLine;\n            View arrow;\n            View collapseExpandArea;\n            View footerFiller;\n\n            // Other states\n            Alarm alarm;\n        }\n\n        // Used for scrolling an expanded item in the list to make sure it is fully visible.\n        private long mScrollAlarmId = -1;\n        private final Runnable mScrollRunnable = new Runnable() {\n            @Override\n            public void run() {\n                if (mScrollAlarmId != -1) {\n                    View v = getViewById(mScrollAlarmId);\n                    if (v != null) {\n                        Rect rect = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n                        mList.requestChildRectangleOnScreen(v, rect, false);\n                    }\n                    mScrollAlarmId = -1;\n                }\n            }\n        };\n\n        public AlarmItemAdapter(Context context, long[] expandedIds, long[] repeatCheckedIds,\n                long[] selectedAlarms, Bundle previousDaysOfWeekMap, ListView list) {\n            super(context, null, 0);\n            mContext = context;\n            mFactory = LayoutInflater.from(context);\n            mList = list;\n\n            DateFormatSymbols dfs = new DateFormatSymbols();\n            mShortWeekDayStrings = dfs.getShortWeekdays();\n            mLongWeekDayStrings = dfs.getWeekdays();\n            int firstDayOfWeek = Calendar.getInstance(Locale.getDefault()).getFirstDayOfWeek();\n            int j = 0;\n            for (int i = firstDayOfWeek; i \u003c= DAY_ORDER.length; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n            for (int i = Calendar.SUNDAY; i \u003c firstDayOfWeek; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n\n            Resources res = mContext.getResources();\n            mColorLit = res.getColor(R.color.clock_white);\n            mColorDim = res.getColor(R.color.clock_gray);\n            mBackgroundColorExpanded = res.getColor(R.color.alarm_whiteish);\n            mBackgroundColor = R.drawable.alarm_background_normal;\n\n            mRobotoBold = Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\n            mRobotoNormal = Typeface.create(\"sans-serif-condensed\", Typeface.NORMAL);\n\n            if (expandedIds != null) {\n                buildHashSetFromArray(expandedIds, mExpanded);\n            }\n            if (repeatCheckedIds != null) {\n                buildHashSetFromArray(repeatCheckedIds, mRepeatChecked);\n            }\n            if (previousDaysOfWeekMap != null) {\n                mPreviousDaysOfWeekMap = previousDaysOfWeekMap;\n            }\n            if (selectedAlarms != null) {\n                buildHashSetFromArray(selectedAlarms, mSelectedAlarms);\n            }\n\n            mHasVibrator = ((Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE))\n                    .hasVibrator();\n\n            mCollapseExpandHeight = (int) res.getDimension(R.dimen.collapse_expand_height);\n        }\n\n        public void removeSelectedId(int id) {\n            mSelectedAlarms.remove(id);\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (!getCursor().moveToPosition(position)) {\n                // May happen if the last alarm was deleted and the cursor refreshed while the\n                // list is updated.\n                Log.v(\"couldn't move cursor to position \" + position);\n                return null;\n            }\n            View v;\n            if (convertView == null) {\n                v = newView(mContext, getCursor(), parent);\n            } else {\n                // TODO temporary hack to prevent the convertView from not having stuff we need.\n                boolean badConvertView = convertView.findViewById(R.id.digital_clock) == null;\n                // Do a translation check to test for animation. Change this to something more\n                // reliable and robust in the future.\n                if (convertView.getTranslationX() != 0 || convertView.getTranslationY() != 0 ||\n                        badConvertView) {\n                    // view was animated, reset\n                    v = newView(mContext, getCursor(), parent);\n                } else {\n                    v = convertView;\n                }\n            }\n            bindView(v, mContext, getCursor());\n            ItemHolder holder = (ItemHolder) v.getTag();\n\n            // We need the footer for the last element of the array to allow the user to scroll\n            // the item beyond the bottom button bar, which obscures the view.\n            holder.footerFiller.setVisibility(position \u003c getCount() - 1 ? View.GONE : View.VISIBLE);\n            return v;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            final View view = mFactory.inflate(R.layout.alarm_time, parent, false);\n            setNewHolder(view);\n            return view;\n        }\n\n        /**\n         * In addition to changing the data set for the alarm list, swapCursor is now also\n         * responsible for preparing the list view's pre-draw operation for any animations that\n         * need to occur if an alarm was removed or added.\n         */\n        @Override\n        public synchronized Cursor swapCursor(Cursor cursor) {\n            Cursor c = super.swapCursor(cursor);\n\n            if (mItemIdTopMap.isEmpty() \u0026\u0026 mAddedAlarm == null) {\n                return c;\n            }\n\n            final ListView list = mAlarmsList;\n            final ViewTreeObserver observer = list.getViewTreeObserver();\n\n            /*\n             * Add a pre-draw listener to the observer to prepare for any possible animations to\n             * the alarms within the list view.  The animations will occur if an alarm has been\n             * removed or added.\n             *\n             * For alarm removal, the remaining children should all retain their initial starting\n             * positions, and transition to their new positions.\n             *\n             * For alarm addition, the other children should all retain their initial starting\n             * positions, transition to their new positions, and at the end of that transition, the\n             * newly added alarm should appear in the designated space.\n             */\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n\n                private View mAddedView;\n\n                @Override\n                public boolean onPreDraw() {\n                    // Remove the pre-draw listener, as this only needs to occur once.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    boolean firstAnimation = true;\n                    int firstVisiblePosition = list.getFirstVisiblePosition();\n\n                    // Iterate through the children to prepare the add/remove animation.\n                    for (int i = 0; i\u003c list.getChildCount(); i++) {\n                        final View child = list.getChildAt(i);\n\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n\n                        // If this is the added alarm, set it invisible for now, and animate later.\n                        if (mAddedAlarm != null \u0026\u0026 itemId == mAddedAlarm.id) {\n                            mAddedView = child;\n                            mAddedView.setAlpha(0.0f);\n                            continue;\n                        }\n\n                        // The cached starting position of the child view.\n                        Integer startTop = mItemIdTopMap.get(itemId);\n                        // The new starting position of the child view.\n                        int top = child.getTop();\n\n                        // If there is no cached starting position, determine whether the item has\n                        // come from the top of bottom of the list view.\n                        if (startTop == null) {\n                            int childHeight = child.getHeight() + list.getDividerHeight();\n                            startTop = top + (i \u003e 0 ? childHeight : -childHeight);\n                        }\n\n                        Log.d(\"Start Top: \" + startTop + \", Top: \" + top);\n                        // If the starting position of the child view is different from the\n                        // current position, animate the child.\n                        if (startTop != top) {\n                            int delta = startTop - top;\n                            child.setTranslationY(delta);\n                            child.animate().setDuration(ANIMATION_DURATION).translationY(0);\n                            final View addedView = mAddedView;\n                            if (firstAnimation) {\n\n                                // If this is the first child being animated, then after the\n                                // animation is complete, and animate in the added alarm (if one\n                                // exists).\n                                child.animate().withEndAction(new Runnable() {\n\n                                    @Override\n                                    public void run() {\n\n\n                                        // If there was an added view, animate it in after\n                                        // the other views have animated.\n                                        if (addedView != null) {\n                                            addedView.animate().alpha(1.0f)\n                                                .setDuration(ANIMATION_DURATION)\n                                                .withEndAction(new Runnable() {\n\n                                                    @Override\n                                                    public void run() {\n                                                        // Re-enable the list after the add\n                                                        // animation is complete.\n                                                        list.setEnabled(true);\n                                                    }\n\n                                                });\n                                        } else {\n                                            // Re-enable the list after animations are complete.\n                                            list.setEnabled(true);\n                                        }\n                                    }\n\n                                });\n                                firstAnimation = false;\n                            }\n                        }\n                    }\n\n                    // If there were no child views (outside of a possible added view)\n                    // that require animation...\n                    if (firstAnimation) {\n                        if (mAddedView != null) {\n                            // If there is an added view, prepare animation for the added view.\n                            Log.d(\"Animating added view...\");\n                            mAddedView.animate().alpha(1.0f)\n                                .setDuration(ANIMATION_DURATION)\n                                .withEndAction(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        // Re-enable the list after animations are complete.\n                                        list.setEnabled(true);\n                                    }\n                                });\n                        } else {\n                            // Re-enable the list after animations are complete.\n                            list.setEnabled(true);\n                        }\n                    }\n\n                    mAddedAlarm = null;\n                    mItemIdTopMap.clear();\n                    return true;\n                }\n            });\n            return c;\n        }\n\n        private void setNewHolder(View view) {\n            // standard view holder optimization\n            final ItemHolder holder = new ItemHolder();\n            holder.alarmItem = (LinearLayout) view.findViewById(R.id.alarm_item);\n            holder.clock = (TextTime) view.findViewById(R.id.digital_clock);\n            holder.onoff = (Switch) view.findViewById(R.id.onoff);\n            holder.onoff.setTypeface(mRobotoNormal);\n            holder.daysOfWeek = (TextView) view.findViewById(R.id.daysOfWeek);\n            holder.label = (TextView) view.findViewById(R.id.label);\n            holder.delete = (ImageView) view.findViewById(R.id.delete);\n            holder.summary = view.findViewById(R.id.summary);\n            holder.expandArea = view.findViewById(R.id.expand_area);\n            holder.hairLine = view.findViewById(R.id.hairline);\n            holder.arrow = view.findViewById(R.id.arrow);\n            holder.repeat = (CheckBox) view.findViewById(R.id.repeat_onoff);\n            holder.clickableLabel = (TextView) view.findViewById(R.id.edit_label);\n            holder.repeatDays = (LinearLayout) view.findViewById(R.id.repeat_days);\n            holder.collapseExpandArea = view.findViewById(R.id.collapse_expand);\n            holder.footerFiller = view.findViewById(R.id.alarm_footer_filler);\n            holder.footerFiller.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // Do nothing.\n                }\n            });\n\n            // Build button for each day.\n            for (int i = 0; i \u003c 7; i++) {\n                final ViewGroup viewgroup = (ViewGroup) mFactory.inflate(R.layout.day_button,\n                        holder.repeatDays, false);\n                final ToggleButton button = (ToggleButton) viewgroup.getChildAt(0);\n                final int dayToShowIndex = DAY_ORDER[i];\n                button.setText(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOn(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOff(mShortWeekDayStrings[dayToShowIndex]);\n                button.setContentDescription(mLongWeekDayStrings[dayToShowIndex]);\n                holder.repeatDays.addView(viewgroup);\n                holder.dayButtons[i] = button;\n                holder.dayButtonParents[i] = viewgroup;\n            }\n            holder.vibrate = (CheckBox) view.findViewById(R.id.vibrate_onoff);\n            holder.increasingVolume = (CheckBox) view.findViewById(R.id.increasing_volume_onoff);\n            holder.ringtone = (TextView) view.findViewById(R.id.choose_ringtone);\n            holder.profile = (TextView) view.findViewById(R.id.choose_profile);\n\n            view.setTag(holder);\n        }\n\n        @Override\n        public void bindView(final View view, Context context, final Cursor cursor) {\n            final Alarm alarm = new Alarm(cursor);\n            Object tag = view.getTag();\n            if (tag == null) {\n                // The view was converted but somehow lost its tag.\n                setNewHolder(view);\n            }\n            final ItemHolder itemHolder = (ItemHolder) tag;\n            itemHolder.alarm = alarm;\n\n            // We must unset the listener first because this maybe a recycled view so changing the\n            // state would affect the wrong alarm.\n            itemHolder.onoff.setOnCheckedChangeListener(null);\n            itemHolder.onoff.setChecked(alarm.enabled);\n\n            if (mSelectedAlarms.contains(itemHolder.alarm.id)) {\n                itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n                setItemAlpha(itemHolder, true);\n                itemHolder.onoff.setEnabled(false);\n            } else {\n                itemHolder.onoff.setEnabled(true);\n                itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n                setItemAlpha(itemHolder, itemHolder.onoff.isChecked());\n            }\n            itemHolder.clock.setFormat(\n                    (int)mContext.getResources().getDimension(R.dimen.alarm_label_size));\n            itemHolder.clock.setTime(alarm.hour, alarm.minutes);\n            itemHolder.clock.setClickable(true);\n            itemHolder.clock.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    mSelectedAlarm = itemHolder.alarm;\n                    AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                            alarm, AlarmClockFragment.this\n                            , DateFormat.is24HourFormat(getActivity()));\n                    expandAlarm(itemHolder, true);\n                    itemHolder.alarmItem.post(mScrollRunnable);\n                }\n            });\n\n            final CompoundButton.OnCheckedChangeListener onOffListener =\n                    new CompoundButton.OnCheckedChangeListener() {\n                        @Override\n                        public void onCheckedChanged(CompoundButton compoundButton,\n                                boolean checked) {\n                            if (checked != alarm.enabled) {\n                                setItemAlpha(itemHolder, checked);\n                                alarm.enabled = checked;\n                                asyncUpdateAlarm(alarm, alarm.enabled);\n                            }\n                        }\n                    };\n\n            itemHolder.onoff.setOnCheckedChangeListener(onOffListener);\n\n            boolean expanded = isAlarmExpanded(alarm);\n            itemHolder.expandArea.setVisibility(expanded? View.VISIBLE : View.GONE);\n            itemHolder.summary.setVisibility(expanded? View.GONE : View.VISIBLE);\n\n            String labelSpace = \"\";\n            // Set the repeat text or leave it blank if it does not repeat.\n            final String daysOfWeekStr =\n                    alarm.daysOfWeek.toString(AlarmClockFragment.this.getActivity(), false);\n            if (daysOfWeekStr != null \u0026\u0026 daysOfWeekStr.length() != 0) {\n                itemHolder.daysOfWeek.setText(daysOfWeekStr);\n                itemHolder.daysOfWeek.setContentDescription(alarm.daysOfWeek.toAccessibilityString(\n                        AlarmClockFragment.this.getActivity()));\n                itemHolder.daysOfWeek.setVisibility(View.VISIBLE);\n                labelSpace = \"  \";\n                itemHolder.daysOfWeek.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n\n            } else {\n                itemHolder.daysOfWeek.setVisibility(View.GONE);\n            }\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() != 0) {\n                itemHolder.label.setText(alarm.label + labelSpace);\n                itemHolder.label.setVisibility(View.VISIBLE);\n                itemHolder.label.setContentDescription(\n                        mContext.getResources().getString(R.string.label_description) + \" \"\n                        + alarm.label);\n                itemHolder.label.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n            } else {\n                itemHolder.label.setVisibility(View.GONE);\n            }\n\n            itemHolder.delete.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    mDeletedAlarm = alarm;\n\n                    view.animate().setDuration(ANIMATION_DURATION).alpha(0).translationY(-1)\n                    .withEndAction(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            asyncDeleteAlarm(mDeletedAlarm, view);\n                        }\n                    });\n                }\n            });\n\n            if (expanded) {\n                expandAlarm(itemHolder, false);\n            } else {\n                collapseAlarm(itemHolder, false);\n            }\n\n            itemHolder.alarmItem.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    if (isAlarmExpanded(alarm)) {\n                        collapseAlarm(itemHolder, true);\n                    } else {\n                        expandAlarm(itemHolder, true);\n                    }\n                }\n            });\n\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n        }\n\n        private void bindExpandArea(final ItemHolder itemHolder, final Alarm alarm) {\n            // Views in here are not bound until the item is expanded.\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() \u003e 0) {\n                itemHolder.clickableLabel.setText(alarm.label);\n                itemHolder.clickableLabel.setTextColor(mColorLit);\n            } else {\n                itemHolder.clickableLabel.setText(R.string.label);\n                itemHolder.clickableLabel.setTextColor(mColorDim);\n            }\n            itemHolder.clickableLabel.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    showLabelDialog(alarm);\n                }\n            });\n\n            if (mRepeatChecked.contains(alarm.id) || itemHolder.alarm.daysOfWeek.isRepeating()) {\n                itemHolder.repeat.setChecked(true);\n                itemHolder.repeatDays.setVisibility(View.VISIBLE);\n            } else {\n                itemHolder.repeat.setChecked(false);\n                itemHolder.repeatDays.setVisibility(View.GONE);\n            }\n            itemHolder.repeat.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    final boolean checked = ((CheckBox) view).isChecked();\n                    if (checked) {\n                        // Show days\n                        itemHolder.repeatDays.setVisibility(View.VISIBLE);\n                        mRepeatChecked.add(alarm.id);\n\n                        // Set all previously set days\n                        // or\n                        // Set all days if no previous.\n                        final int bitSet = mPreviousDaysOfWeekMap.getInt(\"\" + alarm.id);\n                        alarm.daysOfWeek.setBitSet(bitSet);\n                        if (!alarm.daysOfWeek.isRepeating()) {\n                            alarm.daysOfWeek.setDaysOfWeek(true, DAY_ORDER);\n                        }\n                        updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n                    } else {\n                        itemHolder.repeatDays.setVisibility(View.GONE);\n                        mRepeatChecked.remove(alarm.id);\n\n                        // Remember the set days in case the user wants it back.\n                        final int bitSet = alarm.daysOfWeek.getBitSet();\n                        mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id, bitSet);\n\n                        // Remove all repeat days\n                        alarm.daysOfWeek.clearAllDays();\n                    }\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n            for (int i = 0; i \u003c 7; i++) {\n                final int buttonIndex = i;\n\n                itemHolder.dayButtonParents[i].setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        itemHolder.dayButtons[buttonIndex].toggle();\n                        final boolean checked = itemHolder.dayButtons[buttonIndex].isChecked();\n                        int day = DAY_ORDER[buttonIndex];\n                        alarm.daysOfWeek.setDaysOfWeek(checked, day);\n                        if (checked) {\n                            turnOnDayOfWeek(itemHolder, buttonIndex);\n                        } else {\n                            turnOffDayOfWeek(itemHolder, buttonIndex);\n\n                            // See if this was the last day, if so, un-check the repeat box.\n                            if (!alarm.daysOfWeek.isRepeating()) {\n                                itemHolder.repeatDays.setVisibility(View.GONE);\n                                itemHolder.repeat.setTextColor(mColorDim);\n                                mRepeatChecked.remove(alarm.id);\n\n                                // Set history to no days, so it will be everyday when repeat is\n                                // turned back on\n                                mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id,\n                                        DaysOfWeek.NO_DAYS_SET);\n                            }\n                        }\n                        asyncUpdateAlarm(alarm, false);\n                    }\n                });\n            }\n\n\n            if (!mHasVibrator) {\n                itemHolder.vibrate.setVisibility(View.INVISIBLE);\n            } else {\n                itemHolder.vibrate.setVisibility(View.VISIBLE);\n                if (!alarm.vibrate) {\n                    itemHolder.vibrate.setChecked(false);\n                    itemHolder.vibrate.setTextColor(mColorDim);\n                } else {\n                    itemHolder.vibrate.setChecked(true);\n                    itemHolder.vibrate.setTextColor(mColorLit);\n                }\n            }\n\n            itemHolder.vibrate.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    if (checked) {\n                        itemHolder.vibrate.setTextColor(mColorLit);\n                    } else {\n                        itemHolder.vibrate.setTextColor(mColorDim);\n                    }\n                    alarm.vibrate = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String ringtone;\n            final String ringtitle;\n            if (Alarm.NO_RINGTONE_URI.equals(alarm.alert)) {\n                ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n            } else {\n                ringtitle = getRingToneTitle(alarm.alert);\n                if (ringtitle != null) {\n                    ringtone = ringtitle;\n                } else {\n                    ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n                }\n            }\n            itemHolder.ringtone.setText(ringtone);\n            itemHolder.ringtone.setContentDescription(\n                    mContext.getResources().getString(R.string.ringtone_description) + \" \"\n                            + ringtone);\n            itemHolder.ringtone.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchRingTonePicker(alarm);\n                }\n            });\n\n\n            itemHolder.increasingVolume.setVisibility(View.VISIBLE);\n            itemHolder.increasingVolume.setChecked(alarm.increasingVolume);\n            itemHolder.increasingVolume.setTextColor(\n                    alarm.increasingVolume ? mColorLit : mColorDim);\n            itemHolder.increasingVolume.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    //When action mode is on - simulate long click\n                    itemHolder.increasingVolume.setTextColor(checked ? mColorLit : mColorDim);\n                    alarm.increasingVolume = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String profile = getProfileName(alarm);\n            itemHolder.profile.setText(profile);\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n            itemHolder.profile.setContentDescription(\n                    mContext.getResources().getString(R.string.profile_description, profile));\n            itemHolder.profile.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchProfilePicker(alarm);\n                }\n            });\n        }\n\n        // Sets the alpha of the item except the on/off switch. This gives a visual effect\n        // for enabled/disabled alarm while leaving the on/off switch more visible\n        private void setItemAlpha(ItemHolder holder, boolean enabled) {\n            float alpha = enabled ? 1f : 0.5f;\n            holder.clock.setAlpha(alpha);\n            holder.summary.setAlpha(alpha);\n            holder.expandArea.setAlpha(alpha);\n            holder.delete.setAlpha(alpha);\n            holder.daysOfWeek.setAlpha(alpha);\n        }\n\n        private void updateDaysOfWeekButtons(ItemHolder holder, DaysOfWeek daysOfWeek) {\n            HashSet\u003cInteger\u003e setDays = daysOfWeek.getSetDays();\n            for (int i = 0; i \u003c 7; i++) {\n                if (setDays.contains(DAY_ORDER[i])) {\n                    turnOnDayOfWeek(holder, i);\n                } else {\n                    turnOffDayOfWeek(holder, i);\n                }\n            }\n        }\n\n        public void toggleSelectState(View v) {\n            // long press could be on the parent view or one of its childs, so find the parent view\n            v = getTopParent(v);\n            if (v != null) {\n                long id = ((ItemHolder)v.getTag()).alarm.id;\n                if (mSelectedAlarms.contains(id)) {\n                    mSelectedAlarms.remove(id);\n                } else {\n                    mSelectedAlarms.add(id);\n                }\n            }\n        }\n\n        private View getTopParent(View v) {\n            while (v != null \u0026\u0026 v.getId() != R.id.alarm_item) {\n                v = (View) v.getParent();\n            }\n            return v;\n        }\n\n        public int getSelectedItemsNum() {\n            return mSelectedAlarms.size();\n        }\n\n        private void turnOffDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(false);\n            holder.dayButtons[dayIndex].setTextColor(mColorDim);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoNormal);\n        }\n\n        private void turnOnDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(true);\n            holder.dayButtons[dayIndex].setTextColor(mColorLit);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoBold);\n        }\n\n\n        /**\n         * Does a read-through cache for ringtone titles.\n         *\n         * @param uri The uri of the ringtone.\n         * @return The ringtone title. {@literal null} if no matching ringtone found.\n         */\n        private String getRingToneTitle(Uri uri) {\n            // Try the cache first\n            String title = mRingtoneTitleCache.getString(uri.toString());\n            if (title == null) {\n                if (uri.equals(MultiPlayer.RANDOM_URI)) {\n                    title = mContext.getResources().getString(R.string.alarm_type_random);\n                } else {\n                    // This is slow because a media player is created during Ringtone object creation.\n                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);\n                    if (ringTone != null) {\n                        title = ringTone.getTitle(mContext);\n                    }\n                }\n                if (title != null) {\n                    mRingtoneTitleCache.putString(uri.toString(), title);\n                }\n            }\n            return title;\n        }\n\n        public void setNewAlarm(long alarmId) {\n            mExpanded.add(alarmId);\n        }\n\n        /**\n         * Expands the alarm for editing.\n         *\n         * @param itemHolder The item holder instance.\n         */\n        private void expandAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.add(itemHolder.alarm.id);\n            bindExpandArea(itemHolder, itemHolder.alarm);\n            // Scroll the view to make sure it is fully viewed\n            mScrollAlarmId = itemHolder.alarm.id;\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to visible so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n            itemHolder.expandArea.setVisibility(View.VISIBLE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(180);\n                // We need to translate the hairline up, so the height of the collapseArea\n                // needs to be measured to know how high to translate it.\n                final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n                observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                    @Override\n                    public boolean onPreDraw() {\n                        // We don't want to continue getting called for every listview drawing.\n                        if (observer.isAlive()) {\n                            observer.removeOnPreDrawListener(this);\n                        }\n                        int hairlineHeight = itemHolder.hairLine.getHeight();\n                        int collapseHeight =\n                                itemHolder.collapseExpandArea.getHeight() - hairlineHeight;\n                        itemHolder.hairLine.setTranslationY(-collapseHeight);\n                        return true;\n                    }\n                });\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to VISIBLE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * the height is set back to the starting point so it can be animated down.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    // We don't want to continue getting called for every listview drawing.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    final int collapseHeight = itemHolder.collapseExpandArea.getHeight();\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = collapseHeight - hairlineHeight;\n\n                    // Set the height back to the start state of the animation.\n                    itemHolder.alarmItem.getLayoutParams().height = startingHeight;\n                    // To allow the expandArea to glide in with the expansion animation, set a\n                    // negative top margin, which will animate down to a margin of 0 as the height\n                    // is increased.\n                    // Note that we need to maintain the bottom margin as a fixed value (instead of\n                    // just using a listview, to allow for a flatter hierarchy) to fit the bottom\n                    // bar underneath.\n                    FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                            itemHolder.expandArea.getLayoutParams();\n                    expandParams.setMargins(0, -distance, 0, collapseHeight);\n                    itemHolder.alarmItem.requestLayout();\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(EXPAND_DURATION);\n                    animator.setInterpolator(mExpandInterpolator);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) -((1 - value) * distance), 0, collapseHeight);\n                            itemHolder.arrow.setRotation(180 * value);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * value);\n                            itemHolder.summary.setAlpha(1 - value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n                            itemHolder.arrow.setRotation(180);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance);\n                            itemHolder.summary.setVisibility(View.GONE);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    // Return false so this draw does not occur to prevent the final frame from\n                    // being drawn for the single frame before the animations start.\n                    return false;\n                }\n            });\n        }\n\n        private boolean isAlarmExpanded(Alarm alarm) {\n            return mExpanded.contains(alarm.id);\n        }\n\n        private void collapseAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.remove(itemHolder.alarm.id);\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to gone so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n            itemHolder.expandArea.setVisibility(View.GONE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(0);\n                itemHolder.hairLine.setTranslationY(0);\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to GONE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * expandArea is set to VISIBLE again so it can be shown animating.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = mCollapseExpandHeight - hairlineHeight;\n\n                    // Re-set the visibilities for the start state of the animation.\n                    itemHolder.expandArea.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setAlpha(1);\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(COLLAPSE_DURATION);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) (value * distance), 0, mCollapseExpandHeight);\n                            itemHolder.arrow.setRotation(180 * (1 - value));\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * (1 - value));\n                            itemHolder.summary.setAlpha(value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    animator.setInterpolator(mCollapseInterpolator);\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(0, 0, 0, mCollapseExpandHeight);\n\n                            itemHolder.expandArea.setVisibility(View.GONE);\n                            itemHolder.arrow.setRotation(0);\n                            itemHolder.hairLine.setTranslationY(0);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    return false;\n                }\n            });\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            return 1;\n        }\n\n        private View getViewById(long id) {\n            for (int i = 0; i \u003c mList.getCount(); i++) {\n                View v = mList.getChildAt(i);\n                if (v != null) {\n                    ItemHolder h = (ItemHolder)(v.getTag());\n                    if (h != null \u0026\u0026 h.alarm.id == id) {\n                        return v;\n                    }\n                }\n            }\n            return null;\n        }\n\n        public long[] getExpandedArray() {\n            int index = 0;\n            long[] ids = new long[mExpanded.size()];\n            for (long id : mExpanded) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getSelectedAlarmsArray() {\n            int index = 0;\n            long[] ids = new long[mSelectedAlarms.size()];\n            for (long id : mSelectedAlarms) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getRepeatArray() {\n            int index = 0;\n            long[] ids = new long[mRepeatChecked.size()];\n            for (long id : mRepeatChecked) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public Bundle getPreviousDaysOfWeekMap() {\n            return mPreviousDaysOfWeekMap;\n        }\n\n        private void buildHashSetFromArray(long[] ids, HashSet\u003cLong\u003e set) {\n            for (long id : ids) {\n                set.add(id);\n            }\n        }\n    }\n\n    private void startCreatingAlarm() {\n        // Set the \"selected\" alarm as null, and we'll create the new one when the timepicker\n        // comes back.\n        mSelectedAlarm = null;\n        AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                null, AlarmClockFragment.this, DateFormat.is24HourFormat(getActivity()));\n    }\n\n    private static AlarmInstance setupAlarmInstance(Context context, Alarm alarm) {\n        ContentResolver cr = context.getContentResolver();\n        AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());\n        newInstance = AlarmInstance.addInstance(cr, newInstance);\n        // Register instance to state manager\n        AlarmStateManager.registerInstance(context, newInstance, true);\n        return newInstance;\n    }\n\n    private void asyncDeleteAlarm(final Alarm alarm, final View viewToRemove) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, Void\u003e deleteTask = new AsyncTask\u003cVoid, Void, Void\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                if (viewToRemove == null) {\n                    return;\n                }\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                final ListView list = mAlarmsList;\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    if (child != viewToRemove) {\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n                        mItemIdTopMap.put(itemId, child.getTop());\n                    }\n                }\n            }\n\n            @Override\n            protected Void doInBackground(Void... parameters) {\n                // Activity may be closed at this point , make sure data is still valid\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n                    AlarmStateManager.deleteAllInstances(context, alarm.id);\n                    Alarm.deleteAlarm(cr, alarm.id);\n                }\n                return null;\n            }\n        };\n        mUndoShowing = true;\n        deleteTask.execute();\n    }\n\n    private void asyncAddAlarm(final Alarm alarm) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                final ListView list = mAlarmsList;\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    int position = firstVisiblePosition + i;\n                    long itemId = mAdapter.getItemId(position);\n                    mItemIdTopMap.put(itemId, child.getTop());\n                }\n            }\n\n            @Override\n            protected AlarmInstance doInBackground(Void... parameters) {\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n\n                    // Add alarm to db\n                    Alarm newAlarm = Alarm.addAlarm(cr, alarm);\n                    mScrollToAlarmId = newAlarm.id;\n\n                    // Create and add instance to db\n                    if (newAlarm.enabled) {\n                        return setupAlarmInstance(context, newAlarm);\n                    }\n                }\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    private void asyncUpdateAlarm(final Alarm alarm, final boolean popToast) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            protected AlarmInstance doInBackground(Void ... parameters) {\n                ContentResolver cr = context.getContentResolver();\n\n                // Dismiss all old instances\n                AlarmStateManager.deleteAllInstances(context, alarm.id);\n\n                // Update alarm\n                Alarm.updateAlarm(cr, alarm);\n                if (alarm.enabled) {\n                    return setupAlarmInstance(context, alarm);\n                }\n\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (popToast \u0026\u0026 instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        hideUndoBar(true, event);\n        return false;\n    }\n}","b":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.deskclock;\n\nimport android.animation.Animator;\nimport android.animation.Animator.AnimatorListener;\nimport android.animation.AnimatorInflater;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.FragmentTransaction;\nimport android.app.LoaderManager;\nimport android.app.Profile;\nimport android.app.ProfileManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.media.AudioManager;\nimport android.media.Ringtone;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.text.format.DateFormat;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.Interpolator;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CursorAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport com.android.datetimepicker.time.RadialPickerLayout;\nimport com.android.datetimepicker.time.TimePickerDialog;\nimport com.android.deskclock.alarms.AlarmStateManager;\nimport com.android.deskclock.provider.Alarm;\nimport com.android.deskclock.provider.AlarmInstance;\nimport com.android.deskclock.provider.DaysOfWeek;\nimport com.android.deskclock.widget.ActionableToastBar;\nimport com.android.deskclock.widget.TextTime;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * AlarmClock application.\n */\npublic class AlarmClockFragment extends DeskClockFragment implements\n        LoaderManager.LoaderCallbacks\u003cCursor\u003e,\n        TimePickerDialog.OnTimeSetListener,\n        View.OnTouchListener\n        {\n    private static final float EXPAND_DECELERATION = 1f;\n    private static final float COLLAPSE_DECELERATION = 0.7f;\n    private static final int ANIMATION_DURATION = 300;\n    private static final String KEY_EXPANDED_IDS = \"expandedIds\";\n    private static final String KEY_REPEAT_CHECKED_IDS = \"repeatCheckedIds\";\n    private static final String KEY_RINGTONE_TITLE_CACHE = \"ringtoneTitleCache\";\n    private static final String KEY_SELECTED_ALARMS = \"selectedAlarms\";\n    private static final String KEY_DELETED_ALARM = \"deletedAlarm\";\n    private static final String KEY_UNDO_SHOWING = \"undoShowing\";\n    private static final String KEY_PREVIOUS_DAY_MAP = \"previousDayMap\";\n    private static final String KEY_SELECTED_ALARM = \"selectedAlarm\";\n    private static final String KEY_DELETE_CONFIRMATION = \"deleteConfirmation\";\n\n    private static final int REQUEST_CODE_RINGTONE = 1;\n    private static final int REQUEST_CODE_PROFILE = 2;\n\n    // This extra is used when receiving an intent to create an alarm, but no alarm details\n    // have been passed in, so the alarm page should start the process of creating a new alarm.\n    public static final String ALARM_CREATE_NEW_INTENT_EXTRA = \"deskclock.create.new\";\n\n    // This extra is used when receiving an intent to scroll to specific alarm. If alarm\n    // can not be found, and toast message will pop up that the alarm has be deleted.\n    public static final String SCROLL_TO_ALARM_INTENT_EXTRA = \"deskclock.scroll.to.alarm\";\n\n    private ProfileManager mProfileManager;\n    private ProfilesObserver mProfileObserver;\n    private AudioManager mAudioManager;\n\n    private final Uri PROFILES_SETTINGS_URI =\n        Settings.System.getUriFor(Settings.System.SYSTEM_PROFILES_ENABLED);\n\n    private static final int MSG_PROFILE_STATUS_CHANGE = 1000;\n\n    private ListView mAlarmsList;\n    private AlarmItemAdapter mAdapter;\n    private View mEmptyView;\n    private ImageView mAddAlarmButton;\n    private View mAlarmsView;\n    private View mTimelineLayout;\n    private AlarmTimelineView mTimelineView;\n    private View mFooterView;\n\n    private Bundle mRingtoneTitleCache; // Key: ringtone uri, value: ringtone title\n    private ActionableToastBar mUndoBar;\n    private View mUndoFrame;\n\n    private Alarm mSelectedAlarm;\n    private long mScrollToAlarmId = -1;\n\n    private Loader mCursorLoader = null;\n\n    // Saved states for undo\n    private Alarm mDeletedAlarm;\n    private Alarm mAddedAlarm;\n    private boolean mUndoShowing = false;\n\n    private Animator mFadeIn;\n    private Animator mFadeOut;\n\n    private Interpolator mExpandInterpolator;\n    private Interpolator mCollapseInterpolator;\n\n    private int mTimelineViewWidth;\n    private int mUndoBarInitialMargin;\n\n    // Cached layout positions of items in listview prior to add/removal of alarm item\n    private ConcurrentHashMap\u003cLong, Integer\u003e mItemIdTopMap = new ConcurrentHashMap\u003cLong, Integer\u003e();\n\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case MSG_PROFILE_STATUS_CHANGE:\n                    updateProfilesStatus();\n                    break;\n            }\n        }\n    };\n\n    public AlarmClockFragment() {\n        // Basic provider required by Fragment.java\n    }\n\n    @Override\n    public void onCreate(Bundle savedState) {\n        super.onCreate(savedState);\n        mCursorLoader = getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedState) {\n        // Inflate the layout for this fragment\n        final View v = inflater.inflate(R.layout.alarm_clock, container, false);\n\n        long[] expandedIds = null;\n        long[] repeatCheckedIds = null;\n        long[] selectedAlarms = null;\n        Bundle previousDayMap = null;\n        if (savedState != null) {\n            expandedIds = savedState.getLongArray(KEY_EXPANDED_IDS);\n            repeatCheckedIds = savedState.getLongArray(KEY_REPEAT_CHECKED_IDS);\n            mRingtoneTitleCache = savedState.getBundle(KEY_RINGTONE_TITLE_CACHE);\n            mDeletedAlarm = savedState.getParcelable(KEY_DELETED_ALARM);\n            mUndoShowing = savedState.getBoolean(KEY_UNDO_SHOWING);\n            selectedAlarms = savedState.getLongArray(KEY_SELECTED_ALARMS);\n            previousDayMap = savedState.getBundle(KEY_PREVIOUS_DAY_MAP);\n            mSelectedAlarm = savedState.getParcelable(KEY_SELECTED_ALARM);\n        }\n\n        // Register profiles status\n        mProfileManager = (ProfileManager) getActivity().getSystemService(Context.PROFILE_SERVICE);\n        mProfileObserver = new ProfilesObserver(mHandler);\n\n        mExpandInterpolator = new DecelerateInterpolator(EXPAND_DECELERATION);\n        mCollapseInterpolator = new DecelerateInterpolator(COLLAPSE_DECELERATION);\n\n        mAddAlarmButton = (ImageButton) v.findViewById(R.id.alarm_add_alarm);\n        mAddAlarmButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                hideUndoBar(true, null);\n                startCreatingAlarm();\n            }\n        });\n        // For landscape, put the add button on the right and the menu in the actionbar.\n        FrameLayout.LayoutParams layoutParams =\n                (FrameLayout.LayoutParams) mAddAlarmButton.getLayoutParams();\n        boolean isLandscape = getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n        if (isLandscape) {\n            layoutParams.gravity = Gravity.END;\n        } else {\n            layoutParams.gravity = Gravity.CENTER;\n        }\n        mAddAlarmButton.setLayoutParams(layoutParams);\n\n        View menuButton = v.findViewById(R.id.menu_button);\n        if (menuButton != null) {\n            if (isLandscape) {\n                menuButton.setVisibility(View.GONE);\n            } else {\n                menuButton.setVisibility(View.VISIBLE);\n                setupFakeOverflowMenuButton(menuButton);\n            }\n        }\n\n        mEmptyView = v.findViewById(R.id.alarms_empty_view);\n        mEmptyView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startCreatingAlarm();\n            }\n        });\n        mAlarmsList = (ListView) v.findViewById(R.id.alarms_list);\n\n        mFadeIn = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_in);\n        mFadeIn.setDuration(ANIMATION_DURATION);\n        mFadeIn.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator animation) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animation) {\n                // Do nothing.\n            }\n        });\n        mFadeIn.setTarget(mEmptyView);\n        mFadeOut = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_out);\n        mFadeOut.setDuration(ANIMATION_DURATION);\n        mFadeOut.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator arg0) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator arg0) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator arg0) {\n                mEmptyView.setVisibility(View.GONE);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator arg0) {\n                // Do nothing.\n            }\n        });\n        mFadeOut.setTarget(mEmptyView);\n        mAlarmsView = v.findViewById(R.id.alarm_layout);\n        mTimelineLayout = v.findViewById(R.id.timeline_layout);\n\n        mUndoBar = (ActionableToastBar) v.findViewById(R.id.undo_bar);\n        mUndoBarInitialMargin = getActivity().getResources()\n                .getDimensionPixelOffset(R.dimen.alarm_undo_bar_horizontal_margin);\n        mUndoFrame = v.findViewById(R.id.undo_frame);\n        mUndoFrame.setOnTouchListener(this);\n\n        mFooterView = v.findViewById(R.id.alarms_footer_view);\n        mFooterView.setOnTouchListener(this);\n\n        // Timeline layout only exists in tablet landscape mode for now.\n        if (mTimelineLayout != null) {\n            mTimelineView = (AlarmTimelineView) v.findViewById(R.id.alarm_timeline_view);\n            mTimelineViewWidth = getActivity().getResources()\n                    .getDimensionPixelOffset(R.dimen.alarm_timeline_layout_width);\n        }\n\n        mAdapter = new AlarmItemAdapter(getActivity(),\n                expandedIds, repeatCheckedIds, selectedAlarms, previousDayMap, mAlarmsList);\n        mAdapter.registerDataSetObserver(new DataSetObserver() {\n\n            private int prevAdapterCount = -1;\n\n            @Override\n            public void onChanged() {\n\n                final int count = mAdapter.getCount();\n                if (mDeletedAlarm != null \u0026\u0026 prevAdapterCount \u003e count) {\n                    showUndoBar();\n                }\n\n                // If there are no alarms in the adapter...\n                if (count == 0) {\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_red);\n\n                    // ...and if there exists a timeline view (currently only in tablet landscape)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        // ...and if the previous adapter had alarms (indicating a removal)...\n                        if (prevAdapterCount \u003e 0) {\n\n                            // Then animate in the \"no alarms\" icon...\n                            mFadeIn.start();\n\n                            // and animate out the alarm timeline view, expanding the width of the\n                            // alarms list / undo bar.\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mCollapseInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.addListener(new AnimatorListener() {\n\n                                @Override\n                                public void onAnimationCancel(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(false);\n                                }\n\n                                @Override\n                                public void onAnimationRepeat(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationStart(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(true);\n                                }\n\n                            });\n                            animator.start();\n                        } else {\n                            // If the previous adapter did not have alarms, no animation needed,\n                            // just hide the timeline view and show the \"no alarms\" icon.\n                            mTimelineLayout.setVisibility(View.GONE);\n                            mEmptyView.setVisibility(View.VISIBLE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just show the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.VISIBLE);\n                    }\n                } else {\n\n                    // Otherwise, if the adapter DOES contain alarms...\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_normal);\n\n                    // ...and if there exists a timeline view (currently in tablet landscape mode)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        mTimelineLayout.setVisibility(View.VISIBLE);\n                        // ...and if the previous adapter did not have alarms (indicating an add)\n                        if (prevAdapterCount == 0) {\n\n                            // Then, animate to hide the \"no alarms\" icon...\n                            mFadeOut.start();\n\n                            // and animate to show the timeline view, reducing the width of the\n                            // alarms list / undo bar.\n                            ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mExpandInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    ((FrameLayout.LayoutParams) mAlarmsView.getLayoutParams())\n                                        .setMargins(0, 0, (int) -rightOffset, 0);\n                                    mAlarmsView.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.start();\n                        } else {\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            mEmptyView.setVisibility(View.GONE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin + mTimelineViewWidth);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just hide the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.GONE);\n                    }\n                }\n\n                // Cache this adapter's count for when the adapter changes.\n                prevAdapterCount = count;\n                super.onChanged();\n            }\n        });\n\n        if (mRingtoneTitleCache == null) {\n            mRingtoneTitleCache = new Bundle();\n        }\n\n        mAlarmsList.setAdapter(mAdapter);\n        mAlarmsList.setVerticalScrollBarEnabled(true);\n        mAlarmsList.setOnCreateContextMenuListener(this);\n\n        mAudioManager = (AudioManager)getActivity().getSystemService(Context.AUDIO_SERVICE);\n\n        if (mUndoShowing) {\n            showUndoBar();\n        }\n        return v;\n    }\n\n    private void setUndoBarRightMargin(int margin) {\n        FrameLayout.LayoutParams params =\n                (FrameLayout.LayoutParams) mUndoBar.getLayoutParams();\n        ((FrameLayout.LayoutParams) mUndoBar.getLayoutParams())\n            .setMargins(params.leftMargin, params.topMargin, margin, params.bottomMargin);\n        mUndoBar.requestLayout();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Check if another app asked us to create a blank new alarm.\n        final Intent intent = getActivity().getIntent();\n        if (intent.hasExtra(ALARM_CREATE_NEW_INTENT_EXTRA)) {\n            if (intent.getBooleanExtra(ALARM_CREATE_NEW_INTENT_EXTRA, false)) {\n                // An external app asked us to create a blank alarm.\n                startCreatingAlarm();\n            }\n\n            // Remove the CREATE_NEW extra now that we've processed it.\n            intent.removeExtra(ALARM_CREATE_NEW_INTENT_EXTRA);\n        } else if (intent.hasExtra(SCROLL_TO_ALARM_INTENT_EXTRA)) {\n            long alarmId = intent.getLongExtra(SCROLL_TO_ALARM_INTENT_EXTRA, Alarm.INVALID_ID);\n            if (alarmId != Alarm.INVALID_ID) {\n                mScrollToAlarmId = alarmId;\n                if (mCursorLoader != null \u0026\u0026 mCursorLoader.isStarted()) {\n                    // We need to force a reload here to make sure we have the latest view\n                    // of the data to scroll to.\n                    mCursorLoader.forceLoad();\n                }\n            }\n\n            // Remove the SCROLL_TO_ALARM extra now that we've processed it.\n            intent.removeExtra(SCROLL_TO_ALARM_INTENT_EXTRA);\n        } else {\n            // If alarm stream volume is 0, show a warning\n            if (mAudioManager.getStreamVolume(AudioManager.STREAM_ALARM) == 0) {\n                showSilentWarningBar();\n            }\n\n        }\n\n        // Make sure to use the child FragmentManager. We have to use that one for the\n        // case where an intent comes in telling the activity to load the timepicker,\n        // which means we have to use that one everywhere so that the fragment can get\n        // correctly picked up here if it's open.\n        TimePickerDialog tpd = (TimePickerDialog) getChildFragmentManager().\n                findFragmentByTag(AlarmUtils.FRAG_TAG_TIME_PICKER);\n        if (tpd != null) {\n            // The dialog is already open so we need to set the listener again.\n            tpd.setOnTimeSetListener(this);\n        }\n\n        // Update the profile status and register the profile observer\n        getActivity().getContentResolver().registerContentObserver(\n                PROFILES_SETTINGS_URI, false, mProfileObserver);\n        updateProfilesStatus();\n    }\n\n    private void hideUndoBar(boolean animate, MotionEvent event) {\n        if (mUndoBar != null) {\n            mUndoFrame.setVisibility(View.GONE);\n            if (event != null \u0026\u0026 mUndoBar.isEventInToastBar(event)) {\n                // Avoid touches inside the undo bar.\n                return;\n            }\n            mUndoBar.hide(animate);\n        }\n        mDeletedAlarm = null;\n        mUndoShowing = false;\n    }\n\n    private void showUndoBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                asyncAddAlarm(mDeletedAlarm);\n                mDeletedAlarm = null;\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.alarm_deleted), true, 0, R.string.alarm_undo, true);\n    }\n\n    private void showSilentWarningBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                mAudioManager.adjustStreamVolume(AudioManager.STREAM_ALARM,\n                        AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.warn_silent_alarm_title), true,\n                R.drawable.ic_menu_alarms, 0, true);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLongArray(KEY_EXPANDED_IDS, mAdapter.getExpandedArray());\n        outState.putLongArray(KEY_REPEAT_CHECKED_IDS, mAdapter.getRepeatArray());\n        outState.putLongArray(KEY_SELECTED_ALARMS, mAdapter.getSelectedAlarmsArray());\n        outState.putBundle(KEY_RINGTONE_TITLE_CACHE, mRingtoneTitleCache);\n        outState.putParcelable(KEY_DELETED_ALARM, mDeletedAlarm);\n        outState.putBoolean(KEY_UNDO_SHOWING, mUndoShowing);\n        outState.putBundle(KEY_PREVIOUS_DAY_MAP, mAdapter.getPreviousDaysOfWeekMap());\n        outState.putParcelable(KEY_SELECTED_ALARM, mSelectedAlarm);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        ToastMaster.cancelToast();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        // When the user places the app in the background by pressing \"home\",\n        // dismiss the toast bar. However, since there is no way to determine if\n        // home was pressed, just dismiss any existing toast bar when restarting\n        // the app.\n        hideUndoBar(false, null);\n\n        // Unregister the profile observer\n        getActivity().getContentResolver().unregisterContentObserver(mProfileObserver);\n    }\n\n    // Callback used by TimePickerDialog\n    @Override\n    public void onTimeSet(RadialPickerLayout view, int hourOfDay, int minute) {\n        if (mSelectedAlarm == null) {\n            // If mSelectedAlarm is null then we're creating a new alarm.\n            Alarm a = new Alarm();\n            a.alert = RingtoneManager.getActualDefaultRingtoneUri(getActivity(),\n                    RingtoneManager.TYPE_ALARM);\n            if (a.alert == null) {\n                a.alert = Uri.parse(\"content://settings/system/alarm_alert\");\n            }\n            a.hour = hourOfDay;\n            a.minutes = minute;\n            a.enabled = true;\n            asyncAddAlarm(a);\n        } else {\n            mSelectedAlarm.hour = hourOfDay;\n            mSelectedAlarm.minutes = minute;\n            mSelectedAlarm.enabled = true;\n            mScrollToAlarmId = mSelectedAlarm.id;\n            asyncUpdateAlarm(mSelectedAlarm, true);\n            mSelectedAlarm = null;\n        }\n    }\n\n    private void showLabelDialog(final Alarm alarm) {\n        final FragmentTransaction ft = getFragmentManager().beginTransaction();\n        final Fragment prev = getFragmentManager().findFragmentByTag(\"label_dialog\");\n        if (prev != null) {\n            ft.remove(prev);\n        }\n        ft.addToBackStack(null);\n\n        // Create and show the dialog.\n        final LabelDialogFragment newFragment =\n                LabelDialogFragment.newInstance(alarm, alarm.label, getTag());\n        newFragment.show(ft, \"label_dialog\");\n    }\n\n    public void setLabel(Alarm alarm, String label) {\n        alarm.label = label;\n        asyncUpdateAlarm(alarm, false);\n    }\n\n    @Override\n    public Loader\u003cCursor\u003e onCreateLoader(int id, Bundle args) {\n        return Alarm.getAlarmsCursorLoader(getActivity());\n    }\n\n    @Override\n    public void onLoadFinished(Loader\u003cCursor\u003e cursorLoader, final Cursor data) {\n        mAdapter.swapCursor(data);\n        if (mScrollToAlarmId != -1) {\n            scrollToAlarm(mScrollToAlarmId);\n            mScrollToAlarmId = -1;\n        }\n    }\n\n    /**\n     * Scroll to alarm with given alarm id.\n     *\n     * @param alarmId The alarm id to scroll to.\n     */\n    private void scrollToAlarm(long alarmId) {\n        int alarmPosition = -1;\n        for (int i = 0; i \u003c mAdapter.getCount(); i++) {\n            long id = mAdapter.getItemId(i);\n            if (id == alarmId) {\n                alarmPosition = i;\n                break;\n            }\n        }\n\n        if (alarmPosition \u003e= 0) {\n            mAdapter.setNewAlarm(alarmId);\n            mAlarmsList.smoothScrollToPositionFromTop(alarmPosition, 0);\n        } else {\n            // Trying to display a deleted alarm should only happen from a missed notification for\n            // an alarm that has been marked deleted after use.\n            Context context = getActivity().getApplicationContext();\n            Toast toast = Toast.makeText(context, R.string.missed_alarm_has_been_deleted,\n                    Toast.LENGTH_LONG);\n            ToastMaster.setToast(toast);\n            toast.show();\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader\u003cCursor\u003e cursorLoader) {\n        mAdapter.swapCursor(null);\n    }\n\n    private void launchRingTonePicker(final Alarm alarm) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.alarm_picker_title).setItems(\n                R.array.ringtone_picker_entries,\n\n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        switch (which) {\n                            case 0:\n                                launchSingleRingTonePicker(alarm);\n                                break;\n                            case 1:\n                                alarm.alert = MultiPlayer.RANDOM_URI;\n                                asyncUpdateAlarm(alarm, false);\n                                break;\n                        }\n                    }\n                });\n        AlertDialog d = builder.create();\n        d.show();\n    }\n\n    private void launchSingleRingTonePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;\n        final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, oldRingtone);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, false);\n        startActivityForResult(intent, REQUEST_CODE_RINGTONE);\n    }\n\n    private void launchProfilePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        final Intent intent = new Intent(ProfileManager.ACTION_PROFILE_PICKER);\n\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_EXISTING_UUID, alarm.profile.toString());\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_SHOW_NONE, true);\n        startActivityForResult(intent, REQUEST_CODE_PROFILE);\n    }\n\n    private void saveRingtoneUri(Intent intent) {\n        Uri uri = intent.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);\n        if (uri == null) {\n            uri = Alarm.NO_RINGTONE_URI;\n        }\n        mSelectedAlarm.alert = uri;\n\n        // Save the last selected ringtone as the default for new alarms\n        if (!Alarm.NO_RINGTONE_URI.equals(uri)) {\n            RingtoneManager.setActualDefaultRingtoneUri(\n                    getActivity(), RingtoneManager.TYPE_ALARM, uri);\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private void saveProfile(Intent intent) {\n        final String uuid = intent.getStringExtra(ProfileManager.EXTRA_PROFILE_PICKED_UUID);\n        if (uuid != null) {\n            try {\n                mSelectedAlarm.profile = UUID.fromString(uuid);\n            } catch (IllegalArgumentException ex) {\n                mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n            }\n        } else {\n            mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private boolean isProfilesEnabled() {\n        return Settings.System.getInt(getActivity().getContentResolver(),\n                Settings.System.SYSTEM_PROFILES_ENABLED, 1) == 1;\n    }\n\n    private String getProfileName(Alarm alarm) {\n        if (!isProfilesEnabled() || alarm.profile.equals(ProfileManager.NO_PROFILE)) {\n            return getString(R.string.profile_no_selected);\n        }\n        Profile profile = mProfileManager.getProfile(alarm.profile);\n        if (profile == null) {\n            return getString(R.string.profile_no_selected);\n        }\n        return profile.getName();\n    }\n\n    private void updateProfilesStatus() {\n        // Need to refresh the data\n        if (mAdapter != null) {\n            mAdapter.notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == Activity.RESULT_OK) {\n            switch (requestCode) {\n                case REQUEST_CODE_RINGTONE:\n                    saveRingtoneUri(data);\n                    break;\n                case REQUEST_CODE_PROFILE:\n                    saveProfile(data);\n                default:\n                    Log.w(\"Unhandled request code in onActivityResult: \" + requestCode);\n            }\n        }\n    }\n\n    private class ProfilesObserver extends ContentObserver {\n        public ProfilesObserver(Handler handler) {\n            super(handler);\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n            onChange(selfChange, null);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            if (uri == null) return;\n            if (PROFILES_SETTINGS_URI.equals(uri)) {\n                mHandler.removeMessages(MSG_PROFILE_STATUS_CHANGE);\n                mHandler.sendEmptyMessage(MSG_PROFILE_STATUS_CHANGE);\n            }\n        }\n    }\n\n    public class AlarmItemAdapter extends CursorAdapter {\n        private static final int EXPAND_DURATION = 300;\n        private static final int COLLAPSE_DURATION = 250;\n\n        private final Context mContext;\n        private final LayoutInflater mFactory;\n        private final String[] mShortWeekDayStrings;\n        private final String[] mLongWeekDayStrings;\n        private final int mColorLit;\n        private final int mColorDim;\n        private final int mBackgroundColorExpanded;\n        private final int mBackgroundColor;\n        private final Typeface mRobotoNormal;\n        private final Typeface mRobotoBold;\n        private final ListView mList;\n\n        private final HashSet\u003cLong\u003e mExpanded = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mRepeatChecked = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mSelectedAlarms = new HashSet\u003cLong\u003e();\n        private Bundle mPreviousDaysOfWeekMap = new Bundle();\n\n        private final boolean mHasVibrator;\n        private final int mCollapseExpandHeight;\n\n        // This determines the order in which it is shown and processed in the UI.\n        // The array is filled when the adapter is created\n        private final int[] DAY_ORDER = new int[7];\n\n        public class ItemHolder {\n\n            // views for optimization\n            LinearLayout alarmItem;\n            TextTime clock;\n            Switch onoff;\n            TextView daysOfWeek;\n            TextView label;\n            ImageView delete;\n            View expandArea;\n            View summary;\n            TextView clickableLabel;\n            CheckBox repeat;\n            LinearLayout repeatDays;\n            ViewGroup[] dayButtonParents = new ViewGroup[7];\n            ToggleButton[] dayButtons = new ToggleButton[7];\n            CheckBox vibrate;\n            CheckBox increasingVolume;\n            TextView ringtone;\n            TextView profile;\n            View hairLine;\n            View arrow;\n            View collapseExpandArea;\n            View footerFiller;\n\n            // Other states\n            Alarm alarm;\n        }\n\n        // Used for scrolling an expanded item in the list to make sure it is fully visible.\n        private long mScrollAlarmId = -1;\n        private final Runnable mScrollRunnable = new Runnable() {\n            @Override\n            public void run() {\n                if (mScrollAlarmId != -1) {\n                    View v = getViewById(mScrollAlarmId);\n                    if (v != null) {\n                        Rect rect = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n                        mList.requestChildRectangleOnScreen(v, rect, false);\n                    }\n                    mScrollAlarmId = -1;\n                }\n            }\n        };\n\n        public AlarmItemAdapter(Context context, long[] expandedIds, long[] repeatCheckedIds,\n                long[] selectedAlarms, Bundle previousDaysOfWeekMap, ListView list) {\n            super(context, null, 0);\n            mContext = context;\n            mFactory = LayoutInflater.from(context);\n            mList = list;\n\n            DateFormatSymbols dfs = new DateFormatSymbols();\n            mShortWeekDayStrings = dfs.getShortWeekdays();\n            mLongWeekDayStrings = dfs.getWeekdays();\n            int firstDayOfWeek = Calendar.getInstance(Locale.getDefault()).getFirstDayOfWeek();\n            int j = 0;\n            for (int i = firstDayOfWeek; i \u003c= DAY_ORDER.length; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n            for (int i = Calendar.SUNDAY; i \u003c firstDayOfWeek; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n\n            Resources res = mContext.getResources();\n            mColorLit = res.getColor(R.color.clock_white);\n            mColorDim = res.getColor(R.color.clock_gray);\n            mBackgroundColorExpanded = res.getColor(R.color.alarm_whiteish);\n            mBackgroundColor = R.drawable.alarm_background_normal;\n\n            mRobotoBold = Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\n            mRobotoNormal = Typeface.create(\"sans-serif-condensed\", Typeface.NORMAL);\n\n            if (expandedIds != null) {\n                buildHashSetFromArray(expandedIds, mExpanded);\n            }\n            if (repeatCheckedIds != null) {\n                buildHashSetFromArray(repeatCheckedIds, mRepeatChecked);\n            }\n            if (previousDaysOfWeekMap != null) {\n                mPreviousDaysOfWeekMap = previousDaysOfWeekMap;\n            }\n            if (selectedAlarms != null) {\n                buildHashSetFromArray(selectedAlarms, mSelectedAlarms);\n            }\n\n            mHasVibrator = ((Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE))\n                    .hasVibrator();\n\n            mCollapseExpandHeight = (int) res.getDimension(R.dimen.collapse_expand_height);\n        }\n\n        public void removeSelectedId(int id) {\n            mSelectedAlarms.remove(id);\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (!getCursor().moveToPosition(position)) {\n                // May happen if the last alarm was deleted and the cursor refreshed while the\n                // list is updated.\n                Log.v(\"couldn't move cursor to position \" + position);\n                return null;\n            }\n            View v;\n            if (convertView == null) {\n                v = newView(mContext, getCursor(), parent);\n            } else {\n                // TODO temporary hack to prevent the convertView from not having stuff we need.\n                boolean badConvertView = convertView.findViewById(R.id.digital_clock) == null;\n                // Do a translation check to test for animation. Change this to something more\n                // reliable and robust in the future.\n                if (convertView.getTranslationX() != 0 || convertView.getTranslationY() != 0 ||\n                        badConvertView) {\n                    // view was animated, reset\n                    v = newView(mContext, getCursor(), parent);\n                } else {\n                    v = convertView;\n                }\n            }\n            bindView(v, mContext, getCursor());\n            ItemHolder holder = (ItemHolder) v.getTag();\n\n            // We need the footer for the last element of the array to allow the user to scroll\n            // the item beyond the bottom button bar, which obscures the view.\n            holder.footerFiller.setVisibility(position \u003c getCount() - 1 ? View.GONE : View.VISIBLE);\n            return v;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            final View view = mFactory.inflate(R.layout.alarm_time, parent, false);\n            setNewHolder(view);\n            return view;\n        }\n\n        /**\n         * In addition to changing the data set for the alarm list, swapCursor is now also\n         * responsible for preparing the list view's pre-draw operation for any animations that\n         * need to occur if an alarm was removed or added.\n         */\n        @Override\n        public synchronized Cursor swapCursor(Cursor cursor) {\n            Cursor c = super.swapCursor(cursor);\n\n            if (mItemIdTopMap.isEmpty() \u0026\u0026 mAddedAlarm == null) {\n                return c;\n            }\n\n            final ListView list = mAlarmsList;\n            final ViewTreeObserver observer = list.getViewTreeObserver();\n\n            /*\n             * Add a pre-draw listener to the observer to prepare for any possible animations to\n             * the alarms within the list view.  The animations will occur if an alarm has been\n             * removed or added.\n             *\n             * For alarm removal, the remaining children should all retain their initial starting\n             * positions, and transition to their new positions.\n             *\n             * For alarm addition, the other children should all retain their initial starting\n             * positions, transition to their new positions, and at the end of that transition, the\n             * newly added alarm should appear in the designated space.\n             */\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n\n                private View mAddedView;\n\n                @Override\n                public boolean onPreDraw() {\n                    // Remove the pre-draw listener, as this only needs to occur once.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    boolean firstAnimation = true;\n                    int firstVisiblePosition = list.getFirstVisiblePosition();\n\n                    // Iterate through the children to prepare the add/remove animation.\n                    for (int i = 0; i\u003c list.getChildCount(); i++) {\n                        final View child = list.getChildAt(i);\n\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n\n                        // If this is the added alarm, set it invisible for now, and animate later.\n                        if (mAddedAlarm != null \u0026\u0026 itemId == mAddedAlarm.id) {\n                            mAddedView = child;\n                            mAddedView.setAlpha(0.0f);\n                            continue;\n                        }\n\n                        // The cached starting position of the child view.\n                        Integer startTop = mItemIdTopMap.get(itemId);\n                        // The new starting position of the child view.\n                        int top = child.getTop();\n\n                        // If there is no cached starting position, determine whether the item has\n                        // come from the top of bottom of the list view.\n                        if (startTop == null) {\n                            int childHeight = child.getHeight() + list.getDividerHeight();\n                            startTop = top + (i \u003e 0 ? childHeight : -childHeight);\n                        }\n\n                        Log.d(\"Start Top: \" + startTop + \", Top: \" + top);\n                        // If the starting position of the child view is different from the\n                        // current position, animate the child.\n                        if (startTop != top) {\n                            int delta = startTop - top;\n                            child.setTranslationY(delta);\n                            child.animate().setDuration(ANIMATION_DURATION).translationY(0);\n                            final View addedView = mAddedView;\n                            if (firstAnimation) {\n\n                                // If this is the first child being animated, then after the\n                                // animation is complete, and animate in the added alarm (if one\n                                // exists).\n                                child.animate().withEndAction(new Runnable() {\n\n                                    @Override\n                                    public void run() {\n\n\n                                        // If there was an added view, animate it in after\n                                        // the other views have animated.\n                                        if (addedView != null) {\n                                            addedView.animate().alpha(1.0f)\n                                                .setDuration(ANIMATION_DURATION)\n                                                .withEndAction(new Runnable() {\n\n                                                    @Override\n                                                    public void run() {\n                                                        // Re-enable the list after the add\n                                                        // animation is complete.\n                                                        list.setEnabled(true);\n                                                    }\n\n                                                });\n                                        } else {\n                                            // Re-enable the list after animations are complete.\n                                            list.setEnabled(true);\n                                        }\n                                    }\n\n                                });\n                                firstAnimation = false;\n                            }\n                        }\n                    }\n\n                    // If there were no child views (outside of a possible added view)\n                    // that require animation...\n                    if (firstAnimation) {\n                        if (mAddedView != null) {\n                            // If there is an added view, prepare animation for the added view.\n                            Log.d(\"Animating added view...\");\n                            mAddedView.animate().alpha(1.0f)\n                                .setDuration(ANIMATION_DURATION)\n                                .withEndAction(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        // Re-enable the list after animations are complete.\n                                        list.setEnabled(true);\n                                    }\n                                });\n                        } else {\n                            // Re-enable the list after animations are complete.\n                            list.setEnabled(true);\n                        }\n                    }\n\n                    mAddedAlarm = null;\n                    mItemIdTopMap.clear();\n                    return true;\n                }\n            });\n            return c;\n        }\n\n        private void setNewHolder(View view) {\n            // standard view holder optimization\n            final ItemHolder holder = new ItemHolder();\n            holder.alarmItem = (LinearLayout) view.findViewById(R.id.alarm_item);\n            holder.clock = (TextTime) view.findViewById(R.id.digital_clock);\n            holder.onoff = (Switch) view.findViewById(R.id.onoff);\n            holder.onoff.setTypeface(mRobotoNormal);\n            holder.daysOfWeek = (TextView) view.findViewById(R.id.daysOfWeek);\n            holder.label = (TextView) view.findViewById(R.id.label);\n            holder.delete = (ImageView) view.findViewById(R.id.delete);\n            holder.summary = view.findViewById(R.id.summary);\n            holder.expandArea = view.findViewById(R.id.expand_area);\n            holder.hairLine = view.findViewById(R.id.hairline);\n            holder.arrow = view.findViewById(R.id.arrow);\n            holder.repeat = (CheckBox) view.findViewById(R.id.repeat_onoff);\n            holder.clickableLabel = (TextView) view.findViewById(R.id.edit_label);\n            holder.repeatDays = (LinearLayout) view.findViewById(R.id.repeat_days);\n            holder.collapseExpandArea = view.findViewById(R.id.collapse_expand);\n            holder.footerFiller = view.findViewById(R.id.alarm_footer_filler);\n            holder.footerFiller.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // Do nothing.\n                }\n            });\n\n            // Build button for each day.\n            for (int i = 0; i \u003c 7; i++) {\n                final ViewGroup viewgroup = (ViewGroup) mFactory.inflate(R.layout.day_button,\n                        holder.repeatDays, false);\n                final ToggleButton button = (ToggleButton) viewgroup.getChildAt(0);\n                final int dayToShowIndex = DAY_ORDER[i];\n                button.setText(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOn(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOff(mShortWeekDayStrings[dayToShowIndex]);\n                button.setContentDescription(mLongWeekDayStrings[dayToShowIndex]);\n                holder.repeatDays.addView(viewgroup);\n                holder.dayButtons[i] = button;\n                holder.dayButtonParents[i] = viewgroup;\n            }\n            holder.vibrate = (CheckBox) view.findViewById(R.id.vibrate_onoff);\n            holder.increasingVolume = (CheckBox) view.findViewById(R.id.increasing_volume_onoff);\n            holder.ringtone = (TextView) view.findViewById(R.id.choose_ringtone);\n            holder.profile = (TextView) view.findViewById(R.id.choose_profile);\n\n            view.setTag(holder);\n        }\n\n        @Override\n        public void bindView(final View view, Context context, final Cursor cursor) {\n            final Alarm alarm = new Alarm(cursor);\n            Object tag = view.getTag();\n            if (tag == null) {\n                // The view was converted but somehow lost its tag.\n                setNewHolder(view);\n            }\n            final ItemHolder itemHolder = (ItemHolder) tag;\n            itemHolder.alarm = alarm;\n\n            // We must unset the listener first because this maybe a recycled view so changing the\n            // state would affect the wrong alarm.\n            itemHolder.onoff.setOnCheckedChangeListener(null);\n            itemHolder.onoff.setChecked(alarm.enabled);\n\n            if (mSelectedAlarms.contains(itemHolder.alarm.id)) {\n                itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n                setItemAlpha(itemHolder, true);\n                itemHolder.onoff.setEnabled(false);\n            } else {\n                itemHolder.onoff.setEnabled(true);\n                itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n                setItemAlpha(itemHolder, itemHolder.onoff.isChecked());\n            }\n            itemHolder.clock.setFormat(\n                    (int)mContext.getResources().getDimension(R.dimen.alarm_label_size));\n            itemHolder.clock.setTime(alarm.hour, alarm.minutes);\n            itemHolder.clock.setClickable(true);\n            itemHolder.clock.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    mSelectedAlarm = itemHolder.alarm;\n                    AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                            alarm, AlarmClockFragment.this\n                            , DateFormat.is24HourFormat(getActivity()));\n                    expandAlarm(itemHolder, true);\n                    itemHolder.alarmItem.post(mScrollRunnable);\n                }\n            });\n\n            final CompoundButton.OnCheckedChangeListener onOffListener =\n                    new CompoundButton.OnCheckedChangeListener() {\n                        @Override\n                        public void onCheckedChanged(CompoundButton compoundButton,\n                                boolean checked) {\n                            if (checked != alarm.enabled) {\n                                setItemAlpha(itemHolder, checked);\n                                alarm.enabled = checked;\n                                asyncUpdateAlarm(alarm, alarm.enabled);\n                            }\n                        }\n                    };\n\n            itemHolder.onoff.setOnCheckedChangeListener(onOffListener);\n\n            boolean expanded = isAlarmExpanded(alarm);\n            itemHolder.expandArea.setVisibility(expanded? View.VISIBLE : View.GONE);\n            itemHolder.summary.setVisibility(expanded? View.GONE : View.VISIBLE);\n\n            String labelSpace = \"\";\n            // Set the repeat text or leave it blank if it does not repeat.\n            final String daysOfWeekStr =\n                    alarm.daysOfWeek.toString(AlarmClockFragment.this.getActivity(), false);\n            if (daysOfWeekStr != null \u0026\u0026 daysOfWeekStr.length() != 0) {\n                itemHolder.daysOfWeek.setText(daysOfWeekStr);\n                itemHolder.daysOfWeek.setContentDescription(alarm.daysOfWeek.toAccessibilityString(\n                        AlarmClockFragment.this.getActivity()));\n                itemHolder.daysOfWeek.setVisibility(View.VISIBLE);\n                labelSpace = \"  \";\n                itemHolder.daysOfWeek.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n\n            } else {\n                itemHolder.daysOfWeek.setVisibility(View.GONE);\n            }\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() != 0) {\n                itemHolder.label.setText(alarm.label + labelSpace);\n                itemHolder.label.setVisibility(View.VISIBLE);\n                itemHolder.label.setContentDescription(\n                        mContext.getResources().getString(R.string.label_description) + \" \"\n                        + alarm.label);\n                itemHolder.label.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n            } else {\n                itemHolder.label.setVisibility(View.GONE);\n            }\n\n            itemHolder.delete.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    mDeletedAlarm = alarm;\n\n                    view.animate().setDuration(ANIMATION_DURATION).alpha(0).translationY(-1)\n                    .withEndAction(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            asyncDeleteAlarm(mDeletedAlarm, view);\n                        }\n                    });\n                }\n            });\n\n            if (expanded) {\n                expandAlarm(itemHolder, false);\n            } else {\n                collapseAlarm(itemHolder, false);\n            }\n\n            itemHolder.alarmItem.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    if (isAlarmExpanded(alarm)) {\n                        collapseAlarm(itemHolder, true);\n                    } else {\n                        expandAlarm(itemHolder, true);\n                    }\n                }\n            });\n\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n        }\n\n        private void bindExpandArea(final ItemHolder itemHolder, final Alarm alarm) {\n            // Views in here are not bound until the item is expanded.\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() \u003e 0) {\n                itemHolder.clickableLabel.setText(alarm.label);\n                itemHolder.clickableLabel.setTextColor(mColorLit);\n            } else {\n                itemHolder.clickableLabel.setText(R.string.label);\n                itemHolder.clickableLabel.setTextColor(mColorDim);\n            }\n            itemHolder.clickableLabel.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    showLabelDialog(alarm);\n                }\n            });\n\n            if (mRepeatChecked.contains(alarm.id) || itemHolder.alarm.daysOfWeek.isRepeating()) {\n                itemHolder.repeat.setChecked(true);\n                itemHolder.repeatDays.setVisibility(View.VISIBLE);\n            } else {\n                itemHolder.repeat.setChecked(false);\n                itemHolder.repeatDays.setVisibility(View.GONE);\n            }\n            itemHolder.repeat.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    final boolean checked = ((CheckBox) view).isChecked();\n                    if (checked) {\n                        // Show days\n                        itemHolder.repeatDays.setVisibility(View.VISIBLE);\n                        mRepeatChecked.add(alarm.id);\n\n                        // Set all previously set days\n                        // or\n                        // Set all days if no previous.\n                        final int bitSet = mPreviousDaysOfWeekMap.getInt(\"\" + alarm.id);\n                        alarm.daysOfWeek.setBitSet(bitSet);\n                        if (!alarm.daysOfWeek.isRepeating()) {\n                            alarm.daysOfWeek.setDaysOfWeek(true, DAY_ORDER);\n                        }\n                        updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n                    } else {\n                        itemHolder.repeatDays.setVisibility(View.GONE);\n                        mRepeatChecked.remove(alarm.id);\n\n                        // Remember the set days in case the user wants it back.\n                        final int bitSet = alarm.daysOfWeek.getBitSet();\n                        mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id, bitSet);\n\n                        // Remove all repeat days\n                        alarm.daysOfWeek.clearAllDays();\n                    }\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n            for (int i = 0; i \u003c 7; i++) {\n                final int buttonIndex = i;\n\n                itemHolder.dayButtonParents[i].setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        itemHolder.dayButtons[buttonIndex].toggle();\n                        final boolean checked = itemHolder.dayButtons[buttonIndex].isChecked();\n                        int day = DAY_ORDER[buttonIndex];\n                        alarm.daysOfWeek.setDaysOfWeek(checked, day);\n                        if (checked) {\n                            turnOnDayOfWeek(itemHolder, buttonIndex);\n                        } else {\n                            turnOffDayOfWeek(itemHolder, buttonIndex);\n\n                            // See if this was the last day, if so, un-check the repeat box.\n                            if (!alarm.daysOfWeek.isRepeating()) {\n                                itemHolder.repeatDays.setVisibility(View.GONE);\n                                itemHolder.repeat.setTextColor(mColorDim);\n                                mRepeatChecked.remove(alarm.id);\n\n                                // Set history to no days, so it will be everyday when repeat is\n                                // turned back on\n                                mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id,\n                                        DaysOfWeek.NO_DAYS_SET);\n                            }\n                        }\n                        asyncUpdateAlarm(alarm, false);\n                    }\n                });\n            }\n\n\n            if (!mHasVibrator) {\n                itemHolder.vibrate.setVisibility(View.INVISIBLE);\n            } else {\n                itemHolder.vibrate.setVisibility(View.VISIBLE);\n                if (!alarm.vibrate) {\n                    itemHolder.vibrate.setChecked(false);\n                    itemHolder.vibrate.setTextColor(mColorDim);\n                } else {\n                    itemHolder.vibrate.setChecked(true);\n                    itemHolder.vibrate.setTextColor(mColorLit);\n                }\n            }\n\n            itemHolder.vibrate.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    if (checked) {\n                        itemHolder.vibrate.setTextColor(mColorLit);\n                    } else {\n                        itemHolder.vibrate.setTextColor(mColorDim);\n                    }\n                    alarm.vibrate = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String ringtone;\n            final String ringtitle;\n            if (Alarm.NO_RINGTONE_URI.equals(alarm.alert)) {\n                ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n            } else {\n                ringtitle = getRingToneTitle(alarm.alert);\n                if (ringtitle != null) {\n                    ringtone = ringtitle;\n                } else {\n                    ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n                }\n            }\n            itemHolder.ringtone.setText(ringtone);\n            itemHolder.ringtone.setContentDescription(\n                    mContext.getResources().getString(R.string.ringtone_description) + \" \"\n                            + ringtone);\n            itemHolder.ringtone.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchRingTonePicker(alarm);\n                }\n            });\n\n\n            itemHolder.increasingVolume.setVisibility(View.VISIBLE);\n            itemHolder.increasingVolume.setChecked(alarm.increasingVolume);\n            itemHolder.increasingVolume.setTextColor(\n                    alarm.increasingVolume ? mColorLit : mColorDim);\n            itemHolder.increasingVolume.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    //When action mode is on - simulate long click\n                    itemHolder.increasingVolume.setTextColor(checked ? mColorLit : mColorDim);\n                    alarm.increasingVolume = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String profile = getProfileName(alarm);\n            itemHolder.profile.setText(profile);\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n            itemHolder.profile.setContentDescription(\n                    mContext.getResources().getString(R.string.profile_description, profile));\n            itemHolder.profile.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchProfilePicker(alarm);\n                }\n            });\n        }\n\n        // Sets the alpha of the item except the on/off switch. This gives a visual effect\n        // for enabled/disabled alarm while leaving the on/off switch more visible\n        private void setItemAlpha(ItemHolder holder, boolean enabled) {\n            float alpha = enabled ? 1f : 0.5f;\n            holder.clock.setAlpha(alpha);\n            holder.summary.setAlpha(alpha);\n            holder.expandArea.setAlpha(alpha);\n            holder.delete.setAlpha(alpha);\n            holder.daysOfWeek.setAlpha(alpha);\n        }\n\n        private void updateDaysOfWeekButtons(ItemHolder holder, DaysOfWeek daysOfWeek) {\n            HashSet\u003cInteger\u003e setDays = daysOfWeek.getSetDays();\n            for (int i = 0; i \u003c 7; i++) {\n                if (setDays.contains(DAY_ORDER[i])) {\n                    turnOnDayOfWeek(holder, i);\n                } else {\n                    turnOffDayOfWeek(holder, i);\n                }\n            }\n        }\n\n        public void toggleSelectState(View v) {\n            // long press could be on the parent view or one of its childs, so find the parent view\n            v = getTopParent(v);\n            if (v != null) {\n                long id = ((ItemHolder)v.getTag()).alarm.id;\n                if (mSelectedAlarms.contains(id)) {\n                    mSelectedAlarms.remove(id);\n                } else {\n                    mSelectedAlarms.add(id);\n                }\n            }\n        }\n\n        private View getTopParent(View v) {\n            while (v != null \u0026\u0026 v.getId() != R.id.alarm_item) {\n                v = (View) v.getParent();\n            }\n            return v;\n        }\n\n        public int getSelectedItemsNum() {\n            return mSelectedAlarms.size();\n        }\n\n        private void turnOffDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(false);\n            holder.dayButtons[dayIndex].setTextColor(mColorDim);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoNormal);\n        }\n\n        private void turnOnDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(true);\n            holder.dayButtons[dayIndex].setTextColor(mColorLit);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoBold);\n        }\n\n\n        /**\n         * Does a read-through cache for ringtone titles.\n         *\n         * @param uri The uri of the ringtone.\n         * @return The ringtone title. {@literal null} if no matching ringtone found.\n         */\n        private String getRingToneTitle(Uri uri) {\n            // Try the cache first\n            String title = mRingtoneTitleCache.getString(uri.toString());\n            if (title == null) {\n                if (uri.equals(MultiPlayer.RANDOM_URI)) {\n                    title = mContext.getResources().getString(R.string.alarm_type_random);\n                } else {\n                    // This is slow because a media player is created during Ringtone object creation.\n                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);\n                    if (ringTone != null) {\n                        title = ringTone.getTitle(mContext);\n                    }\n                }\n                if (title != null) {\n                    mRingtoneTitleCache.putString(uri.toString(), title);\n                }\n            }\n            return title;\n        }\n\n        public void setNewAlarm(long alarmId) {\n            mExpanded.add(alarmId);\n        }\n\n        /**\n         * Expands the alarm for editing.\n         *\n         * @param itemHolder The item holder instance.\n         */\n        private void expandAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.add(itemHolder.alarm.id);\n            bindExpandArea(itemHolder, itemHolder.alarm);\n            // Scroll the view to make sure it is fully viewed\n            mScrollAlarmId = itemHolder.alarm.id;\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to visible so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n            itemHolder.expandArea.setVisibility(View.VISIBLE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(180);\n                // We need to translate the hairline up, so the height of the collapseArea\n                // needs to be measured to know how high to translate it.\n                final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n                observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                    @Override\n                    public boolean onPreDraw() {\n                        // We don't want to continue getting called for every listview drawing.\n                        if (observer.isAlive()) {\n                            observer.removeOnPreDrawListener(this);\n                        }\n                        int hairlineHeight = itemHolder.hairLine.getHeight();\n                        int collapseHeight =\n                                itemHolder.collapseExpandArea.getHeight() - hairlineHeight;\n                        itemHolder.hairLine.setTranslationY(-collapseHeight);\n                        return true;\n                    }\n                });\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to VISIBLE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * the height is set back to the starting point so it can be animated down.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    // We don't want to continue getting called for every listview drawing.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    final int collapseHeight = itemHolder.collapseExpandArea.getHeight();\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = collapseHeight - hairlineHeight;\n\n                    // Set the height back to the start state of the animation.\n                    itemHolder.alarmItem.getLayoutParams().height = startingHeight;\n                    // To allow the expandArea to glide in with the expansion animation, set a\n                    // negative top margin, which will animate down to a margin of 0 as the height\n                    // is increased.\n                    // Note that we need to maintain the bottom margin as a fixed value (instead of\n                    // just using a listview, to allow for a flatter hierarchy) to fit the bottom\n                    // bar underneath.\n                    FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                            itemHolder.expandArea.getLayoutParams();\n                    expandParams.setMargins(0, -distance, 0, collapseHeight);\n                    itemHolder.alarmItem.requestLayout();\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(EXPAND_DURATION);\n                    animator.setInterpolator(mExpandInterpolator);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) -((1 - value) * distance), 0, collapseHeight);\n                            itemHolder.arrow.setRotation(180 * value);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * value);\n                            itemHolder.summary.setAlpha(1 - value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n                            itemHolder.arrow.setRotation(180);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance);\n                            itemHolder.summary.setVisibility(View.GONE);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    // Return false so this draw does not occur to prevent the final frame from\n                    // being drawn for the single frame before the animations start.\n                    return false;\n                }\n            });\n        }\n\n        private boolean isAlarmExpanded(Alarm alarm) {\n            return mExpanded.contains(alarm.id);\n        }\n\n        private void collapseAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.remove(itemHolder.alarm.id);\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to gone so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n            itemHolder.expandArea.setVisibility(View.GONE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(0);\n                itemHolder.hairLine.setTranslationY(0);\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to GONE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * expandArea is set to VISIBLE again so it can be shown animating.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = mCollapseExpandHeight - hairlineHeight;\n\n                    // Re-set the visibilities for the start state of the animation.\n                    itemHolder.expandArea.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setAlpha(1);\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(COLLAPSE_DURATION);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) (value * distance), 0, mCollapseExpandHeight);\n                            itemHolder.arrow.setRotation(180 * (1 - value));\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * (1 - value));\n                            itemHolder.summary.setAlpha(value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    animator.setInterpolator(mCollapseInterpolator);\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(0, 0, 0, mCollapseExpandHeight);\n\n                            itemHolder.expandArea.setVisibility(View.GONE);\n                            itemHolder.arrow.setRotation(0);\n                            itemHolder.hairLine.setTranslationY(0);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    return false;\n                }\n            });\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            return 1;\n        }\n\n        private View getViewById(long id) {\n            for (int i = 0; i \u003c mList.getCount(); i++) {\n                View v = mList.getChildAt(i);\n                if (v != null) {\n                    ItemHolder h = (ItemHolder)(v.getTag());\n                    if (h != null \u0026\u0026 h.alarm.id == id) {\n                        return v;\n                    }\n                }\n            }\n            return null;\n        }\n\n        public long[] getExpandedArray() {\n            int index = 0;\n            long[] ids = new long[mExpanded.size()];\n            for (long id : mExpanded) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getSelectedAlarmsArray() {\n            int index = 0;\n            long[] ids = new long[mSelectedAlarms.size()];\n            for (long id : mSelectedAlarms) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getRepeatArray() {\n            int index = 0;\n            long[] ids = new long[mRepeatChecked.size()];\n            for (long id : mRepeatChecked) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public Bundle getPreviousDaysOfWeekMap() {\n            return mPreviousDaysOfWeekMap;\n        }\n\n        private void buildHashSetFromArray(long[] ids, HashSet\u003cLong\u003e set) {\n            for (long id : ids) {\n                set.add(id);\n            }\n        }\n    }\n\n    private void startCreatingAlarm() {\n        // Set the \"selected\" alarm as null, and we'll create the new one when the timepicker\n        // comes back.\n        mSelectedAlarm = null;\n        AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                null, AlarmClockFragment.this, DateFormat.is24HourFormat(getActivity()));\n    }\n\n    private static AlarmInstance setupAlarmInstance(Context context, Alarm alarm) {\n        ContentResolver cr = context.getContentResolver();\n        AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());\n        newInstance = AlarmInstance.addInstance(cr, newInstance);\n        // Register instance to state manager\n        AlarmStateManager.registerInstance(context, newInstance, true);\n        return newInstance;\n    }\n\n    private void asyncDeleteAlarm(final Alarm alarm, final View viewToRemove) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, Void\u003e deleteTask = new AsyncTask\u003cVoid, Void, Void\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                if (viewToRemove == null) {\n                    return;\n                }\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                final ListView list = mAlarmsList;\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    if (child != viewToRemove) {\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n                        mItemIdTopMap.put(itemId, child.getTop());\n                    }\n                }\n            }\n\n            @Override\n            protected Void doInBackground(Void... parameters) {\n                // Activity may be closed at this point , make sure data is still valid\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n                    AlarmStateManager.deleteAllInstances(context, alarm.id);\n                    Alarm.deleteAlarm(cr, alarm.id);\n                }\n                return null;\n            }\n        };\n        mUndoShowing = true;\n        deleteTask.execute();\n    }\n\n    private void asyncAddAlarm(final Alarm alarm) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                final ListView list = mAlarmsList;\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    int position = firstVisiblePosition + i;\n                    long itemId = mAdapter.getItemId(position);\n                    mItemIdTopMap.put(itemId, child.getTop());\n                }\n            }\n\n            @Override\n            protected AlarmInstance doInBackground(Void... parameters) {\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n\n                    // Add alarm to db\n                    Alarm newAlarm = Alarm.addAlarm(cr, alarm);\n                    mScrollToAlarmId = newAlarm.id;\n\n                    // Create and add instance to db\n                    if (newAlarm.enabled) {\n                        return setupAlarmInstance(context, newAlarm);\n                    }\n                }\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    private void asyncUpdateAlarm(final Alarm alarm, final boolean popToast) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            protected AlarmInstance doInBackground(Void ... parameters) {\n                ContentResolver cr = context.getContentResolver();\n\n                // Dismiss all old instances\n                AlarmStateManager.deleteAllInstances(context, alarm.id);\n\n                // Update alarm\n                Alarm.updateAlarm(cr, alarm);\n                if (alarm.enabled) {\n                    return setupAlarmInstance(context, alarm);\n                }\n\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (popToast \u0026\u0026 instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        hideUndoBar(true, event);\n        return false;\n    }\n}","comments":[{"author":{"accountId":4550,"email":"mikeioannina@gmail.com","name":"Michael Bestas","username":"mikeioannina"},"date":"2014-05-24T19:24:04.000Z","id":"da0c15f0_dc518b10","line":574,"message":"ic_menu_alarms is horrible, we need to use a holo icon like ic_alarm"}],"name":"src/com/android/deskclock/AlarmClockFragment.java"},"src/com/android/deskclock/widget/ActionableToastBar.java":{"a":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.deskclock.widget;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorInflater;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.android.deskclock.R;\n\n/**\n * A custom {@link View} that exposes an action to the user.\n * \u003cp\u003e\n * This is a copy of packages/apps/UnifiedEmail/src/com/android/mail/ui/ActionableToastBar.java\n * with minor modifications.\n */\npublic class ActionableToastBar extends LinearLayout {\n    private boolean mHidden = false;\n    private Animator mShowAnimation;\n    private Animator mHideAnimation;\n    private final int mBottomMarginSizeInConversation;\n\n    /** Icon for the description. */\n    private ImageView mActionDescriptionIcon;\n    /** The clickable view */\n    private View mActionButton;\n    /** Icon for the action button. */\n    private View mActionIcon;\n    /** The view that contains the description. */\n    private TextView mActionDescriptionView;\n    /** The view that contains the text for the action button. */\n    private TextView mActionText;\n    //private ToastBarOperation mOperation;\n\n    public ActionableToastBar(Context context) {\n        this(context, null);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mBottomMarginSizeInConversation = context.getResources().getDimensionPixelSize(\n                R.dimen.toast_bar_bottom_margin_in_conversation);\n        LayoutInflater.from(context).inflate(R.layout.actionable_toast_row, this, true);\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        mActionDescriptionIcon = (ImageView) findViewById(R.id.description_icon);\n        mActionDescriptionView = (TextView) findViewById(R.id.description_text);\n        mActionButton = findViewById(R.id.action_button);\n        mActionIcon = findViewById(R.id.action_icon);\n        mActionText = (TextView) findViewById(R.id.action_text);\n    }\n\n    /**\n     * Tells the view that it will be appearing in the conversation pane\n     * and should adjust its layout parameters accordingly.\n     * @param isInConversationMode true if the view will be shown in the conversation view\n     */\n    public void setConversationMode(boolean isInConversationMode) {\n        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams();\n        params.bottomMargin = isInConversationMode ? mBottomMarginSizeInConversation : 0;\n        setLayoutParams(params);\n    }\n\n    /**\n     * Displays the toast bar and makes it visible. Allows the setting of\n     * parameters to customize the display.\n     * @param listener performs some action when the action button is clicked\n     * @param descriptionIconResourceId resource ID for the description icon or\n     * 0 if no icon should be shown\n     * @param descriptionText a description text to show in the toast bar\n     * @param showActionIcon if true, the action button icon should be shown\n     * @param actionTextResource resource ID for the text to show in the action button\n     * @param replaceVisibleToast if true, this toast should replace any currently visible toast.\n     * Otherwise, skip showing this toast.\n     */\n    public void show(final ActionClickedListener listener, int descriptionIconResourceId,\n            CharSequence descriptionText, boolean showActionIcon, int actionTextResource,\n            boolean replaceVisibleToast) {\n\n        if (!mHidden \u0026\u0026 !replaceVisibleToast) {\n            return;\n        }\n\n        mActionButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View widget) {\n                if (listener != null) {\n                    listener.onActionClicked();\n                }\n                hide(true);\n            }\n        });\n\n        // Set description icon.\n        if (descriptionIconResourceId == 0) {\n            mActionDescriptionIcon.setVisibility(GONE);\n        } else {\n            mActionDescriptionIcon.setVisibility(VISIBLE);\n            mActionDescriptionIcon.setImageResource(descriptionIconResourceId);\n        }\n\n        mActionDescriptionView.setText(descriptionText);\n        mActionIcon.setVisibility(showActionIcon ? VISIBLE : GONE);\n        mActionText.setText(actionTextResource);\n\n        mHidden = false;\n        getShowAnimation().start();\n    }\n\n    /**\n     * Hides the view and resets the state.\n     */\n    public void hide(boolean animate) {\n        // Prevent multiple call to hide.\n        // Also prevent hiding if show animation is going on.\n        if (!mHidden \u0026\u0026 !getShowAnimation().isRunning()) {\n            mHidden = true;\n            if (getVisibility() == View.VISIBLE) {\n                mActionDescriptionView.setText(\"\");\n                mActionButton.setOnClickListener(null);\n                // Hide view once it's clicked.\n                if (animate) {\n                    getHideAnimation().start();\n                } else {\n                    setAlpha(0);\n                    setVisibility(View.GONE);\n                }\n            }\n        }\n    }\n\n    private Animator getShowAnimation() {\n        if (mShowAnimation == null) {\n            mShowAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_in);\n            mShowAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    // There is a tiny change that and hide animation could have finished right\n                    // before the show animation finished.  In that case, the hide will mark the\n                    // view as GONE.  We need to make sure the last one wins.\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n            });\n            mShowAnimation.setTarget(this);\n        }\n        return mShowAnimation;\n    }\n\n    private Animator getHideAnimation() {\n        if (mHideAnimation == null) {\n            mHideAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_out);\n            mHideAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    setVisibility(View.GONE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n            });\n            mHideAnimation.setTarget(this);\n        }\n        return mHideAnimation;\n    }\n\n    public boolean isEventInToastBar(MotionEvent event) {\n        if (!isShown()) {\n            return false;\n        }\n        int[] xy = new int[2];\n        float x = event.getX();\n        float y = event.getY();\n        getLocationOnScreen(xy);\n        return (x \u003e xy[0] \u0026\u0026 x \u003c (xy[0] + getWidth()) \u0026\u0026 y \u003e xy[1] \u0026\u0026 y \u003c xy[1] + getHeight());\n    }\n\n    /**\n     * Classes that wish to perform some action when the action button is clicked\n     * should implement this interface.\n     */\n    public interface ActionClickedListener {\n        public void onActionClicked();\n    }\n}","b":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.deskclock.widget;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorInflater;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.android.deskclock.R;\n\n/**\n * A custom {@link View} that exposes an action to the user.\n * \u003cp\u003e\n * This is a copy of packages/apps/UnifiedEmail/src/com/android/mail/ui/ActionableToastBar.java\n * with minor modifications.\n */\npublic class ActionableToastBar extends LinearLayout {\n    private boolean mHidden = false;\n    private Animator mShowAnimation;\n    private Animator mHideAnimation;\n    private final int mBottomMarginSizeInConversation;\n\n    /** Icon for the description. */\n    private ImageView mActionDescriptionIcon;\n    /** The clickable view */\n    private View mActionButton;\n    /** Icon for the action button. */\n    private ImageView mActionIcon;\n    /** The view that contains the description. */\n    private TextView mActionDescriptionView;\n    /** The view that contains the text for the action button. */\n    private TextView mActionText;\n    //private ToastBarOperation mOperation;\n\n    public ActionableToastBar(Context context) {\n        this(context, null);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mBottomMarginSizeInConversation = context.getResources().getDimensionPixelSize(\n                R.dimen.toast_bar_bottom_margin_in_conversation);\n        LayoutInflater.from(context).inflate(R.layout.actionable_toast_row, this, true);\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        mActionDescriptionIcon = (ImageView) findViewById(R.id.description_icon);\n        mActionDescriptionView = (TextView) findViewById(R.id.description_text);\n        mActionButton = findViewById(R.id.action_button);\n        mActionIcon = (ImageView)findViewById(R.id.action_icon);\n        mActionText = (TextView) findViewById(R.id.action_text);\n    }\n\n    /**\n     * Tells the view that it will be appearing in the conversation pane\n     * and should adjust its layout parameters accordingly.\n     * @param isInConversationMode true if the view will be shown in the conversation view\n     */\n    public void setConversationMode(boolean isInConversationMode) {\n        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams();\n        params.bottomMargin = isInConversationMode ? mBottomMarginSizeInConversation : 0;\n        setLayoutParams(params);\n    }\n\n    /**\n     * Displays the toast bar and makes it visible. Allows the setting of\n     * parameters to customize the display.\n     * @param listener performs some action when the action button is clicked\n     * @param descriptionIconResourceId resource ID for the description icon or\n     * 0 if no icon should be shown\n     * @param descriptionText a description text to show in the toast bar\n     * @param showActionIcon if true, the action button icon should be shown\n     * @param actionTextResource resource ID for the text to show in the action button\n     * @param replaceVisibleToast if true, this toast should replace any currently visible toast.\n     * Otherwise, skip showing this toast.\n     */\n    public void show(final ActionClickedListener listener, int descriptionIconResourceId,\n            CharSequence descriptionText, boolean showActionIcon, int actionIconResourceId,\n            int actionTextResource, boolean replaceVisibleToast) {\n\n        if (!mHidden \u0026\u0026 !replaceVisibleToast) {\n            return;\n        }\n\n        mActionButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View widget) {\n                if (listener != null) {\n                    listener.onActionClicked();\n                }\n                hide(true);\n            }\n        });\n\n        // Set description icon.\n        if (descriptionIconResourceId == 0) {\n            mActionDescriptionIcon.setVisibility(GONE);\n        } else {\n            mActionDescriptionIcon.setVisibility(VISIBLE);\n            mActionDescriptionIcon.setImageResource(descriptionIconResourceId);\n        }\n\n        // Set action icon\n        if (showActionIcon) {\n            mActionIcon.setVisibility(VISIBLE);\n            mActionIcon.setImageResource(actionIconResourceId == 0 ?\n                    R.drawable.ic_menu_revert_holo_dark : actionIconResourceId);\n        } else {\n            mActionIcon.setVisibility(GONE);\n        }\n\n        mActionDescriptionView.setText(descriptionText);\n        if (actionTextResource == 0) {\n            mActionText.setVisibility(GONE);\n        } else {\n            mActionText.setVisibility(VISIBLE);\n            mActionText.setText(actionTextResource);\n        }\n\n        mHidden = false;\n        getShowAnimation().start();\n    }\n\n    /**\n     * Hides the view and resets the state.\n     */\n    public void hide(boolean animate) {\n        // Prevent multiple call to hide.\n        // Also prevent hiding if show animation is going on.\n        if (!mHidden \u0026\u0026 !getShowAnimation().isRunning()) {\n            mHidden = true;\n            if (getVisibility() == View.VISIBLE) {\n                mActionDescriptionView.setText(\"\");\n                mActionButton.setOnClickListener(null);\n                // Hide view once it's clicked.\n                if (animate) {\n                    getHideAnimation().start();\n                } else {\n                    setAlpha(0);\n                    setVisibility(View.GONE);\n                }\n            }\n        }\n    }\n\n    private Animator getShowAnimation() {\n        if (mShowAnimation == null) {\n            mShowAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_in);\n            mShowAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    // There is a tiny change that and hide animation could have finished right\n                    // before the show animation finished.  In that case, the hide will mark the\n                    // view as GONE.  We need to make sure the last one wins.\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n            });\n            mShowAnimation.setTarget(this);\n        }\n        return mShowAnimation;\n    }\n\n    private Animator getHideAnimation() {\n        if (mHideAnimation == null) {\n            mHideAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_out);\n            mHideAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    setVisibility(View.GONE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n            });\n            mHideAnimation.setTarget(this);\n        }\n        return mHideAnimation;\n    }\n\n    public boolean isEventInToastBar(MotionEvent event) {\n        if (!isShown()) {\n            return false;\n        }\n        int[] xy = new int[2];\n        float x = event.getX();\n        float y = event.getY();\n        getLocationOnScreen(xy);\n        return (x \u003e xy[0] \u0026\u0026 x \u003c (xy[0] + getWidth()) \u0026\u0026 y \u003e xy[1] \u0026\u0026 y \u003c xy[1] + getHeight());\n    }\n\n    /**\n     * Classes that wish to perform some action when the action button is clicked\n     * should implement this interface.\n     */\n    public interface ActionClickedListener {\n        public void onActionClicked();\n    }\n}","comments":[],"name":"src/com/android/deskclock/widget/ActionableToastBar.java"}}},{"author":"Vladimir Vainer \u003cstr3l0k@gmail.com\u003e","committer":"Abhisek Devkota \u003cciwrl@cyanogenmod.com\u003e","message":"Alarm: Show a warning toast when alarm volume is set to silent\n\nChange-Id: I97edae55351101046def5058a2459ab88edf2d0d\n","parentCommit":"ef56f3e9c5b7767a0314385a335fe3d3e19451dc","revisionId":3,"subject":"Alarm: Show a warning toast when alarm volume is set to silent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     ef56f3e9 (Automatic translation import)\nAuthor:     Vladimir Vainer \u003cstr3l0k@gmail.com\u003e\nAuthorDate: 2014-05-11 18:36:09 +0300\nCommit:     Abhisek Devkota \u003cciwrl@cyanogenmod.com\u003e\nCommitDate: 2014-05-26 13:14:07 -0700\n\nAlarm: Show a warning toast when alarm volume is set to silent\n\nChange-Id: I97edae55351101046def5058a2459ab88edf2d0d","comments":[],"name":"/COMMIT_MSG"},"res/values/cm_strings.xml":{"a":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     Copyright (C) 2012-2014 The CyanogenMod Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n--\u003e\n\u003cresources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"\u003e\n    \u003c!-- Setting title for showing/hiding the alarm status bar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_title\"\u003eShow icon\u003c/string\u003e\n\n    \u003c!-- Setting summary for showing/hiding the alarm statusbar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_summary\"\u003eShow an icon in the status bar when an alarm is set\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Increasing volume on or off --\u003e\n    \u003cstring name=\"alarm_increasing_volume\"\u003eIncreasing volume\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Choose profile --\u003e\n    \u003cstring name=\"profile_description\"\u003eProfile \u003cxliff:g id=\"profile\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- No profile selected label --\u003e\n    \u003cstring name=\"profile_no_selected\"\u003eNo profile selected\u003c/string\u003e\n\n    \u003c!-- User-defined cities --\u003e\n    \u003cstring name=\"menu_item_add\"\u003eAdd\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_title\"\u003eAdd city\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_city\"\u003eCity:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_timezone\"\u003eTimezone:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_gps_cd\"\u003eTap to localize your current city\u003c/string\u003e\n    \u003cstring name=\"cities_add_loading\"\u003eLoading\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_searching\"\u003eSearching\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_no_results\"\u003eGPS query returns no location results\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_not_available\"\u003eGPS not available\u003c/string\u003e\n    \u003cstring name=\"cities_add_already_exists\"\u003eThe city already exists in the database\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_failed\"\u003eCan\\'t create the city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_title\"\u003eDelete city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_msg\"\u003eDo you want to delete \u003cxliff:g id=\"city\"\u003e%s\u003c/xliff:g\u003e?\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_failed\"\u003eCan\\'t delete the city\u003c/string\u003e\n\n    \u003c!-- Setting title for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_title\"\u003eFlip action\u003c/string\u003e\n\n    \u003c!-- Dialog title of the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"tablet\"\u003eFlip the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"default\"\u003eFlip the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"tablet\"\u003eFlipping the tablet down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"default\"\u003eFlipping the phone down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Setting title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_title\"\u003eShake action\u003c/string\u003e\n\n    \u003c!-- Dialog title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"tablet\"\u003eShake the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"default\"\u003eShake the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"tablet\"\u003eShaking the tablet will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"default\"\u003eShaking the phone will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Summary texts for shake and flip actions --\u003e\n    \u003cstring name=\"action_summary_snooze\"\u003esnooze alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_dismiss\"\u003edismiss alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_do_nothing\"\u003edo nothing\u003c/string\u003e\n\n    \u003c!-- Alarm picker dialog title --\u003e\n    \u003cstring name=\"alarm_picker_title\"\u003eChoose alarm type\u003c/string\u003e\n\n    \u003c!-- Alarm types --\u003e\n    \u003cstring name=\"alarm_type_ringtone\"\u003eRingtone\u003c/string\u003e\n    \u003cstring name=\"alarm_type_random\"\u003eRandomly\u003c/string\u003e\n\u003c/resources\u003e","b":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     Copyright (C) 2012-2014 The CyanogenMod Project\n\n     Licensed under the Apache License, Version 2.0 (the \"License\");\n     you may not use this file except in compliance with the License.\n     You may obtain a copy of the License at\n\n          http://www.apache.org/licenses/LICENSE-2.0\n\n     Unless required by applicable law or agreed to in writing, software\n     distributed under the License is distributed on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     See the License for the specific language governing permissions and\n     limitations under the License.\n--\u003e\n\u003cresources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\"\u003e\n    \u003c!-- Setting title for showing/hiding the alarm status bar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_title\"\u003eShow icon\u003c/string\u003e\n\n    \u003c!-- Setting summary for showing/hiding the alarm statusbar icon --\u003e\n    \u003cstring name=\"show_status_bar_icon_summary\"\u003eShow an icon in the status bar when an alarm is set\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Increasing volume on or off --\u003e\n    \u003cstring name=\"alarm_increasing_volume\"\u003eIncreasing volume\u003c/string\u003e\n\n    \u003c!-- Setting labels on Set alarm screen: Choose profile --\u003e\n    \u003cstring name=\"profile_description\"\u003eProfile \u003cxliff:g id=\"profile\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- No profile selected label --\u003e\n    \u003cstring name=\"profile_no_selected\"\u003eNo profile selected\u003c/string\u003e\n\n    \u003c!-- User-defined cities --\u003e\n    \u003cstring name=\"menu_item_add\"\u003eAdd\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_title\"\u003eAdd city\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_city\"\u003eCity:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_timezone\"\u003eTimezone:\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_gps_cd\"\u003eTap to localize your current city\u003c/string\u003e\n    \u003cstring name=\"cities_add_loading\"\u003eLoading\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_searching\"\u003eSearching\\u2026\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_no_results\"\u003eGPS query returns no location results\u003c/string\u003e\n    \u003cstring name=\"cities_add_gps_not_available\"\u003eGPS not available\u003c/string\u003e\n    \u003cstring name=\"cities_add_already_exists\"\u003eThe city already exists in the database\u003c/string\u003e\n    \u003cstring name=\"cities_add_city_failed\"\u003eCan\\'t create the city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_title\"\u003eDelete city\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_msg\"\u003eDo you want to delete \u003cxliff:g id=\"city\"\u003e%s\u003c/xliff:g\u003e?\u003c/string\u003e\n    \u003cstring name=\"cities_delete_city_failed\"\u003eCan\\'t delete the city\u003c/string\u003e\n\n    \u003c!-- Setting title for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_title\"\u003eFlip action\u003c/string\u003e\n\n    \u003c!-- Dialog title of the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"tablet\"\u003eFlip the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"flip_action_dialog_title\" product=\"default\"\u003eFlip the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the flip action setting. --\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"tablet\"\u003eFlipping the tablet down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"flip_action_summary\" product=\"default\"\u003eFlipping the phone down will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Setting title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_title\"\u003eShake action\u003c/string\u003e\n\n    \u003c!-- Dialog title for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"tablet\"\u003eShake the tablet to\\u2026\u003c/string\u003e\n    \u003cstring name=\"shake_action_dialog_title\" product=\"default\"\u003eShake the phone to\\u2026\u003c/string\u003e\n\n    \u003c!-- Setting summary for the shake action setting. --\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"tablet\"\u003eShaking the tablet will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n    \u003cstring name=\"shake_action_summary\" product=\"default\"\u003eShaking the phone will \u003cxliff:g id=\"action\"\u003e%s\u003c/xliff:g\u003e\u003c/string\u003e\n\n    \u003c!-- Summary texts for shake and flip actions --\u003e\n    \u003cstring name=\"action_summary_snooze\"\u003esnooze alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_dismiss\"\u003edismiss alarm\u003c/string\u003e\n    \u003cstring name=\"action_summary_do_nothing\"\u003edo nothing\u003c/string\u003e\n\n    \u003c!-- Alarm picker dialog title --\u003e\n    \u003cstring name=\"alarm_picker_title\"\u003eChoose alarm type\u003c/string\u003e\n\n    \u003c!-- Alarm types --\u003e\n    \u003cstring name=\"alarm_type_ringtone\"\u003eRingtone\u003c/string\u003e\n    \u003cstring name=\"alarm_type_random\"\u003eRandomly\u003c/string\u003e\n\n    \u003c!-- Warn Silent Alarm title --\u003e\n    \u003cstring name=\"warn_silent_alarm_title\"\u003eAlarm volume is silent\u003c/string\u003e\n\u003c/resources\u003e","comments":[],"name":"res/values/cm_strings.xml"},"src/com/android/deskclock/AlarmClockFragment.java":{"a":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.deskclock;\n\nimport android.animation.Animator;\nimport android.animation.Animator.AnimatorListener;\nimport android.animation.AnimatorInflater;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.FragmentTransaction;\nimport android.app.LoaderManager;\nimport android.app.Profile;\nimport android.app.ProfileManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.media.Ringtone;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.text.format.DateFormat;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.Interpolator;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CursorAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport com.android.datetimepicker.time.RadialPickerLayout;\nimport com.android.datetimepicker.time.TimePickerDialog;\nimport com.android.deskclock.alarms.AlarmStateManager;\nimport com.android.deskclock.provider.Alarm;\nimport com.android.deskclock.provider.AlarmInstance;\nimport com.android.deskclock.provider.DaysOfWeek;\nimport com.android.deskclock.widget.ActionableToastBar;\nimport com.android.deskclock.widget.TextTime;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * AlarmClock application.\n */\npublic class AlarmClockFragment extends DeskClockFragment implements\n        LoaderManager.LoaderCallbacks\u003cCursor\u003e,\n        TimePickerDialog.OnTimeSetListener,\n        View.OnTouchListener\n        {\n    private static final float EXPAND_DECELERATION = 1f;\n    private static final float COLLAPSE_DECELERATION = 0.7f;\n    private static final int ANIMATION_DURATION = 300;\n    private static final String KEY_EXPANDED_IDS = \"expandedIds\";\n    private static final String KEY_REPEAT_CHECKED_IDS = \"repeatCheckedIds\";\n    private static final String KEY_RINGTONE_TITLE_CACHE = \"ringtoneTitleCache\";\n    private static final String KEY_SELECTED_ALARMS = \"selectedAlarms\";\n    private static final String KEY_DELETED_ALARM = \"deletedAlarm\";\n    private static final String KEY_UNDO_SHOWING = \"undoShowing\";\n    private static final String KEY_PREVIOUS_DAY_MAP = \"previousDayMap\";\n    private static final String KEY_SELECTED_ALARM = \"selectedAlarm\";\n    private static final String KEY_DELETE_CONFIRMATION = \"deleteConfirmation\";\n\n    private static final int REQUEST_CODE_RINGTONE = 1;\n    private static final int REQUEST_CODE_PROFILE = 2;\n\n    // This extra is used when receiving an intent to create an alarm, but no alarm details\n    // have been passed in, so the alarm page should start the process of creating a new alarm.\n    public static final String ALARM_CREATE_NEW_INTENT_EXTRA = \"deskclock.create.new\";\n\n    // This extra is used when receiving an intent to scroll to specific alarm. If alarm\n    // can not be found, and toast message will pop up that the alarm has be deleted.\n    public static final String SCROLL_TO_ALARM_INTENT_EXTRA = \"deskclock.scroll.to.alarm\";\n\n    private ProfileManager mProfileManager;\n    private ProfilesObserver mProfileObserver;\n\n    private final Uri PROFILES_SETTINGS_URI =\n        Settings.System.getUriFor(Settings.System.SYSTEM_PROFILES_ENABLED);\n\n    private static final int MSG_PROFILE_STATUS_CHANGE = 1000;\n\n    private ListView mAlarmsList;\n    private AlarmItemAdapter mAdapter;\n    private View mEmptyView;\n    private ImageView mAddAlarmButton;\n    private View mAlarmsView;\n    private View mTimelineLayout;\n    private AlarmTimelineView mTimelineView;\n    private View mFooterView;\n\n    private Bundle mRingtoneTitleCache; // Key: ringtone uri, value: ringtone title\n    private ActionableToastBar mUndoBar;\n    private View mUndoFrame;\n\n    private Alarm mSelectedAlarm;\n    private long mScrollToAlarmId = -1;\n\n    private Loader mCursorLoader = null;\n\n    // Saved states for undo\n    private Alarm mDeletedAlarm;\n    private Alarm mAddedAlarm;\n    private boolean mUndoShowing = false;\n\n    private Animator mFadeIn;\n    private Animator mFadeOut;\n\n    private Interpolator mExpandInterpolator;\n    private Interpolator mCollapseInterpolator;\n\n    private int mTimelineViewWidth;\n    private int mUndoBarInitialMargin;\n\n    // Cached layout positions of items in listview prior to add/removal of alarm item\n    private ConcurrentHashMap\u003cLong, Integer\u003e mItemIdTopMap = new ConcurrentHashMap\u003cLong, Integer\u003e();\n\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case MSG_PROFILE_STATUS_CHANGE:\n                    updateProfilesStatus();\n                    break;\n            }\n        }\n    };\n\n    public AlarmClockFragment() {\n        // Basic provider required by Fragment.java\n    }\n\n    @Override\n    public void onCreate(Bundle savedState) {\n        super.onCreate(savedState);\n        mCursorLoader = getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedState) {\n        // Inflate the layout for this fragment\n        final View v = inflater.inflate(R.layout.alarm_clock, container, false);\n\n        long[] expandedIds = null;\n        long[] repeatCheckedIds = null;\n        long[] selectedAlarms = null;\n        Bundle previousDayMap = null;\n        if (savedState != null) {\n            expandedIds = savedState.getLongArray(KEY_EXPANDED_IDS);\n            repeatCheckedIds = savedState.getLongArray(KEY_REPEAT_CHECKED_IDS);\n            mRingtoneTitleCache = savedState.getBundle(KEY_RINGTONE_TITLE_CACHE);\n            mDeletedAlarm = savedState.getParcelable(KEY_DELETED_ALARM);\n            mUndoShowing = savedState.getBoolean(KEY_UNDO_SHOWING);\n            selectedAlarms = savedState.getLongArray(KEY_SELECTED_ALARMS);\n            previousDayMap = savedState.getBundle(KEY_PREVIOUS_DAY_MAP);\n            mSelectedAlarm = savedState.getParcelable(KEY_SELECTED_ALARM);\n        }\n\n        // Register profiles status\n        mProfileManager = (ProfileManager) getActivity().getSystemService(Context.PROFILE_SERVICE);\n        mProfileObserver = new ProfilesObserver(mHandler);\n\n        mExpandInterpolator = new DecelerateInterpolator(EXPAND_DECELERATION);\n        mCollapseInterpolator = new DecelerateInterpolator(COLLAPSE_DECELERATION);\n\n        mAddAlarmButton = (ImageButton) v.findViewById(R.id.alarm_add_alarm);\n        mAddAlarmButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                hideUndoBar(true, null);\n                startCreatingAlarm();\n            }\n        });\n        // For landscape, put the add button on the right and the menu in the actionbar.\n        FrameLayout.LayoutParams layoutParams =\n                (FrameLayout.LayoutParams) mAddAlarmButton.getLayoutParams();\n        boolean isLandscape = getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n        if (isLandscape) {\n            layoutParams.gravity = Gravity.END;\n        } else {\n            layoutParams.gravity = Gravity.CENTER;\n        }\n        mAddAlarmButton.setLayoutParams(layoutParams);\n\n        View menuButton = v.findViewById(R.id.menu_button);\n        if (menuButton != null) {\n            if (isLandscape) {\n                menuButton.setVisibility(View.GONE);\n            } else {\n                menuButton.setVisibility(View.VISIBLE);\n                setupFakeOverflowMenuButton(menuButton);\n            }\n        }\n\n        mEmptyView = v.findViewById(R.id.alarms_empty_view);\n        mEmptyView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startCreatingAlarm();\n            }\n        });\n        mAlarmsList = (ListView) v.findViewById(R.id.alarms_list);\n\n        mFadeIn = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_in);\n        mFadeIn.setDuration(ANIMATION_DURATION);\n        mFadeIn.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator animation) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animation) {\n                // Do nothing.\n            }\n        });\n        mFadeIn.setTarget(mEmptyView);\n        mFadeOut = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_out);\n        mFadeOut.setDuration(ANIMATION_DURATION);\n        mFadeOut.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator arg0) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator arg0) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator arg0) {\n                mEmptyView.setVisibility(View.GONE);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator arg0) {\n                // Do nothing.\n            }\n        });\n        mFadeOut.setTarget(mEmptyView);\n        mAlarmsView = v.findViewById(R.id.alarm_layout);\n        mTimelineLayout = v.findViewById(R.id.timeline_layout);\n\n        mUndoBar = (ActionableToastBar) v.findViewById(R.id.undo_bar);\n        mUndoBarInitialMargin = getActivity().getResources()\n                .getDimensionPixelOffset(R.dimen.alarm_undo_bar_horizontal_margin);\n        mUndoFrame = v.findViewById(R.id.undo_frame);\n        mUndoFrame.setOnTouchListener(this);\n\n        mFooterView = v.findViewById(R.id.alarms_footer_view);\n        mFooterView.setOnTouchListener(this);\n\n        // Timeline layout only exists in tablet landscape mode for now.\n        if (mTimelineLayout != null) {\n            mTimelineView = (AlarmTimelineView) v.findViewById(R.id.alarm_timeline_view);\n            mTimelineViewWidth = getActivity().getResources()\n                    .getDimensionPixelOffset(R.dimen.alarm_timeline_layout_width);\n        }\n\n        mAdapter = new AlarmItemAdapter(getActivity(),\n                expandedIds, repeatCheckedIds, selectedAlarms, previousDayMap, mAlarmsList);\n        mAdapter.registerDataSetObserver(new DataSetObserver() {\n\n            private int prevAdapterCount = -1;\n\n            @Override\n            public void onChanged() {\n\n                final int count = mAdapter.getCount();\n                if (mDeletedAlarm != null \u0026\u0026 prevAdapterCount \u003e count) {\n                    showUndoBar();\n                }\n\n                // If there are no alarms in the adapter...\n                if (count == 0) {\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_red);\n\n                    // ...and if there exists a timeline view (currently only in tablet landscape)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        // ...and if the previous adapter had alarms (indicating a removal)...\n                        if (prevAdapterCount \u003e 0) {\n\n                            // Then animate in the \"no alarms\" icon...\n                            mFadeIn.start();\n\n                            // and animate out the alarm timeline view, expanding the width of the\n                            // alarms list / undo bar.\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mCollapseInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.addListener(new AnimatorListener() {\n\n                                @Override\n                                public void onAnimationCancel(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(false);\n                                }\n\n                                @Override\n                                public void onAnimationRepeat(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationStart(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(true);\n                                }\n\n                            });\n                            animator.start();\n                        } else {\n                            // If the previous adapter did not have alarms, no animation needed,\n                            // just hide the timeline view and show the \"no alarms\" icon.\n                            mTimelineLayout.setVisibility(View.GONE);\n                            mEmptyView.setVisibility(View.VISIBLE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just show the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.VISIBLE);\n                    }\n                } else {\n\n                    // Otherwise, if the adapter DOES contain alarms...\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_normal);\n\n                    // ...and if there exists a timeline view (currently in tablet landscape mode)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        mTimelineLayout.setVisibility(View.VISIBLE);\n                        // ...and if the previous adapter did not have alarms (indicating an add)\n                        if (prevAdapterCount == 0) {\n\n                            // Then, animate to hide the \"no alarms\" icon...\n                            mFadeOut.start();\n\n                            // and animate to show the timeline view, reducing the width of the\n                            // alarms list / undo bar.\n                            ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mExpandInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    ((FrameLayout.LayoutParams) mAlarmsView.getLayoutParams())\n                                        .setMargins(0, 0, (int) -rightOffset, 0);\n                                    mAlarmsView.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.start();\n                        } else {\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            mEmptyView.setVisibility(View.GONE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin + mTimelineViewWidth);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just hide the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.GONE);\n                    }\n                }\n\n                // Cache this adapter's count for when the adapter changes.\n                prevAdapterCount = count;\n                super.onChanged();\n            }\n        });\n\n        if (mRingtoneTitleCache == null) {\n            mRingtoneTitleCache = new Bundle();\n        }\n\n        mAlarmsList.setAdapter(mAdapter);\n        mAlarmsList.setVerticalScrollBarEnabled(true);\n        mAlarmsList.setOnCreateContextMenuListener(this);\n\n        if (mUndoShowing) {\n            showUndoBar();\n        }\n        return v;\n    }\n\n    private void setUndoBarRightMargin(int margin) {\n        FrameLayout.LayoutParams params =\n                (FrameLayout.LayoutParams) mUndoBar.getLayoutParams();\n        ((FrameLayout.LayoutParams) mUndoBar.getLayoutParams())\n            .setMargins(params.leftMargin, params.topMargin, margin, params.bottomMargin);\n        mUndoBar.requestLayout();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Check if another app asked us to create a blank new alarm.\n        final Intent intent = getActivity().getIntent();\n        if (intent.hasExtra(ALARM_CREATE_NEW_INTENT_EXTRA)) {\n            if (intent.getBooleanExtra(ALARM_CREATE_NEW_INTENT_EXTRA, false)) {\n                // An external app asked us to create a blank alarm.\n                startCreatingAlarm();\n            }\n\n            // Remove the CREATE_NEW extra now that we've processed it.\n            intent.removeExtra(ALARM_CREATE_NEW_INTENT_EXTRA);\n        } else if (intent.hasExtra(SCROLL_TO_ALARM_INTENT_EXTRA)) {\n            long alarmId = intent.getLongExtra(SCROLL_TO_ALARM_INTENT_EXTRA, Alarm.INVALID_ID);\n            if (alarmId != Alarm.INVALID_ID) {\n                mScrollToAlarmId = alarmId;\n                if (mCursorLoader != null \u0026\u0026 mCursorLoader.isStarted()) {\n                    // We need to force a reload here to make sure we have the latest view\n                    // of the data to scroll to.\n                    mCursorLoader.forceLoad();\n                }\n            }\n\n            // Remove the SCROLL_TO_ALARM extra now that we've processed it.\n            intent.removeExtra(SCROLL_TO_ALARM_INTENT_EXTRA);\n        }\n\n        // Make sure to use the child FragmentManager. We have to use that one for the\n        // case where an intent comes in telling the activity to load the timepicker,\n        // which means we have to use that one everywhere so that the fragment can get\n        // correctly picked up here if it's open.\n        TimePickerDialog tpd = (TimePickerDialog) getChildFragmentManager().\n                findFragmentByTag(AlarmUtils.FRAG_TAG_TIME_PICKER);\n        if (tpd != null) {\n            // The dialog is already open so we need to set the listener again.\n            tpd.setOnTimeSetListener(this);\n        }\n\n        // Update the profile status and register the profile observer\n        getActivity().getContentResolver().registerContentObserver(\n                PROFILES_SETTINGS_URI, false, mProfileObserver);\n        updateProfilesStatus();\n    }\n\n    private void hideUndoBar(boolean animate, MotionEvent event) {\n        if (mUndoBar != null) {\n            mUndoFrame.setVisibility(View.GONE);\n            if (event != null \u0026\u0026 mUndoBar.isEventInToastBar(event)) {\n                // Avoid touches inside the undo bar.\n                return;\n            }\n            mUndoBar.hide(animate);\n        }\n        mDeletedAlarm = null;\n        mUndoShowing = false;\n    }\n\n    private void showUndoBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                asyncAddAlarm(mDeletedAlarm);\n                mDeletedAlarm = null;\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.alarm_deleted), true, R.string.alarm_undo, true);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLongArray(KEY_EXPANDED_IDS, mAdapter.getExpandedArray());\n        outState.putLongArray(KEY_REPEAT_CHECKED_IDS, mAdapter.getRepeatArray());\n        outState.putLongArray(KEY_SELECTED_ALARMS, mAdapter.getSelectedAlarmsArray());\n        outState.putBundle(KEY_RINGTONE_TITLE_CACHE, mRingtoneTitleCache);\n        outState.putParcelable(KEY_DELETED_ALARM, mDeletedAlarm);\n        outState.putBoolean(KEY_UNDO_SHOWING, mUndoShowing);\n        outState.putBundle(KEY_PREVIOUS_DAY_MAP, mAdapter.getPreviousDaysOfWeekMap());\n        outState.putParcelable(KEY_SELECTED_ALARM, mSelectedAlarm);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        ToastMaster.cancelToast();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        // When the user places the app in the background by pressing \"home\",\n        // dismiss the toast bar. However, since there is no way to determine if\n        // home was pressed, just dismiss any existing toast bar when restarting\n        // the app.\n        hideUndoBar(false, null);\n\n        // Unregister the profile observer\n        getActivity().getContentResolver().unregisterContentObserver(mProfileObserver);\n    }\n\n    // Callback used by TimePickerDialog\n    @Override\n    public void onTimeSet(RadialPickerLayout view, int hourOfDay, int minute) {\n        if (mSelectedAlarm == null) {\n            // If mSelectedAlarm is null then we're creating a new alarm.\n            Alarm a = new Alarm();\n            a.alert = RingtoneManager.getActualDefaultRingtoneUri(getActivity(),\n                    RingtoneManager.TYPE_ALARM);\n            if (a.alert == null) {\n                a.alert = Uri.parse(\"content://settings/system/alarm_alert\");\n            }\n            a.hour = hourOfDay;\n            a.minutes = minute;\n            a.enabled = true;\n            asyncAddAlarm(a);\n        } else {\n            mSelectedAlarm.hour = hourOfDay;\n            mSelectedAlarm.minutes = minute;\n            mSelectedAlarm.enabled = true;\n            mScrollToAlarmId = mSelectedAlarm.id;\n            asyncUpdateAlarm(mSelectedAlarm, true);\n            mSelectedAlarm = null;\n        }\n    }\n\n    private void showLabelDialog(final Alarm alarm) {\n        final FragmentTransaction ft = getFragmentManager().beginTransaction();\n        final Fragment prev = getFragmentManager().findFragmentByTag(\"label_dialog\");\n        if (prev != null) {\n            ft.remove(prev);\n        }\n        ft.addToBackStack(null);\n\n        // Create and show the dialog.\n        final LabelDialogFragment newFragment =\n                LabelDialogFragment.newInstance(alarm, alarm.label, getTag());\n        newFragment.show(ft, \"label_dialog\");\n    }\n\n    public void setLabel(Alarm alarm, String label) {\n        alarm.label = label;\n        asyncUpdateAlarm(alarm, false);\n    }\n\n    @Override\n    public Loader\u003cCursor\u003e onCreateLoader(int id, Bundle args) {\n        return Alarm.getAlarmsCursorLoader(getActivity());\n    }\n\n    @Override\n    public void onLoadFinished(Loader\u003cCursor\u003e cursorLoader, final Cursor data) {\n        mAdapter.swapCursor(data);\n        if (mScrollToAlarmId != -1) {\n            scrollToAlarm(mScrollToAlarmId);\n            mScrollToAlarmId = -1;\n        }\n    }\n\n    /**\n     * Scroll to alarm with given alarm id.\n     *\n     * @param alarmId The alarm id to scroll to.\n     */\n    private void scrollToAlarm(long alarmId) {\n        int alarmPosition = -1;\n        for (int i = 0; i \u003c mAdapter.getCount(); i++) {\n            long id = mAdapter.getItemId(i);\n            if (id == alarmId) {\n                alarmPosition = i;\n                break;\n            }\n        }\n\n        if (alarmPosition \u003e= 0) {\n            mAdapter.setNewAlarm(alarmId);\n            mAlarmsList.smoothScrollToPositionFromTop(alarmPosition, 0);\n        } else {\n            // Trying to display a deleted alarm should only happen from a missed notification for\n            // an alarm that has been marked deleted after use.\n            Context context = getActivity().getApplicationContext();\n            Toast toast = Toast.makeText(context, R.string.missed_alarm_has_been_deleted,\n                    Toast.LENGTH_LONG);\n            ToastMaster.setToast(toast);\n            toast.show();\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader\u003cCursor\u003e cursorLoader) {\n        mAdapter.swapCursor(null);\n    }\n\n    private void launchRingTonePicker(final Alarm alarm) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.alarm_picker_title).setItems(\n                R.array.ringtone_picker_entries,\n\n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        switch (which) {\n                            case 0:\n                                launchSingleRingTonePicker(alarm);\n                                break;\n                            case 1:\n                                alarm.alert = MultiPlayer.RANDOM_URI;\n                                asyncUpdateAlarm(alarm, false);\n                                break;\n                        }\n                    }\n                });\n        AlertDialog d = builder.create();\n        d.show();\n    }\n\n    private void launchSingleRingTonePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;\n        final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, oldRingtone);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, false);\n        startActivityForResult(intent, REQUEST_CODE_RINGTONE);\n    }\n\n    private void launchProfilePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        final Intent intent = new Intent(ProfileManager.ACTION_PROFILE_PICKER);\n\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_EXISTING_UUID, alarm.profile.toString());\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_SHOW_NONE, true);\n        startActivityForResult(intent, REQUEST_CODE_PROFILE);\n    }\n\n    private void saveRingtoneUri(Intent intent) {\n        Uri uri = intent.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);\n        if (uri == null) {\n            uri = Alarm.NO_RINGTONE_URI;\n        }\n        mSelectedAlarm.alert = uri;\n\n        // Save the last selected ringtone as the default for new alarms\n        if (!Alarm.NO_RINGTONE_URI.equals(uri)) {\n            RingtoneManager.setActualDefaultRingtoneUri(\n                    getActivity(), RingtoneManager.TYPE_ALARM, uri);\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private void saveProfile(Intent intent) {\n        final String uuid = intent.getStringExtra(ProfileManager.EXTRA_PROFILE_PICKED_UUID);\n        if (uuid != null) {\n            try {\n                mSelectedAlarm.profile = UUID.fromString(uuid);\n            } catch (IllegalArgumentException ex) {\n                mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n            }\n        } else {\n            mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private boolean isProfilesEnabled() {\n        return Settings.System.getInt(getActivity().getContentResolver(),\n                Settings.System.SYSTEM_PROFILES_ENABLED, 1) == 1;\n    }\n\n    private String getProfileName(Alarm alarm) {\n        if (!isProfilesEnabled() || alarm.profile.equals(ProfileManager.NO_PROFILE)) {\n            return getString(R.string.profile_no_selected);\n        }\n        Profile profile = mProfileManager.getProfile(alarm.profile);\n        if (profile == null) {\n            return getString(R.string.profile_no_selected);\n        }\n        return profile.getName();\n    }\n\n    private void updateProfilesStatus() {\n        // Need to refresh the data\n        if (mAdapter != null) {\n            mAdapter.notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == Activity.RESULT_OK) {\n            switch (requestCode) {\n                case REQUEST_CODE_RINGTONE:\n                    saveRingtoneUri(data);\n                    break;\n                case REQUEST_CODE_PROFILE:\n                    saveProfile(data);\n                default:\n                    Log.w(\"Unhandled request code in onActivityResult: \" + requestCode);\n            }\n        }\n    }\n\n    private class ProfilesObserver extends ContentObserver {\n        public ProfilesObserver(Handler handler) {\n            super(handler);\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n            onChange(selfChange, null);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            if (uri == null) return;\n            if (PROFILES_SETTINGS_URI.equals(uri)) {\n                mHandler.removeMessages(MSG_PROFILE_STATUS_CHANGE);\n                mHandler.sendEmptyMessage(MSG_PROFILE_STATUS_CHANGE);\n            }\n        }\n    }\n\n    public class AlarmItemAdapter extends CursorAdapter {\n        private static final int EXPAND_DURATION = 300;\n        private static final int COLLAPSE_DURATION = 250;\n\n        private final Context mContext;\n        private final LayoutInflater mFactory;\n        private final String[] mShortWeekDayStrings;\n        private final String[] mLongWeekDayStrings;\n        private final int mColorLit;\n        private final int mColorDim;\n        private final int mBackgroundColorExpanded;\n        private final int mBackgroundColor;\n        private final Typeface mRobotoNormal;\n        private final Typeface mRobotoBold;\n        private final ListView mList;\n\n        private final HashSet\u003cLong\u003e mExpanded = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mRepeatChecked = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mSelectedAlarms = new HashSet\u003cLong\u003e();\n        private Bundle mPreviousDaysOfWeekMap = new Bundle();\n\n        private final boolean mHasVibrator;\n        private final int mCollapseExpandHeight;\n\n        // This determines the order in which it is shown and processed in the UI.\n        // The array is filled when the adapter is created\n        private final int[] DAY_ORDER = new int[7];\n\n        public class ItemHolder {\n\n            // views for optimization\n            LinearLayout alarmItem;\n            TextTime clock;\n            Switch onoff;\n            TextView daysOfWeek;\n            TextView label;\n            ImageView delete;\n            View expandArea;\n            View summary;\n            TextView clickableLabel;\n            CheckBox repeat;\n            LinearLayout repeatDays;\n            ViewGroup[] dayButtonParents = new ViewGroup[7];\n            ToggleButton[] dayButtons = new ToggleButton[7];\n            CheckBox vibrate;\n            CheckBox increasingVolume;\n            TextView ringtone;\n            TextView profile;\n            View hairLine;\n            View arrow;\n            View collapseExpandArea;\n            View footerFiller;\n\n            // Other states\n            Alarm alarm;\n        }\n\n        // Used for scrolling an expanded item in the list to make sure it is fully visible.\n        private long mScrollAlarmId = -1;\n        private final Runnable mScrollRunnable = new Runnable() {\n            @Override\n            public void run() {\n                if (mScrollAlarmId != -1) {\n                    View v = getViewById(mScrollAlarmId);\n                    if (v != null) {\n                        Rect rect = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n                        mList.requestChildRectangleOnScreen(v, rect, false);\n                    }\n                    mScrollAlarmId = -1;\n                }\n            }\n        };\n\n        public AlarmItemAdapter(Context context, long[] expandedIds, long[] repeatCheckedIds,\n                long[] selectedAlarms, Bundle previousDaysOfWeekMap, ListView list) {\n            super(context, null, 0);\n            mContext = context;\n            mFactory = LayoutInflater.from(context);\n            mList = list;\n\n            DateFormatSymbols dfs = new DateFormatSymbols();\n            mShortWeekDayStrings = dfs.getShortWeekdays();\n            mLongWeekDayStrings = dfs.getWeekdays();\n            int firstDayOfWeek = Calendar.getInstance(Locale.getDefault()).getFirstDayOfWeek();\n            int j = 0;\n            for (int i = firstDayOfWeek; i \u003c= DAY_ORDER.length; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n            for (int i = Calendar.SUNDAY; i \u003c firstDayOfWeek; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n\n            Resources res = mContext.getResources();\n            mColorLit = res.getColor(R.color.clock_white);\n            mColorDim = res.getColor(R.color.clock_gray);\n            mBackgroundColorExpanded = res.getColor(R.color.alarm_whiteish);\n            mBackgroundColor = R.drawable.alarm_background_normal;\n\n            mRobotoBold = Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\n            mRobotoNormal = Typeface.create(\"sans-serif-condensed\", Typeface.NORMAL);\n\n            if (expandedIds != null) {\n                buildHashSetFromArray(expandedIds, mExpanded);\n            }\n            if (repeatCheckedIds != null) {\n                buildHashSetFromArray(repeatCheckedIds, mRepeatChecked);\n            }\n            if (previousDaysOfWeekMap != null) {\n                mPreviousDaysOfWeekMap = previousDaysOfWeekMap;\n            }\n            if (selectedAlarms != null) {\n                buildHashSetFromArray(selectedAlarms, mSelectedAlarms);\n            }\n\n            mHasVibrator = ((Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE))\n                    .hasVibrator();\n\n            mCollapseExpandHeight = (int) res.getDimension(R.dimen.collapse_expand_height);\n        }\n\n        public void removeSelectedId(int id) {\n            mSelectedAlarms.remove(id);\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (!getCursor().moveToPosition(position)) {\n                // May happen if the last alarm was deleted and the cursor refreshed while the\n                // list is updated.\n                Log.v(\"couldn't move cursor to position \" + position);\n                return null;\n            }\n            View v;\n            if (convertView == null) {\n                v = newView(mContext, getCursor(), parent);\n            } else {\n                // TODO temporary hack to prevent the convertView from not having stuff we need.\n                boolean badConvertView = convertView.findViewById(R.id.digital_clock) == null;\n                // Do a translation check to test for animation. Change this to something more\n                // reliable and robust in the future.\n                if (convertView.getTranslationX() != 0 || convertView.getTranslationY() != 0 ||\n                        badConvertView) {\n                    // view was animated, reset\n                    v = newView(mContext, getCursor(), parent);\n                } else {\n                    v = convertView;\n                }\n            }\n            bindView(v, mContext, getCursor());\n            ItemHolder holder = (ItemHolder) v.getTag();\n\n            // We need the footer for the last element of the array to allow the user to scroll\n            // the item beyond the bottom button bar, which obscures the view.\n            holder.footerFiller.setVisibility(position \u003c getCount() - 1 ? View.GONE : View.VISIBLE);\n            return v;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            final View view = mFactory.inflate(R.layout.alarm_time, parent, false);\n            setNewHolder(view);\n            return view;\n        }\n\n        /**\n         * In addition to changing the data set for the alarm list, swapCursor is now also\n         * responsible for preparing the list view's pre-draw operation for any animations that\n         * need to occur if an alarm was removed or added.\n         */\n        @Override\n        public synchronized Cursor swapCursor(Cursor cursor) {\n            Cursor c = super.swapCursor(cursor);\n\n            if (mItemIdTopMap.isEmpty() \u0026\u0026 mAddedAlarm == null) {\n                return c;\n            }\n\n            final ListView list = mAlarmsList;\n            final ViewTreeObserver observer = list.getViewTreeObserver();\n\n            /*\n             * Add a pre-draw listener to the observer to prepare for any possible animations to\n             * the alarms within the list view.  The animations will occur if an alarm has been\n             * removed or added.\n             *\n             * For alarm removal, the remaining children should all retain their initial starting\n             * positions, and transition to their new positions.\n             *\n             * For alarm addition, the other children should all retain their initial starting\n             * positions, transition to their new positions, and at the end of that transition, the\n             * newly added alarm should appear in the designated space.\n             */\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n\n                private View mAddedView;\n\n                @Override\n                public boolean onPreDraw() {\n                    // Remove the pre-draw listener, as this only needs to occur once.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    boolean firstAnimation = true;\n                    int firstVisiblePosition = list.getFirstVisiblePosition();\n\n                    // Iterate through the children to prepare the add/remove animation.\n                    for (int i = 0; i\u003c list.getChildCount(); i++) {\n                        final View child = list.getChildAt(i);\n\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n\n                        // If this is the added alarm, set it invisible for now, and animate later.\n                        if (mAddedAlarm != null \u0026\u0026 itemId == mAddedAlarm.id) {\n                            mAddedView = child;\n                            mAddedView.setAlpha(0.0f);\n                            continue;\n                        }\n\n                        // The cached starting position of the child view.\n                        Integer startTop = mItemIdTopMap.get(itemId);\n                        // The new starting position of the child view.\n                        int top = child.getTop();\n\n                        // If there is no cached starting position, determine whether the item has\n                        // come from the top of bottom of the list view.\n                        if (startTop == null) {\n                            int childHeight = child.getHeight() + list.getDividerHeight();\n                            startTop = top + (i \u003e 0 ? childHeight : -childHeight);\n                        }\n\n                        Log.d(\"Start Top: \" + startTop + \", Top: \" + top);\n                        // If the starting position of the child view is different from the\n                        // current position, animate the child.\n                        if (startTop != top) {\n                            int delta = startTop - top;\n                            child.setTranslationY(delta);\n                            child.animate().setDuration(ANIMATION_DURATION).translationY(0);\n                            final View addedView = mAddedView;\n                            if (firstAnimation) {\n\n                                // If this is the first child being animated, then after the\n                                // animation is complete, and animate in the added alarm (if one\n                                // exists).\n                                child.animate().withEndAction(new Runnable() {\n\n                                    @Override\n                                    public void run() {\n\n\n                                        // If there was an added view, animate it in after\n                                        // the other views have animated.\n                                        if (addedView != null) {\n                                            addedView.animate().alpha(1.0f)\n                                                .setDuration(ANIMATION_DURATION)\n                                                .withEndAction(new Runnable() {\n\n                                                    @Override\n                                                    public void run() {\n                                                        // Re-enable the list after the add\n                                                        // animation is complete.\n                                                        list.setEnabled(true);\n                                                    }\n\n                                                });\n                                        } else {\n                                            // Re-enable the list after animations are complete.\n                                            list.setEnabled(true);\n                                        }\n                                    }\n\n                                });\n                                firstAnimation = false;\n                            }\n                        }\n                    }\n\n                    // If there were no child views (outside of a possible added view)\n                    // that require animation...\n                    if (firstAnimation) {\n                        if (mAddedView != null) {\n                            // If there is an added view, prepare animation for the added view.\n                            Log.d(\"Animating added view...\");\n                            mAddedView.animate().alpha(1.0f)\n                                .setDuration(ANIMATION_DURATION)\n                                .withEndAction(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        // Re-enable the list after animations are complete.\n                                        list.setEnabled(true);\n                                    }\n                                });\n                        } else {\n                            // Re-enable the list after animations are complete.\n                            list.setEnabled(true);\n                        }\n                    }\n\n                    mAddedAlarm = null;\n                    mItemIdTopMap.clear();\n                    return true;\n                }\n            });\n            return c;\n        }\n\n        private void setNewHolder(View view) {\n            // standard view holder optimization\n            final ItemHolder holder = new ItemHolder();\n            holder.alarmItem = (LinearLayout) view.findViewById(R.id.alarm_item);\n            holder.clock = (TextTime) view.findViewById(R.id.digital_clock);\n            holder.onoff = (Switch) view.findViewById(R.id.onoff);\n            holder.onoff.setTypeface(mRobotoNormal);\n            holder.daysOfWeek = (TextView) view.findViewById(R.id.daysOfWeek);\n            holder.label = (TextView) view.findViewById(R.id.label);\n            holder.delete = (ImageView) view.findViewById(R.id.delete);\n            holder.summary = view.findViewById(R.id.summary);\n            holder.expandArea = view.findViewById(R.id.expand_area);\n            holder.hairLine = view.findViewById(R.id.hairline);\n            holder.arrow = view.findViewById(R.id.arrow);\n            holder.repeat = (CheckBox) view.findViewById(R.id.repeat_onoff);\n            holder.clickableLabel = (TextView) view.findViewById(R.id.edit_label);\n            holder.repeatDays = (LinearLayout) view.findViewById(R.id.repeat_days);\n            holder.collapseExpandArea = view.findViewById(R.id.collapse_expand);\n            holder.footerFiller = view.findViewById(R.id.alarm_footer_filler);\n            holder.footerFiller.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // Do nothing.\n                }\n            });\n\n            // Build button for each day.\n            for (int i = 0; i \u003c 7; i++) {\n                final ViewGroup viewgroup = (ViewGroup) mFactory.inflate(R.layout.day_button,\n                        holder.repeatDays, false);\n                final ToggleButton button = (ToggleButton) viewgroup.getChildAt(0);\n                final int dayToShowIndex = DAY_ORDER[i];\n                button.setText(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOn(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOff(mShortWeekDayStrings[dayToShowIndex]);\n                button.setContentDescription(mLongWeekDayStrings[dayToShowIndex]);\n                holder.repeatDays.addView(viewgroup);\n                holder.dayButtons[i] = button;\n                holder.dayButtonParents[i] = viewgroup;\n            }\n            holder.vibrate = (CheckBox) view.findViewById(R.id.vibrate_onoff);\n            holder.increasingVolume = (CheckBox) view.findViewById(R.id.increasing_volume_onoff);\n            holder.ringtone = (TextView) view.findViewById(R.id.choose_ringtone);\n            holder.profile = (TextView) view.findViewById(R.id.choose_profile);\n\n            view.setTag(holder);\n        }\n\n        @Override\n        public void bindView(final View view, Context context, final Cursor cursor) {\n            final Alarm alarm = new Alarm(cursor);\n            Object tag = view.getTag();\n            if (tag == null) {\n                // The view was converted but somehow lost its tag.\n                setNewHolder(view);\n            }\n            final ItemHolder itemHolder = (ItemHolder) tag;\n            itemHolder.alarm = alarm;\n\n            // We must unset the listener first because this maybe a recycled view so changing the\n            // state would affect the wrong alarm.\n            itemHolder.onoff.setOnCheckedChangeListener(null);\n            itemHolder.onoff.setChecked(alarm.enabled);\n\n            if (mSelectedAlarms.contains(itemHolder.alarm.id)) {\n                itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n                setItemAlpha(itemHolder, true);\n                itemHolder.onoff.setEnabled(false);\n            } else {\n                itemHolder.onoff.setEnabled(true);\n                itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n                setItemAlpha(itemHolder, itemHolder.onoff.isChecked());\n            }\n            itemHolder.clock.setFormat(\n                    (int)mContext.getResources().getDimension(R.dimen.alarm_label_size));\n            itemHolder.clock.setTime(alarm.hour, alarm.minutes);\n            itemHolder.clock.setClickable(true);\n            itemHolder.clock.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    mSelectedAlarm = itemHolder.alarm;\n                    AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                            alarm, AlarmClockFragment.this\n                            , DateFormat.is24HourFormat(getActivity()));\n                    expandAlarm(itemHolder, true);\n                    itemHolder.alarmItem.post(mScrollRunnable);\n                }\n            });\n\n            final CompoundButton.OnCheckedChangeListener onOffListener =\n                    new CompoundButton.OnCheckedChangeListener() {\n                        @Override\n                        public void onCheckedChanged(CompoundButton compoundButton,\n                                boolean checked) {\n                            if (checked != alarm.enabled) {\n                                setItemAlpha(itemHolder, checked);\n                                alarm.enabled = checked;\n                                asyncUpdateAlarm(alarm, alarm.enabled);\n                            }\n                        }\n                    };\n\n            itemHolder.onoff.setOnCheckedChangeListener(onOffListener);\n\n            boolean expanded = isAlarmExpanded(alarm);\n            itemHolder.expandArea.setVisibility(expanded? View.VISIBLE : View.GONE);\n            itemHolder.summary.setVisibility(expanded? View.GONE : View.VISIBLE);\n\n            String labelSpace = \"\";\n            // Set the repeat text or leave it blank if it does not repeat.\n            final String daysOfWeekStr =\n                    alarm.daysOfWeek.toString(AlarmClockFragment.this.getActivity(), false);\n            if (daysOfWeekStr != null \u0026\u0026 daysOfWeekStr.length() != 0) {\n                itemHolder.daysOfWeek.setText(daysOfWeekStr);\n                itemHolder.daysOfWeek.setContentDescription(alarm.daysOfWeek.toAccessibilityString(\n                        AlarmClockFragment.this.getActivity()));\n                itemHolder.daysOfWeek.setVisibility(View.VISIBLE);\n                labelSpace = \"  \";\n                itemHolder.daysOfWeek.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n\n            } else {\n                itemHolder.daysOfWeek.setVisibility(View.GONE);\n            }\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() != 0) {\n                itemHolder.label.setText(alarm.label + labelSpace);\n                itemHolder.label.setVisibility(View.VISIBLE);\n                itemHolder.label.setContentDescription(\n                        mContext.getResources().getString(R.string.label_description) + \" \"\n                        + alarm.label);\n                itemHolder.label.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n            } else {\n                itemHolder.label.setVisibility(View.GONE);\n            }\n\n            itemHolder.delete.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    mDeletedAlarm = alarm;\n\n                    view.animate().setDuration(ANIMATION_DURATION).alpha(0).translationY(-1)\n                    .withEndAction(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            asyncDeleteAlarm(mDeletedAlarm, view);\n                        }\n                    });\n                }\n            });\n\n            if (expanded) {\n                expandAlarm(itemHolder, false);\n            } else {\n                collapseAlarm(itemHolder, false);\n            }\n\n            itemHolder.alarmItem.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    if (isAlarmExpanded(alarm)) {\n                        collapseAlarm(itemHolder, true);\n                    } else {\n                        expandAlarm(itemHolder, true);\n                    }\n                }\n            });\n\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n        }\n\n        private void bindExpandArea(final ItemHolder itemHolder, final Alarm alarm) {\n            // Views in here are not bound until the item is expanded.\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() \u003e 0) {\n                itemHolder.clickableLabel.setText(alarm.label);\n                itemHolder.clickableLabel.setTextColor(mColorLit);\n            } else {\n                itemHolder.clickableLabel.setText(R.string.label);\n                itemHolder.clickableLabel.setTextColor(mColorDim);\n            }\n            itemHolder.clickableLabel.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    showLabelDialog(alarm);\n                }\n            });\n\n            if (mRepeatChecked.contains(alarm.id) || itemHolder.alarm.daysOfWeek.isRepeating()) {\n                itemHolder.repeat.setChecked(true);\n                itemHolder.repeatDays.setVisibility(View.VISIBLE);\n            } else {\n                itemHolder.repeat.setChecked(false);\n                itemHolder.repeatDays.setVisibility(View.GONE);\n            }\n            itemHolder.repeat.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    final boolean checked = ((CheckBox) view).isChecked();\n                    if (checked) {\n                        // Show days\n                        itemHolder.repeatDays.setVisibility(View.VISIBLE);\n                        mRepeatChecked.add(alarm.id);\n\n                        // Set all previously set days\n                        // or\n                        // Set all days if no previous.\n                        final int bitSet = mPreviousDaysOfWeekMap.getInt(\"\" + alarm.id);\n                        alarm.daysOfWeek.setBitSet(bitSet);\n                        if (!alarm.daysOfWeek.isRepeating()) {\n                            alarm.daysOfWeek.setDaysOfWeek(true, DAY_ORDER);\n                        }\n                        updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n                    } else {\n                        itemHolder.repeatDays.setVisibility(View.GONE);\n                        mRepeatChecked.remove(alarm.id);\n\n                        // Remember the set days in case the user wants it back.\n                        final int bitSet = alarm.daysOfWeek.getBitSet();\n                        mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id, bitSet);\n\n                        // Remove all repeat days\n                        alarm.daysOfWeek.clearAllDays();\n                    }\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n            for (int i = 0; i \u003c 7; i++) {\n                final int buttonIndex = i;\n\n                itemHolder.dayButtonParents[i].setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        itemHolder.dayButtons[buttonIndex].toggle();\n                        final boolean checked = itemHolder.dayButtons[buttonIndex].isChecked();\n                        int day = DAY_ORDER[buttonIndex];\n                        alarm.daysOfWeek.setDaysOfWeek(checked, day);\n                        if (checked) {\n                            turnOnDayOfWeek(itemHolder, buttonIndex);\n                        } else {\n                            turnOffDayOfWeek(itemHolder, buttonIndex);\n\n                            // See if this was the last day, if so, un-check the repeat box.\n                            if (!alarm.daysOfWeek.isRepeating()) {\n                                itemHolder.repeatDays.setVisibility(View.GONE);\n                                itemHolder.repeat.setTextColor(mColorDim);\n                                mRepeatChecked.remove(alarm.id);\n\n                                // Set history to no days, so it will be everyday when repeat is\n                                // turned back on\n                                mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id,\n                                        DaysOfWeek.NO_DAYS_SET);\n                            }\n                        }\n                        asyncUpdateAlarm(alarm, false);\n                    }\n                });\n            }\n\n\n            if (!mHasVibrator) {\n                itemHolder.vibrate.setVisibility(View.INVISIBLE);\n            } else {\n                itemHolder.vibrate.setVisibility(View.VISIBLE);\n                if (!alarm.vibrate) {\n                    itemHolder.vibrate.setChecked(false);\n                    itemHolder.vibrate.setTextColor(mColorDim);\n                } else {\n                    itemHolder.vibrate.setChecked(true);\n                    itemHolder.vibrate.setTextColor(mColorLit);\n                }\n            }\n\n            itemHolder.vibrate.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    if (checked) {\n                        itemHolder.vibrate.setTextColor(mColorLit);\n                    } else {\n                        itemHolder.vibrate.setTextColor(mColorDim);\n                    }\n                    alarm.vibrate = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String ringtone;\n            final String ringtitle;\n            if (Alarm.NO_RINGTONE_URI.equals(alarm.alert)) {\n                ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n            } else {\n                ringtitle = getRingToneTitle(alarm.alert);\n                if (ringtitle != null) {\n                    ringtone = ringtitle;\n                } else {\n                    ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n                }\n            }\n            itemHolder.ringtone.setText(ringtone);\n            itemHolder.ringtone.setContentDescription(\n                    mContext.getResources().getString(R.string.ringtone_description) + \" \"\n                            + ringtone);\n            itemHolder.ringtone.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchRingTonePicker(alarm);\n                }\n            });\n\n\n            itemHolder.increasingVolume.setVisibility(View.VISIBLE);\n            itemHolder.increasingVolume.setChecked(alarm.increasingVolume);\n            itemHolder.increasingVolume.setTextColor(\n                    alarm.increasingVolume ? mColorLit : mColorDim);\n            itemHolder.increasingVolume.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    //When action mode is on - simulate long click\n                    itemHolder.increasingVolume.setTextColor(checked ? mColorLit : mColorDim);\n                    alarm.increasingVolume = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String profile = getProfileName(alarm);\n            itemHolder.profile.setText(profile);\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n            itemHolder.profile.setContentDescription(\n                    mContext.getResources().getString(R.string.profile_description, profile));\n            itemHolder.profile.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchProfilePicker(alarm);\n                }\n            });\n        }\n\n        // Sets the alpha of the item except the on/off switch. This gives a visual effect\n        // for enabled/disabled alarm while leaving the on/off switch more visible\n        private void setItemAlpha(ItemHolder holder, boolean enabled) {\n            float alpha = enabled ? 1f : 0.5f;\n            holder.clock.setAlpha(alpha);\n            holder.summary.setAlpha(alpha);\n            holder.expandArea.setAlpha(alpha);\n            holder.delete.setAlpha(alpha);\n            holder.daysOfWeek.setAlpha(alpha);\n        }\n\n        private void updateDaysOfWeekButtons(ItemHolder holder, DaysOfWeek daysOfWeek) {\n            HashSet\u003cInteger\u003e setDays = daysOfWeek.getSetDays();\n            for (int i = 0; i \u003c 7; i++) {\n                if (setDays.contains(DAY_ORDER[i])) {\n                    turnOnDayOfWeek(holder, i);\n                } else {\n                    turnOffDayOfWeek(holder, i);\n                }\n            }\n        }\n\n        public void toggleSelectState(View v) {\n            // long press could be on the parent view or one of its childs, so find the parent view\n            v = getTopParent(v);\n            if (v != null) {\n                long id = ((ItemHolder)v.getTag()).alarm.id;\n                if (mSelectedAlarms.contains(id)) {\n                    mSelectedAlarms.remove(id);\n                } else {\n                    mSelectedAlarms.add(id);\n                }\n            }\n        }\n\n        private View getTopParent(View v) {\n            while (v != null \u0026\u0026 v.getId() != R.id.alarm_item) {\n                v = (View) v.getParent();\n            }\n            return v;\n        }\n\n        public int getSelectedItemsNum() {\n            return mSelectedAlarms.size();\n        }\n\n        private void turnOffDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(false);\n            holder.dayButtons[dayIndex].setTextColor(mColorDim);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoNormal);\n        }\n\n        private void turnOnDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(true);\n            holder.dayButtons[dayIndex].setTextColor(mColorLit);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoBold);\n        }\n\n\n        /**\n         * Does a read-through cache for ringtone titles.\n         *\n         * @param uri The uri of the ringtone.\n         * @return The ringtone title. {@literal null} if no matching ringtone found.\n         */\n        private String getRingToneTitle(Uri uri) {\n            // Try the cache first\n            String title = mRingtoneTitleCache.getString(uri.toString());\n            if (title == null) {\n                if (uri.equals(MultiPlayer.RANDOM_URI)) {\n                    title = mContext.getResources().getString(R.string.alarm_type_random);\n                } else {\n                    // This is slow because a media player is created during Ringtone object creation.\n                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);\n                    if (ringTone != null) {\n                        title = ringTone.getTitle(mContext);\n                    }\n                }\n                if (title != null) {\n                    mRingtoneTitleCache.putString(uri.toString(), title);\n                }\n            }\n            return title;\n        }\n\n        public void setNewAlarm(long alarmId) {\n            mExpanded.add(alarmId);\n        }\n\n        /**\n         * Expands the alarm for editing.\n         *\n         * @param itemHolder The item holder instance.\n         */\n        private void expandAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.add(itemHolder.alarm.id);\n            bindExpandArea(itemHolder, itemHolder.alarm);\n            // Scroll the view to make sure it is fully viewed\n            mScrollAlarmId = itemHolder.alarm.id;\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to visible so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n            itemHolder.expandArea.setVisibility(View.VISIBLE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(180);\n                // We need to translate the hairline up, so the height of the collapseArea\n                // needs to be measured to know how high to translate it.\n                final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n                observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                    @Override\n                    public boolean onPreDraw() {\n                        // We don't want to continue getting called for every listview drawing.\n                        if (observer.isAlive()) {\n                            observer.removeOnPreDrawListener(this);\n                        }\n                        int hairlineHeight = itemHolder.hairLine.getHeight();\n                        int collapseHeight =\n                                itemHolder.collapseExpandArea.getHeight() - hairlineHeight;\n                        itemHolder.hairLine.setTranslationY(-collapseHeight);\n                        return true;\n                    }\n                });\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to VISIBLE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * the height is set back to the starting point so it can be animated down.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    // We don't want to continue getting called for every listview drawing.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    final int collapseHeight = itemHolder.collapseExpandArea.getHeight();\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = collapseHeight - hairlineHeight;\n\n                    // Set the height back to the start state of the animation.\n                    itemHolder.alarmItem.getLayoutParams().height = startingHeight;\n                    // To allow the expandArea to glide in with the expansion animation, set a\n                    // negative top margin, which will animate down to a margin of 0 as the height\n                    // is increased.\n                    // Note that we need to maintain the bottom margin as a fixed value (instead of\n                    // just using a listview, to allow for a flatter hierarchy) to fit the bottom\n                    // bar underneath.\n                    FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                            itemHolder.expandArea.getLayoutParams();\n                    expandParams.setMargins(0, -distance, 0, collapseHeight);\n                    itemHolder.alarmItem.requestLayout();\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(EXPAND_DURATION);\n                    animator.setInterpolator(mExpandInterpolator);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) -((1 - value) * distance), 0, collapseHeight);\n                            itemHolder.arrow.setRotation(180 * value);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * value);\n                            itemHolder.summary.setAlpha(1 - value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n                            itemHolder.arrow.setRotation(180);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance);\n                            itemHolder.summary.setVisibility(View.GONE);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    // Return false so this draw does not occur to prevent the final frame from\n                    // being drawn for the single frame before the animations start.\n                    return false;\n                }\n            });\n        }\n\n        private boolean isAlarmExpanded(Alarm alarm) {\n            return mExpanded.contains(alarm.id);\n        }\n\n        private void collapseAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.remove(itemHolder.alarm.id);\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to gone so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n            itemHolder.expandArea.setVisibility(View.GONE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(0);\n                itemHolder.hairLine.setTranslationY(0);\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to GONE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * expandArea is set to VISIBLE again so it can be shown animating.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = mCollapseExpandHeight - hairlineHeight;\n\n                    // Re-set the visibilities for the start state of the animation.\n                    itemHolder.expandArea.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setAlpha(1);\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(COLLAPSE_DURATION);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) (value * distance), 0, mCollapseExpandHeight);\n                            itemHolder.arrow.setRotation(180 * (1 - value));\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * (1 - value));\n                            itemHolder.summary.setAlpha(value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    animator.setInterpolator(mCollapseInterpolator);\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(0, 0, 0, mCollapseExpandHeight);\n\n                            itemHolder.expandArea.setVisibility(View.GONE);\n                            itemHolder.arrow.setRotation(0);\n                            itemHolder.hairLine.setTranslationY(0);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    return false;\n                }\n            });\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            return 1;\n        }\n\n        private View getViewById(long id) {\n            for (int i = 0; i \u003c mList.getCount(); i++) {\n                View v = mList.getChildAt(i);\n                if (v != null) {\n                    ItemHolder h = (ItemHolder)(v.getTag());\n                    if (h != null \u0026\u0026 h.alarm.id == id) {\n                        return v;\n                    }\n                }\n            }\n            return null;\n        }\n\n        public long[] getExpandedArray() {\n            int index = 0;\n            long[] ids = new long[mExpanded.size()];\n            for (long id : mExpanded) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getSelectedAlarmsArray() {\n            int index = 0;\n            long[] ids = new long[mSelectedAlarms.size()];\n            for (long id : mSelectedAlarms) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getRepeatArray() {\n            int index = 0;\n            long[] ids = new long[mRepeatChecked.size()];\n            for (long id : mRepeatChecked) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public Bundle getPreviousDaysOfWeekMap() {\n            return mPreviousDaysOfWeekMap;\n        }\n\n        private void buildHashSetFromArray(long[] ids, HashSet\u003cLong\u003e set) {\n            for (long id : ids) {\n                set.add(id);\n            }\n        }\n    }\n\n    private void startCreatingAlarm() {\n        // Set the \"selected\" alarm as null, and we'll create the new one when the timepicker\n        // comes back.\n        mSelectedAlarm = null;\n        AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                null, AlarmClockFragment.this, DateFormat.is24HourFormat(getActivity()));\n    }\n\n    private static AlarmInstance setupAlarmInstance(Context context, Alarm alarm) {\n        ContentResolver cr = context.getContentResolver();\n        AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());\n        newInstance = AlarmInstance.addInstance(cr, newInstance);\n        // Register instance to state manager\n        AlarmStateManager.registerInstance(context, newInstance, true);\n        return newInstance;\n    }\n\n    private void asyncDeleteAlarm(final Alarm alarm, final View viewToRemove) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, Void\u003e deleteTask = new AsyncTask\u003cVoid, Void, Void\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                if (viewToRemove == null) {\n                    return;\n                }\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                final ListView list = mAlarmsList;\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    if (child != viewToRemove) {\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n                        mItemIdTopMap.put(itemId, child.getTop());\n                    }\n                }\n            }\n\n            @Override\n            protected Void doInBackground(Void... parameters) {\n                // Activity may be closed at this point , make sure data is still valid\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n                    AlarmStateManager.deleteAllInstances(context, alarm.id);\n                    Alarm.deleteAlarm(cr, alarm.id);\n                }\n                return null;\n            }\n        };\n        mUndoShowing = true;\n        deleteTask.execute();\n    }\n\n    private void asyncAddAlarm(final Alarm alarm) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                final ListView list = mAlarmsList;\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    int position = firstVisiblePosition + i;\n                    long itemId = mAdapter.getItemId(position);\n                    mItemIdTopMap.put(itemId, child.getTop());\n                }\n            }\n\n            @Override\n            protected AlarmInstance doInBackground(Void... parameters) {\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n\n                    // Add alarm to db\n                    Alarm newAlarm = Alarm.addAlarm(cr, alarm);\n                    mScrollToAlarmId = newAlarm.id;\n\n                    // Create and add instance to db\n                    if (newAlarm.enabled) {\n                        return setupAlarmInstance(context, newAlarm);\n                    }\n                }\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    private void asyncUpdateAlarm(final Alarm alarm, final boolean popToast) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            protected AlarmInstance doInBackground(Void ... parameters) {\n                ContentResolver cr = context.getContentResolver();\n\n                // Dismiss all old instances\n                AlarmStateManager.deleteAllInstances(context, alarm.id);\n\n                // Update alarm\n                Alarm.updateAlarm(cr, alarm);\n                if (alarm.enabled) {\n                    return setupAlarmInstance(context, alarm);\n                }\n\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (popToast \u0026\u0026 instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        hideUndoBar(true, event);\n        return false;\n    }\n}","b":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.deskclock;\n\nimport android.animation.Animator;\nimport android.animation.Animator.AnimatorListener;\nimport android.animation.AnimatorInflater;\nimport android.animation.ValueAnimator;\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Fragment;\nimport android.app.FragmentTransaction;\nimport android.app.LoaderManager;\nimport android.app.Profile;\nimport android.app.ProfileManager;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.media.AudioManager;\nimport android.media.Ringtone;\nimport android.media.RingtoneManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Vibrator;\nimport android.provider.Settings;\nimport android.text.format.DateFormat;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.Interpolator;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CursorAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.ImageButton;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.Switch;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport com.android.datetimepicker.time.RadialPickerLayout;\nimport com.android.datetimepicker.time.TimePickerDialog;\nimport com.android.deskclock.alarms.AlarmStateManager;\nimport com.android.deskclock.provider.Alarm;\nimport com.android.deskclock.provider.AlarmInstance;\nimport com.android.deskclock.provider.DaysOfWeek;\nimport com.android.deskclock.widget.ActionableToastBar;\nimport com.android.deskclock.widget.TextTime;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * AlarmClock application.\n */\npublic class AlarmClockFragment extends DeskClockFragment implements\n        LoaderManager.LoaderCallbacks\u003cCursor\u003e,\n        TimePickerDialog.OnTimeSetListener,\n        View.OnTouchListener\n        {\n    private static final float EXPAND_DECELERATION = 1f;\n    private static final float COLLAPSE_DECELERATION = 0.7f;\n    private static final int ANIMATION_DURATION = 300;\n    private static final String KEY_EXPANDED_IDS = \"expandedIds\";\n    private static final String KEY_REPEAT_CHECKED_IDS = \"repeatCheckedIds\";\n    private static final String KEY_RINGTONE_TITLE_CACHE = \"ringtoneTitleCache\";\n    private static final String KEY_SELECTED_ALARMS = \"selectedAlarms\";\n    private static final String KEY_DELETED_ALARM = \"deletedAlarm\";\n    private static final String KEY_UNDO_SHOWING = \"undoShowing\";\n    private static final String KEY_PREVIOUS_DAY_MAP = \"previousDayMap\";\n    private static final String KEY_SELECTED_ALARM = \"selectedAlarm\";\n    private static final String KEY_DELETE_CONFIRMATION = \"deleteConfirmation\";\n\n    private static final int REQUEST_CODE_RINGTONE = 1;\n    private static final int REQUEST_CODE_PROFILE = 2;\n\n    // This extra is used when receiving an intent to create an alarm, but no alarm details\n    // have been passed in, so the alarm page should start the process of creating a new alarm.\n    public static final String ALARM_CREATE_NEW_INTENT_EXTRA = \"deskclock.create.new\";\n\n    // This extra is used when receiving an intent to scroll to specific alarm. If alarm\n    // can not be found, and toast message will pop up that the alarm has be deleted.\n    public static final String SCROLL_TO_ALARM_INTENT_EXTRA = \"deskclock.scroll.to.alarm\";\n\n    private ProfileManager mProfileManager;\n    private ProfilesObserver mProfileObserver;\n    private AudioManager mAudioManager;\n\n    private final Uri PROFILES_SETTINGS_URI =\n        Settings.System.getUriFor(Settings.System.SYSTEM_PROFILES_ENABLED);\n\n    private static final int MSG_PROFILE_STATUS_CHANGE = 1000;\n\n    private ListView mAlarmsList;\n    private AlarmItemAdapter mAdapter;\n    private View mEmptyView;\n    private ImageView mAddAlarmButton;\n    private View mAlarmsView;\n    private View mTimelineLayout;\n    private AlarmTimelineView mTimelineView;\n    private View mFooterView;\n\n    private Bundle mRingtoneTitleCache; // Key: ringtone uri, value: ringtone title\n    private ActionableToastBar mUndoBar;\n    private View mUndoFrame;\n\n    private Alarm mSelectedAlarm;\n    private long mScrollToAlarmId = -1;\n\n    private Loader mCursorLoader = null;\n\n    // Saved states for undo\n    private Alarm mDeletedAlarm;\n    private Alarm mAddedAlarm;\n    private boolean mUndoShowing = false;\n\n    private Animator mFadeIn;\n    private Animator mFadeOut;\n\n    private Interpolator mExpandInterpolator;\n    private Interpolator mCollapseInterpolator;\n\n    private int mTimelineViewWidth;\n    private int mUndoBarInitialMargin;\n\n    // Cached layout positions of items in listview prior to add/removal of alarm item\n    private ConcurrentHashMap\u003cLong, Integer\u003e mItemIdTopMap = new ConcurrentHashMap\u003cLong, Integer\u003e();\n\n    private final Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n\n            switch (msg.what) {\n                case MSG_PROFILE_STATUS_CHANGE:\n                    updateProfilesStatus();\n                    break;\n            }\n        }\n    };\n\n    public AlarmClockFragment() {\n        // Basic provider required by Fragment.java\n    }\n\n    @Override\n    public void onCreate(Bundle savedState) {\n        super.onCreate(savedState);\n        mCursorLoader = getLoaderManager().initLoader(0, null, this);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedState) {\n        // Inflate the layout for this fragment\n        final View v = inflater.inflate(R.layout.alarm_clock, container, false);\n\n        long[] expandedIds = null;\n        long[] repeatCheckedIds = null;\n        long[] selectedAlarms = null;\n        Bundle previousDayMap = null;\n        if (savedState != null) {\n            expandedIds = savedState.getLongArray(KEY_EXPANDED_IDS);\n            repeatCheckedIds = savedState.getLongArray(KEY_REPEAT_CHECKED_IDS);\n            mRingtoneTitleCache = savedState.getBundle(KEY_RINGTONE_TITLE_CACHE);\n            mDeletedAlarm = savedState.getParcelable(KEY_DELETED_ALARM);\n            mUndoShowing = savedState.getBoolean(KEY_UNDO_SHOWING);\n            selectedAlarms = savedState.getLongArray(KEY_SELECTED_ALARMS);\n            previousDayMap = savedState.getBundle(KEY_PREVIOUS_DAY_MAP);\n            mSelectedAlarm = savedState.getParcelable(KEY_SELECTED_ALARM);\n        }\n\n        // Register profiles status\n        mProfileManager = (ProfileManager) getActivity().getSystemService(Context.PROFILE_SERVICE);\n        mProfileObserver = new ProfilesObserver(mHandler);\n\n        mExpandInterpolator = new DecelerateInterpolator(EXPAND_DECELERATION);\n        mCollapseInterpolator = new DecelerateInterpolator(COLLAPSE_DECELERATION);\n\n        mAddAlarmButton = (ImageButton) v.findViewById(R.id.alarm_add_alarm);\n        mAddAlarmButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                hideUndoBar(true, null);\n                startCreatingAlarm();\n            }\n        });\n        // For landscape, put the add button on the right and the menu in the actionbar.\n        FrameLayout.LayoutParams layoutParams =\n                (FrameLayout.LayoutParams) mAddAlarmButton.getLayoutParams();\n        boolean isLandscape = getResources().getConfiguration().orientation\n                == Configuration.ORIENTATION_LANDSCAPE;\n        if (isLandscape) {\n            layoutParams.gravity = Gravity.END;\n        } else {\n            layoutParams.gravity = Gravity.CENTER;\n        }\n        mAddAlarmButton.setLayoutParams(layoutParams);\n\n        View menuButton = v.findViewById(R.id.menu_button);\n        if (menuButton != null) {\n            if (isLandscape) {\n                menuButton.setVisibility(View.GONE);\n            } else {\n                menuButton.setVisibility(View.VISIBLE);\n                setupFakeOverflowMenuButton(menuButton);\n            }\n        }\n\n        mEmptyView = v.findViewById(R.id.alarms_empty_view);\n        mEmptyView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startCreatingAlarm();\n            }\n        });\n        mAlarmsList = (ListView) v.findViewById(R.id.alarms_list);\n\n        mFadeIn = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_in);\n        mFadeIn.setDuration(ANIMATION_DURATION);\n        mFadeIn.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator animation) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animation) {\n                // Do nothing.\n            }\n        });\n        mFadeIn.setTarget(mEmptyView);\n        mFadeOut = AnimatorInflater.loadAnimator(getActivity(), R.anim.fade_out);\n        mFadeOut.setDuration(ANIMATION_DURATION);\n        mFadeOut.addListener(new AnimatorListener() {\n\n            @Override\n            public void onAnimationStart(Animator arg0) {\n                mEmptyView.setVisibility(View.VISIBLE);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator arg0) {\n                // Do nothing.\n            }\n\n            @Override\n            public void onAnimationEnd(Animator arg0) {\n                mEmptyView.setVisibility(View.GONE);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator arg0) {\n                // Do nothing.\n            }\n        });\n        mFadeOut.setTarget(mEmptyView);\n        mAlarmsView = v.findViewById(R.id.alarm_layout);\n        mTimelineLayout = v.findViewById(R.id.timeline_layout);\n\n        mUndoBar = (ActionableToastBar) v.findViewById(R.id.undo_bar);\n        mUndoBarInitialMargin = getActivity().getResources()\n                .getDimensionPixelOffset(R.dimen.alarm_undo_bar_horizontal_margin);\n        mUndoFrame = v.findViewById(R.id.undo_frame);\n        mUndoFrame.setOnTouchListener(this);\n\n        mFooterView = v.findViewById(R.id.alarms_footer_view);\n        mFooterView.setOnTouchListener(this);\n\n        // Timeline layout only exists in tablet landscape mode for now.\n        if (mTimelineLayout != null) {\n            mTimelineView = (AlarmTimelineView) v.findViewById(R.id.alarm_timeline_view);\n            mTimelineViewWidth = getActivity().getResources()\n                    .getDimensionPixelOffset(R.dimen.alarm_timeline_layout_width);\n        }\n\n        mAdapter = new AlarmItemAdapter(getActivity(),\n                expandedIds, repeatCheckedIds, selectedAlarms, previousDayMap, mAlarmsList);\n        mAdapter.registerDataSetObserver(new DataSetObserver() {\n\n            private int prevAdapterCount = -1;\n\n            @Override\n            public void onChanged() {\n\n                final int count = mAdapter.getCount();\n                if (mDeletedAlarm != null \u0026\u0026 prevAdapterCount \u003e count) {\n                    showUndoBar();\n                }\n\n                // If there are no alarms in the adapter...\n                if (count == 0) {\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_red);\n\n                    // ...and if there exists a timeline view (currently only in tablet landscape)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        // ...and if the previous adapter had alarms (indicating a removal)...\n                        if (prevAdapterCount \u003e 0) {\n\n                            // Then animate in the \"no alarms\" icon...\n                            mFadeIn.start();\n\n                            // and animate out the alarm timeline view, expanding the width of the\n                            // alarms list / undo bar.\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            ValueAnimator animator = ValueAnimator.ofFloat(1f, 0f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mCollapseInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.addListener(new AnimatorListener() {\n\n                                @Override\n                                public void onAnimationCancel(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(false);\n                                }\n\n                                @Override\n                                public void onAnimationRepeat(Animator animation) {\n                                    // Do nothing.\n                                }\n\n                                @Override\n                                public void onAnimationStart(Animator animation) {\n                                    mTimelineView.setIsAnimatingOut(true);\n                                }\n\n                            });\n                            animator.start();\n                        } else {\n                            // If the previous adapter did not have alarms, no animation needed,\n                            // just hide the timeline view and show the \"no alarms\" icon.\n                            mTimelineLayout.setVisibility(View.GONE);\n                            mEmptyView.setVisibility(View.VISIBLE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just show the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.VISIBLE);\n                    }\n                } else {\n\n                    // Otherwise, if the adapter DOES contain alarms...\n                    mAddAlarmButton.setBackgroundResource(R.drawable.main_button_normal);\n\n                    // ...and if there exists a timeline view (currently in tablet landscape mode)\n                    if (mTimelineLayout != null \u0026\u0026 mAlarmsView != null) {\n\n                        mTimelineLayout.setVisibility(View.VISIBLE);\n                        // ...and if the previous adapter did not have alarms (indicating an add)\n                        if (prevAdapterCount == 0) {\n\n                            // Then, animate to hide the \"no alarms\" icon...\n                            mFadeOut.start();\n\n                            // and animate to show the timeline view, reducing the width of the\n                            // alarms list / undo bar.\n                            ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                                    .setDuration(ANIMATION_DURATION);\n                            animator.setInterpolator(mExpandInterpolator);\n                            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                                @Override\n                                public void onAnimationUpdate(ValueAnimator animator) {\n                                    Float value = (Float) animator.getAnimatedValue();\n                                    int currentTimelineWidth = (int) (value * mTimelineViewWidth);\n                                    float rightOffset = mTimelineViewWidth * (1 - value);\n                                    mTimelineLayout.setTranslationX(rightOffset);\n                                    mTimelineLayout.setAlpha(value);\n                                    mTimelineLayout.requestLayout();\n                                    ((FrameLayout.LayoutParams) mAlarmsView.getLayoutParams())\n                                        .setMargins(0, 0, (int) -rightOffset, 0);\n                                    mAlarmsView.requestLayout();\n                                    setUndoBarRightMargin(currentTimelineWidth\n                                            + mUndoBarInitialMargin);\n                                }\n                            });\n                            animator.start();\n                        } else {\n                            mTimelineLayout.setVisibility(View.VISIBLE);\n                            mEmptyView.setVisibility(View.GONE);\n                            setUndoBarRightMargin(mUndoBarInitialMargin + mTimelineViewWidth);\n                        }\n                    } else {\n\n                        // If there is no timeline view, just hide the \"no alarms\" icon.\n                        mEmptyView.setVisibility(View.GONE);\n                    }\n                }\n\n                // Cache this adapter's count for when the adapter changes.\n                prevAdapterCount = count;\n                super.onChanged();\n            }\n        });\n\n        if (mRingtoneTitleCache == null) {\n            mRingtoneTitleCache = new Bundle();\n        }\n\n        mAlarmsList.setAdapter(mAdapter);\n        mAlarmsList.setVerticalScrollBarEnabled(true);\n        mAlarmsList.setOnCreateContextMenuListener(this);\n\n        mAudioManager = (AudioManager)getActivity().getSystemService(Context.AUDIO_SERVICE);\n\n        if (mUndoShowing) {\n            showUndoBar();\n        }\n        return v;\n    }\n\n    private void setUndoBarRightMargin(int margin) {\n        FrameLayout.LayoutParams params =\n                (FrameLayout.LayoutParams) mUndoBar.getLayoutParams();\n        ((FrameLayout.LayoutParams) mUndoBar.getLayoutParams())\n            .setMargins(params.leftMargin, params.topMargin, margin, params.bottomMargin);\n        mUndoBar.requestLayout();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        // Check if another app asked us to create a blank new alarm.\n        final Intent intent = getActivity().getIntent();\n        if (intent.hasExtra(ALARM_CREATE_NEW_INTENT_EXTRA)) {\n            if (intent.getBooleanExtra(ALARM_CREATE_NEW_INTENT_EXTRA, false)) {\n                // An external app asked us to create a blank alarm.\n                startCreatingAlarm();\n            }\n\n            // Remove the CREATE_NEW extra now that we've processed it.\n            intent.removeExtra(ALARM_CREATE_NEW_INTENT_EXTRA);\n        } else if (intent.hasExtra(SCROLL_TO_ALARM_INTENT_EXTRA)) {\n            long alarmId = intent.getLongExtra(SCROLL_TO_ALARM_INTENT_EXTRA, Alarm.INVALID_ID);\n            if (alarmId != Alarm.INVALID_ID) {\n                mScrollToAlarmId = alarmId;\n                if (mCursorLoader != null \u0026\u0026 mCursorLoader.isStarted()) {\n                    // We need to force a reload here to make sure we have the latest view\n                    // of the data to scroll to.\n                    mCursorLoader.forceLoad();\n                }\n            }\n\n            // Remove the SCROLL_TO_ALARM extra now that we've processed it.\n            intent.removeExtra(SCROLL_TO_ALARM_INTENT_EXTRA);\n        } else {\n            // If alarm stream volume is 0, show a warning\n            if (mAudioManager.getStreamVolume(AudioManager.STREAM_ALARM) == 0) {\n                showSilentWarningBar();\n            }\n\n        }\n\n        // Make sure to use the child FragmentManager. We have to use that one for the\n        // case where an intent comes in telling the activity to load the timepicker,\n        // which means we have to use that one everywhere so that the fragment can get\n        // correctly picked up here if it's open.\n        TimePickerDialog tpd = (TimePickerDialog) getChildFragmentManager().\n                findFragmentByTag(AlarmUtils.FRAG_TAG_TIME_PICKER);\n        if (tpd != null) {\n            // The dialog is already open so we need to set the listener again.\n            tpd.setOnTimeSetListener(this);\n        }\n\n        // Update the profile status and register the profile observer\n        getActivity().getContentResolver().registerContentObserver(\n                PROFILES_SETTINGS_URI, false, mProfileObserver);\n        updateProfilesStatus();\n    }\n\n    private void hideUndoBar(boolean animate, MotionEvent event) {\n        if (mUndoBar != null) {\n            mUndoFrame.setVisibility(View.GONE);\n            if (event != null \u0026\u0026 mUndoBar.isEventInToastBar(event)) {\n                // Avoid touches inside the undo bar.\n                return;\n            }\n            mUndoBar.hide(animate);\n        }\n        mDeletedAlarm = null;\n        mUndoShowing = false;\n    }\n\n    private void showUndoBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                asyncAddAlarm(mDeletedAlarm);\n                mDeletedAlarm = null;\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.alarm_deleted), true, 0, R.string.alarm_undo, true);\n    }\n\n    private void showSilentWarningBar() {\n        mUndoFrame.setVisibility(View.VISIBLE);\n        mUndoBar.show(new ActionableToastBar.ActionClickedListener() {\n            @Override\n            public void onActionClicked() {\n                mAudioManager.adjustStreamVolume(AudioManager.STREAM_ALARM,\n                        AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);\n                mUndoShowing = false;\n            }\n        }, 0, getResources().getString(R.string.warn_silent_alarm_title), true,\n                R.drawable.ic_alarm, 0, true);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putLongArray(KEY_EXPANDED_IDS, mAdapter.getExpandedArray());\n        outState.putLongArray(KEY_REPEAT_CHECKED_IDS, mAdapter.getRepeatArray());\n        outState.putLongArray(KEY_SELECTED_ALARMS, mAdapter.getSelectedAlarmsArray());\n        outState.putBundle(KEY_RINGTONE_TITLE_CACHE, mRingtoneTitleCache);\n        outState.putParcelable(KEY_DELETED_ALARM, mDeletedAlarm);\n        outState.putBoolean(KEY_UNDO_SHOWING, mUndoShowing);\n        outState.putBundle(KEY_PREVIOUS_DAY_MAP, mAdapter.getPreviousDaysOfWeekMap());\n        outState.putParcelable(KEY_SELECTED_ALARM, mSelectedAlarm);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        ToastMaster.cancelToast();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        // When the user places the app in the background by pressing \"home\",\n        // dismiss the toast bar. However, since there is no way to determine if\n        // home was pressed, just dismiss any existing toast bar when restarting\n        // the app.\n        hideUndoBar(false, null);\n\n        // Unregister the profile observer\n        getActivity().getContentResolver().unregisterContentObserver(mProfileObserver);\n    }\n\n    // Callback used by TimePickerDialog\n    @Override\n    public void onTimeSet(RadialPickerLayout view, int hourOfDay, int minute) {\n        if (mSelectedAlarm == null) {\n            // If mSelectedAlarm is null then we're creating a new alarm.\n            Alarm a = new Alarm();\n            a.alert = RingtoneManager.getActualDefaultRingtoneUri(getActivity(),\n                    RingtoneManager.TYPE_ALARM);\n            if (a.alert == null) {\n                a.alert = Uri.parse(\"content://settings/system/alarm_alert\");\n            }\n            a.hour = hourOfDay;\n            a.minutes = minute;\n            a.enabled = true;\n            asyncAddAlarm(a);\n        } else {\n            mSelectedAlarm.hour = hourOfDay;\n            mSelectedAlarm.minutes = minute;\n            mSelectedAlarm.enabled = true;\n            mScrollToAlarmId = mSelectedAlarm.id;\n            asyncUpdateAlarm(mSelectedAlarm, true);\n            mSelectedAlarm = null;\n        }\n    }\n\n    private void showLabelDialog(final Alarm alarm) {\n        final FragmentTransaction ft = getFragmentManager().beginTransaction();\n        final Fragment prev = getFragmentManager().findFragmentByTag(\"label_dialog\");\n        if (prev != null) {\n            ft.remove(prev);\n        }\n        ft.addToBackStack(null);\n\n        // Create and show the dialog.\n        final LabelDialogFragment newFragment =\n                LabelDialogFragment.newInstance(alarm, alarm.label, getTag());\n        newFragment.show(ft, \"label_dialog\");\n    }\n\n    public void setLabel(Alarm alarm, String label) {\n        alarm.label = label;\n        asyncUpdateAlarm(alarm, false);\n    }\n\n    @Override\n    public Loader\u003cCursor\u003e onCreateLoader(int id, Bundle args) {\n        return Alarm.getAlarmsCursorLoader(getActivity());\n    }\n\n    @Override\n    public void onLoadFinished(Loader\u003cCursor\u003e cursorLoader, final Cursor data) {\n        mAdapter.swapCursor(data);\n        if (mScrollToAlarmId != -1) {\n            scrollToAlarm(mScrollToAlarmId);\n            mScrollToAlarmId = -1;\n        }\n    }\n\n    /**\n     * Scroll to alarm with given alarm id.\n     *\n     * @param alarmId The alarm id to scroll to.\n     */\n    private void scrollToAlarm(long alarmId) {\n        int alarmPosition = -1;\n        for (int i = 0; i \u003c mAdapter.getCount(); i++) {\n            long id = mAdapter.getItemId(i);\n            if (id == alarmId) {\n                alarmPosition = i;\n                break;\n            }\n        }\n\n        if (alarmPosition \u003e= 0) {\n            mAdapter.setNewAlarm(alarmId);\n            mAlarmsList.smoothScrollToPositionFromTop(alarmPosition, 0);\n        } else {\n            // Trying to display a deleted alarm should only happen from a missed notification for\n            // an alarm that has been marked deleted after use.\n            Context context = getActivity().getApplicationContext();\n            Toast toast = Toast.makeText(context, R.string.missed_alarm_has_been_deleted,\n                    Toast.LENGTH_LONG);\n            ToastMaster.setToast(toast);\n            toast.show();\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader\u003cCursor\u003e cursorLoader) {\n        mAdapter.swapCursor(null);\n    }\n\n    private void launchRingTonePicker(final Alarm alarm) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        builder.setTitle(R.string.alarm_picker_title).setItems(\n                R.array.ringtone_picker_entries,\n\n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        switch (which) {\n                            case 0:\n                                launchSingleRingTonePicker(alarm);\n                                break;\n                            case 1:\n                                alarm.alert = MultiPlayer.RANDOM_URI;\n                                asyncUpdateAlarm(alarm, false);\n                                break;\n                        }\n                    }\n                });\n        AlertDialog d = builder.create();\n        d.show();\n    }\n\n    private void launchSingleRingTonePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        Uri oldRingtone = Alarm.NO_RINGTONE_URI.equals(alarm.alert) ? null : alarm.alert;\n        final Intent intent = new Intent(RingtoneManager.ACTION_RINGTONE_PICKER);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, oldRingtone);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, RingtoneManager.TYPE_ALARM);\n        intent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, false);\n        startActivityForResult(intent, REQUEST_CODE_RINGTONE);\n    }\n\n    private void launchProfilePicker(Alarm alarm) {\n        mSelectedAlarm = alarm;\n        final Intent intent = new Intent(ProfileManager.ACTION_PROFILE_PICKER);\n\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_EXISTING_UUID, alarm.profile.toString());\n        intent.putExtra(ProfileManager.EXTRA_PROFILE_SHOW_NONE, true);\n        startActivityForResult(intent, REQUEST_CODE_PROFILE);\n    }\n\n    private void saveRingtoneUri(Intent intent) {\n        Uri uri = intent.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);\n        if (uri == null) {\n            uri = Alarm.NO_RINGTONE_URI;\n        }\n        mSelectedAlarm.alert = uri;\n\n        // Save the last selected ringtone as the default for new alarms\n        if (!Alarm.NO_RINGTONE_URI.equals(uri)) {\n            RingtoneManager.setActualDefaultRingtoneUri(\n                    getActivity(), RingtoneManager.TYPE_ALARM, uri);\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private void saveProfile(Intent intent) {\n        final String uuid = intent.getStringExtra(ProfileManager.EXTRA_PROFILE_PICKED_UUID);\n        if (uuid != null) {\n            try {\n                mSelectedAlarm.profile = UUID.fromString(uuid);\n            } catch (IllegalArgumentException ex) {\n                mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n            }\n        } else {\n            mSelectedAlarm.profile = ProfileManager.NO_PROFILE;\n        }\n        asyncUpdateAlarm(mSelectedAlarm, false);\n    }\n\n    private boolean isProfilesEnabled() {\n        return Settings.System.getInt(getActivity().getContentResolver(),\n                Settings.System.SYSTEM_PROFILES_ENABLED, 1) == 1;\n    }\n\n    private String getProfileName(Alarm alarm) {\n        if (!isProfilesEnabled() || alarm.profile.equals(ProfileManager.NO_PROFILE)) {\n            return getString(R.string.profile_no_selected);\n        }\n        Profile profile = mProfileManager.getProfile(alarm.profile);\n        if (profile == null) {\n            return getString(R.string.profile_no_selected);\n        }\n        return profile.getName();\n    }\n\n    private void updateProfilesStatus() {\n        // Need to refresh the data\n        if (mAdapter != null) {\n            mAdapter.notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == Activity.RESULT_OK) {\n            switch (requestCode) {\n                case REQUEST_CODE_RINGTONE:\n                    saveRingtoneUri(data);\n                    break;\n                case REQUEST_CODE_PROFILE:\n                    saveProfile(data);\n                default:\n                    Log.w(\"Unhandled request code in onActivityResult: \" + requestCode);\n            }\n        }\n    }\n\n    private class ProfilesObserver extends ContentObserver {\n        public ProfilesObserver(Handler handler) {\n            super(handler);\n        }\n\n        @Override\n        public void onChange(boolean selfChange) {\n            onChange(selfChange, null);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            if (uri == null) return;\n            if (PROFILES_SETTINGS_URI.equals(uri)) {\n                mHandler.removeMessages(MSG_PROFILE_STATUS_CHANGE);\n                mHandler.sendEmptyMessage(MSG_PROFILE_STATUS_CHANGE);\n            }\n        }\n    }\n\n    public class AlarmItemAdapter extends CursorAdapter {\n        private static final int EXPAND_DURATION = 300;\n        private static final int COLLAPSE_DURATION = 250;\n\n        private final Context mContext;\n        private final LayoutInflater mFactory;\n        private final String[] mShortWeekDayStrings;\n        private final String[] mLongWeekDayStrings;\n        private final int mColorLit;\n        private final int mColorDim;\n        private final int mBackgroundColorExpanded;\n        private final int mBackgroundColor;\n        private final Typeface mRobotoNormal;\n        private final Typeface mRobotoBold;\n        private final ListView mList;\n\n        private final HashSet\u003cLong\u003e mExpanded = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mRepeatChecked = new HashSet\u003cLong\u003e();\n        private final HashSet\u003cLong\u003e mSelectedAlarms = new HashSet\u003cLong\u003e();\n        private Bundle mPreviousDaysOfWeekMap = new Bundle();\n\n        private final boolean mHasVibrator;\n        private final int mCollapseExpandHeight;\n\n        // This determines the order in which it is shown and processed in the UI.\n        // The array is filled when the adapter is created\n        private final int[] DAY_ORDER = new int[7];\n\n        public class ItemHolder {\n\n            // views for optimization\n            LinearLayout alarmItem;\n            TextTime clock;\n            Switch onoff;\n            TextView daysOfWeek;\n            TextView label;\n            ImageView delete;\n            View expandArea;\n            View summary;\n            TextView clickableLabel;\n            CheckBox repeat;\n            LinearLayout repeatDays;\n            ViewGroup[] dayButtonParents = new ViewGroup[7];\n            ToggleButton[] dayButtons = new ToggleButton[7];\n            CheckBox vibrate;\n            CheckBox increasingVolume;\n            TextView ringtone;\n            TextView profile;\n            View hairLine;\n            View arrow;\n            View collapseExpandArea;\n            View footerFiller;\n\n            // Other states\n            Alarm alarm;\n        }\n\n        // Used for scrolling an expanded item in the list to make sure it is fully visible.\n        private long mScrollAlarmId = -1;\n        private final Runnable mScrollRunnable = new Runnable() {\n            @Override\n            public void run() {\n                if (mScrollAlarmId != -1) {\n                    View v = getViewById(mScrollAlarmId);\n                    if (v != null) {\n                        Rect rect = new Rect(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());\n                        mList.requestChildRectangleOnScreen(v, rect, false);\n                    }\n                    mScrollAlarmId = -1;\n                }\n            }\n        };\n\n        public AlarmItemAdapter(Context context, long[] expandedIds, long[] repeatCheckedIds,\n                long[] selectedAlarms, Bundle previousDaysOfWeekMap, ListView list) {\n            super(context, null, 0);\n            mContext = context;\n            mFactory = LayoutInflater.from(context);\n            mList = list;\n\n            DateFormatSymbols dfs = new DateFormatSymbols();\n            mShortWeekDayStrings = dfs.getShortWeekdays();\n            mLongWeekDayStrings = dfs.getWeekdays();\n            int firstDayOfWeek = Calendar.getInstance(Locale.getDefault()).getFirstDayOfWeek();\n            int j = 0;\n            for (int i = firstDayOfWeek; i \u003c= DAY_ORDER.length; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n            for (int i = Calendar.SUNDAY; i \u003c firstDayOfWeek; i++, j++) {\n                DAY_ORDER[j] = i;\n            }\n\n            Resources res = mContext.getResources();\n            mColorLit = res.getColor(R.color.clock_white);\n            mColorDim = res.getColor(R.color.clock_gray);\n            mBackgroundColorExpanded = res.getColor(R.color.alarm_whiteish);\n            mBackgroundColor = R.drawable.alarm_background_normal;\n\n            mRobotoBold = Typeface.create(\"sans-serif-condensed\", Typeface.BOLD);\n            mRobotoNormal = Typeface.create(\"sans-serif-condensed\", Typeface.NORMAL);\n\n            if (expandedIds != null) {\n                buildHashSetFromArray(expandedIds, mExpanded);\n            }\n            if (repeatCheckedIds != null) {\n                buildHashSetFromArray(repeatCheckedIds, mRepeatChecked);\n            }\n            if (previousDaysOfWeekMap != null) {\n                mPreviousDaysOfWeekMap = previousDaysOfWeekMap;\n            }\n            if (selectedAlarms != null) {\n                buildHashSetFromArray(selectedAlarms, mSelectedAlarms);\n            }\n\n            mHasVibrator = ((Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE))\n                    .hasVibrator();\n\n            mCollapseExpandHeight = (int) res.getDimension(R.dimen.collapse_expand_height);\n        }\n\n        public void removeSelectedId(int id) {\n            mSelectedAlarms.remove(id);\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (!getCursor().moveToPosition(position)) {\n                // May happen if the last alarm was deleted and the cursor refreshed while the\n                // list is updated.\n                Log.v(\"couldn't move cursor to position \" + position);\n                return null;\n            }\n            View v;\n            if (convertView == null) {\n                v = newView(mContext, getCursor(), parent);\n            } else {\n                // TODO temporary hack to prevent the convertView from not having stuff we need.\n                boolean badConvertView = convertView.findViewById(R.id.digital_clock) == null;\n                // Do a translation check to test for animation. Change this to something more\n                // reliable and robust in the future.\n                if (convertView.getTranslationX() != 0 || convertView.getTranslationY() != 0 ||\n                        badConvertView) {\n                    // view was animated, reset\n                    v = newView(mContext, getCursor(), parent);\n                } else {\n                    v = convertView;\n                }\n            }\n            bindView(v, mContext, getCursor());\n            ItemHolder holder = (ItemHolder) v.getTag();\n\n            // We need the footer for the last element of the array to allow the user to scroll\n            // the item beyond the bottom button bar, which obscures the view.\n            holder.footerFiller.setVisibility(position \u003c getCount() - 1 ? View.GONE : View.VISIBLE);\n            return v;\n        }\n\n        @Override\n        public View newView(Context context, Cursor cursor, ViewGroup parent) {\n            final View view = mFactory.inflate(R.layout.alarm_time, parent, false);\n            setNewHolder(view);\n            return view;\n        }\n\n        /**\n         * In addition to changing the data set for the alarm list, swapCursor is now also\n         * responsible for preparing the list view's pre-draw operation for any animations that\n         * need to occur if an alarm was removed or added.\n         */\n        @Override\n        public synchronized Cursor swapCursor(Cursor cursor) {\n            Cursor c = super.swapCursor(cursor);\n\n            if (mItemIdTopMap.isEmpty() \u0026\u0026 mAddedAlarm == null) {\n                return c;\n            }\n\n            final ListView list = mAlarmsList;\n            final ViewTreeObserver observer = list.getViewTreeObserver();\n\n            /*\n             * Add a pre-draw listener to the observer to prepare for any possible animations to\n             * the alarms within the list view.  The animations will occur if an alarm has been\n             * removed or added.\n             *\n             * For alarm removal, the remaining children should all retain their initial starting\n             * positions, and transition to their new positions.\n             *\n             * For alarm addition, the other children should all retain their initial starting\n             * positions, transition to their new positions, and at the end of that transition, the\n             * newly added alarm should appear in the designated space.\n             */\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n\n                private View mAddedView;\n\n                @Override\n                public boolean onPreDraw() {\n                    // Remove the pre-draw listener, as this only needs to occur once.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    boolean firstAnimation = true;\n                    int firstVisiblePosition = list.getFirstVisiblePosition();\n\n                    // Iterate through the children to prepare the add/remove animation.\n                    for (int i = 0; i\u003c list.getChildCount(); i++) {\n                        final View child = list.getChildAt(i);\n\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n\n                        // If this is the added alarm, set it invisible for now, and animate later.\n                        if (mAddedAlarm != null \u0026\u0026 itemId == mAddedAlarm.id) {\n                            mAddedView = child;\n                            mAddedView.setAlpha(0.0f);\n                            continue;\n                        }\n\n                        // The cached starting position of the child view.\n                        Integer startTop = mItemIdTopMap.get(itemId);\n                        // The new starting position of the child view.\n                        int top = child.getTop();\n\n                        // If there is no cached starting position, determine whether the item has\n                        // come from the top of bottom of the list view.\n                        if (startTop == null) {\n                            int childHeight = child.getHeight() + list.getDividerHeight();\n                            startTop = top + (i \u003e 0 ? childHeight : -childHeight);\n                        }\n\n                        Log.d(\"Start Top: \" + startTop + \", Top: \" + top);\n                        // If the starting position of the child view is different from the\n                        // current position, animate the child.\n                        if (startTop != top) {\n                            int delta = startTop - top;\n                            child.setTranslationY(delta);\n                            child.animate().setDuration(ANIMATION_DURATION).translationY(0);\n                            final View addedView = mAddedView;\n                            if (firstAnimation) {\n\n                                // If this is the first child being animated, then after the\n                                // animation is complete, and animate in the added alarm (if one\n                                // exists).\n                                child.animate().withEndAction(new Runnable() {\n\n                                    @Override\n                                    public void run() {\n\n\n                                        // If there was an added view, animate it in after\n                                        // the other views have animated.\n                                        if (addedView != null) {\n                                            addedView.animate().alpha(1.0f)\n                                                .setDuration(ANIMATION_DURATION)\n                                                .withEndAction(new Runnable() {\n\n                                                    @Override\n                                                    public void run() {\n                                                        // Re-enable the list after the add\n                                                        // animation is complete.\n                                                        list.setEnabled(true);\n                                                    }\n\n                                                });\n                                        } else {\n                                            // Re-enable the list after animations are complete.\n                                            list.setEnabled(true);\n                                        }\n                                    }\n\n                                });\n                                firstAnimation = false;\n                            }\n                        }\n                    }\n\n                    // If there were no child views (outside of a possible added view)\n                    // that require animation...\n                    if (firstAnimation) {\n                        if (mAddedView != null) {\n                            // If there is an added view, prepare animation for the added view.\n                            Log.d(\"Animating added view...\");\n                            mAddedView.animate().alpha(1.0f)\n                                .setDuration(ANIMATION_DURATION)\n                                .withEndAction(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        // Re-enable the list after animations are complete.\n                                        list.setEnabled(true);\n                                    }\n                                });\n                        } else {\n                            // Re-enable the list after animations are complete.\n                            list.setEnabled(true);\n                        }\n                    }\n\n                    mAddedAlarm = null;\n                    mItemIdTopMap.clear();\n                    return true;\n                }\n            });\n            return c;\n        }\n\n        private void setNewHolder(View view) {\n            // standard view holder optimization\n            final ItemHolder holder = new ItemHolder();\n            holder.alarmItem = (LinearLayout) view.findViewById(R.id.alarm_item);\n            holder.clock = (TextTime) view.findViewById(R.id.digital_clock);\n            holder.onoff = (Switch) view.findViewById(R.id.onoff);\n            holder.onoff.setTypeface(mRobotoNormal);\n            holder.daysOfWeek = (TextView) view.findViewById(R.id.daysOfWeek);\n            holder.label = (TextView) view.findViewById(R.id.label);\n            holder.delete = (ImageView) view.findViewById(R.id.delete);\n            holder.summary = view.findViewById(R.id.summary);\n            holder.expandArea = view.findViewById(R.id.expand_area);\n            holder.hairLine = view.findViewById(R.id.hairline);\n            holder.arrow = view.findViewById(R.id.arrow);\n            holder.repeat = (CheckBox) view.findViewById(R.id.repeat_onoff);\n            holder.clickableLabel = (TextView) view.findViewById(R.id.edit_label);\n            holder.repeatDays = (LinearLayout) view.findViewById(R.id.repeat_days);\n            holder.collapseExpandArea = view.findViewById(R.id.collapse_expand);\n            holder.footerFiller = view.findViewById(R.id.alarm_footer_filler);\n            holder.footerFiller.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // Do nothing.\n                }\n            });\n\n            // Build button for each day.\n            for (int i = 0; i \u003c 7; i++) {\n                final ViewGroup viewgroup = (ViewGroup) mFactory.inflate(R.layout.day_button,\n                        holder.repeatDays, false);\n                final ToggleButton button = (ToggleButton) viewgroup.getChildAt(0);\n                final int dayToShowIndex = DAY_ORDER[i];\n                button.setText(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOn(mShortWeekDayStrings[dayToShowIndex]);\n                button.setTextOff(mShortWeekDayStrings[dayToShowIndex]);\n                button.setContentDescription(mLongWeekDayStrings[dayToShowIndex]);\n                holder.repeatDays.addView(viewgroup);\n                holder.dayButtons[i] = button;\n                holder.dayButtonParents[i] = viewgroup;\n            }\n            holder.vibrate = (CheckBox) view.findViewById(R.id.vibrate_onoff);\n            holder.increasingVolume = (CheckBox) view.findViewById(R.id.increasing_volume_onoff);\n            holder.ringtone = (TextView) view.findViewById(R.id.choose_ringtone);\n            holder.profile = (TextView) view.findViewById(R.id.choose_profile);\n\n            view.setTag(holder);\n        }\n\n        @Override\n        public void bindView(final View view, Context context, final Cursor cursor) {\n            final Alarm alarm = new Alarm(cursor);\n            Object tag = view.getTag();\n            if (tag == null) {\n                // The view was converted but somehow lost its tag.\n                setNewHolder(view);\n            }\n            final ItemHolder itemHolder = (ItemHolder) tag;\n            itemHolder.alarm = alarm;\n\n            // We must unset the listener first because this maybe a recycled view so changing the\n            // state would affect the wrong alarm.\n            itemHolder.onoff.setOnCheckedChangeListener(null);\n            itemHolder.onoff.setChecked(alarm.enabled);\n\n            if (mSelectedAlarms.contains(itemHolder.alarm.id)) {\n                itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n                setItemAlpha(itemHolder, true);\n                itemHolder.onoff.setEnabled(false);\n            } else {\n                itemHolder.onoff.setEnabled(true);\n                itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n                setItemAlpha(itemHolder, itemHolder.onoff.isChecked());\n            }\n            itemHolder.clock.setFormat(\n                    (int)mContext.getResources().getDimension(R.dimen.alarm_label_size));\n            itemHolder.clock.setTime(alarm.hour, alarm.minutes);\n            itemHolder.clock.setClickable(true);\n            itemHolder.clock.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    mSelectedAlarm = itemHolder.alarm;\n                    AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                            alarm, AlarmClockFragment.this\n                            , DateFormat.is24HourFormat(getActivity()));\n                    expandAlarm(itemHolder, true);\n                    itemHolder.alarmItem.post(mScrollRunnable);\n                }\n            });\n\n            final CompoundButton.OnCheckedChangeListener onOffListener =\n                    new CompoundButton.OnCheckedChangeListener() {\n                        @Override\n                        public void onCheckedChanged(CompoundButton compoundButton,\n                                boolean checked) {\n                            if (checked != alarm.enabled) {\n                                setItemAlpha(itemHolder, checked);\n                                alarm.enabled = checked;\n                                asyncUpdateAlarm(alarm, alarm.enabled);\n                            }\n                        }\n                    };\n\n            itemHolder.onoff.setOnCheckedChangeListener(onOffListener);\n\n            boolean expanded = isAlarmExpanded(alarm);\n            itemHolder.expandArea.setVisibility(expanded? View.VISIBLE : View.GONE);\n            itemHolder.summary.setVisibility(expanded? View.GONE : View.VISIBLE);\n\n            String labelSpace = \"\";\n            // Set the repeat text or leave it blank if it does not repeat.\n            final String daysOfWeekStr =\n                    alarm.daysOfWeek.toString(AlarmClockFragment.this.getActivity(), false);\n            if (daysOfWeekStr != null \u0026\u0026 daysOfWeekStr.length() != 0) {\n                itemHolder.daysOfWeek.setText(daysOfWeekStr);\n                itemHolder.daysOfWeek.setContentDescription(alarm.daysOfWeek.toAccessibilityString(\n                        AlarmClockFragment.this.getActivity()));\n                itemHolder.daysOfWeek.setVisibility(View.VISIBLE);\n                labelSpace = \"  \";\n                itemHolder.daysOfWeek.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n\n            } else {\n                itemHolder.daysOfWeek.setVisibility(View.GONE);\n            }\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() != 0) {\n                itemHolder.label.setText(alarm.label + labelSpace);\n                itemHolder.label.setVisibility(View.VISIBLE);\n                itemHolder.label.setContentDescription(\n                        mContext.getResources().getString(R.string.label_description) + \" \"\n                        + alarm.label);\n                itemHolder.label.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        expandAlarm(itemHolder, true);\n                        itemHolder.alarmItem.post(mScrollRunnable);\n                    }\n                });\n            } else {\n                itemHolder.label.setVisibility(View.GONE);\n            }\n\n            itemHolder.delete.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    mDeletedAlarm = alarm;\n\n                    view.animate().setDuration(ANIMATION_DURATION).alpha(0).translationY(-1)\n                    .withEndAction(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            asyncDeleteAlarm(mDeletedAlarm, view);\n                        }\n                    });\n                }\n            });\n\n            if (expanded) {\n                expandAlarm(itemHolder, false);\n            } else {\n                collapseAlarm(itemHolder, false);\n            }\n\n            itemHolder.alarmItem.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    if (isAlarmExpanded(alarm)) {\n                        collapseAlarm(itemHolder, true);\n                    } else {\n                        expandAlarm(itemHolder, true);\n                    }\n                }\n            });\n\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n        }\n\n        private void bindExpandArea(final ItemHolder itemHolder, final Alarm alarm) {\n            // Views in here are not bound until the item is expanded.\n\n            if (alarm.label != null \u0026\u0026 alarm.label.length() \u003e 0) {\n                itemHolder.clickableLabel.setText(alarm.label);\n                itemHolder.clickableLabel.setTextColor(mColorLit);\n            } else {\n                itemHolder.clickableLabel.setText(R.string.label);\n                itemHolder.clickableLabel.setTextColor(mColorDim);\n            }\n            itemHolder.clickableLabel.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    showLabelDialog(alarm);\n                }\n            });\n\n            if (mRepeatChecked.contains(alarm.id) || itemHolder.alarm.daysOfWeek.isRepeating()) {\n                itemHolder.repeat.setChecked(true);\n                itemHolder.repeatDays.setVisibility(View.VISIBLE);\n            } else {\n                itemHolder.repeat.setChecked(false);\n                itemHolder.repeatDays.setVisibility(View.GONE);\n            }\n            itemHolder.repeat.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    final boolean checked = ((CheckBox) view).isChecked();\n                    if (checked) {\n                        // Show days\n                        itemHolder.repeatDays.setVisibility(View.VISIBLE);\n                        mRepeatChecked.add(alarm.id);\n\n                        // Set all previously set days\n                        // or\n                        // Set all days if no previous.\n                        final int bitSet = mPreviousDaysOfWeekMap.getInt(\"\" + alarm.id);\n                        alarm.daysOfWeek.setBitSet(bitSet);\n                        if (!alarm.daysOfWeek.isRepeating()) {\n                            alarm.daysOfWeek.setDaysOfWeek(true, DAY_ORDER);\n                        }\n                        updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n                    } else {\n                        itemHolder.repeatDays.setVisibility(View.GONE);\n                        mRepeatChecked.remove(alarm.id);\n\n                        // Remember the set days in case the user wants it back.\n                        final int bitSet = alarm.daysOfWeek.getBitSet();\n                        mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id, bitSet);\n\n                        // Remove all repeat days\n                        alarm.daysOfWeek.clearAllDays();\n                    }\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            updateDaysOfWeekButtons(itemHolder, alarm.daysOfWeek);\n            for (int i = 0; i \u003c 7; i++) {\n                final int buttonIndex = i;\n\n                itemHolder.dayButtonParents[i].setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        itemHolder.dayButtons[buttonIndex].toggle();\n                        final boolean checked = itemHolder.dayButtons[buttonIndex].isChecked();\n                        int day = DAY_ORDER[buttonIndex];\n                        alarm.daysOfWeek.setDaysOfWeek(checked, day);\n                        if (checked) {\n                            turnOnDayOfWeek(itemHolder, buttonIndex);\n                        } else {\n                            turnOffDayOfWeek(itemHolder, buttonIndex);\n\n                            // See if this was the last day, if so, un-check the repeat box.\n                            if (!alarm.daysOfWeek.isRepeating()) {\n                                itemHolder.repeatDays.setVisibility(View.GONE);\n                                itemHolder.repeat.setTextColor(mColorDim);\n                                mRepeatChecked.remove(alarm.id);\n\n                                // Set history to no days, so it will be everyday when repeat is\n                                // turned back on\n                                mPreviousDaysOfWeekMap.putInt(\"\" + alarm.id,\n                                        DaysOfWeek.NO_DAYS_SET);\n                            }\n                        }\n                        asyncUpdateAlarm(alarm, false);\n                    }\n                });\n            }\n\n\n            if (!mHasVibrator) {\n                itemHolder.vibrate.setVisibility(View.INVISIBLE);\n            } else {\n                itemHolder.vibrate.setVisibility(View.VISIBLE);\n                if (!alarm.vibrate) {\n                    itemHolder.vibrate.setChecked(false);\n                    itemHolder.vibrate.setTextColor(mColorDim);\n                } else {\n                    itemHolder.vibrate.setChecked(true);\n                    itemHolder.vibrate.setTextColor(mColorLit);\n                }\n            }\n\n            itemHolder.vibrate.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    if (checked) {\n                        itemHolder.vibrate.setTextColor(mColorLit);\n                    } else {\n                        itemHolder.vibrate.setTextColor(mColorDim);\n                    }\n                    alarm.vibrate = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String ringtone;\n            final String ringtitle;\n            if (Alarm.NO_RINGTONE_URI.equals(alarm.alert)) {\n                ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n            } else {\n                ringtitle = getRingToneTitle(alarm.alert);\n                if (ringtitle != null) {\n                    ringtone = ringtitle;\n                } else {\n                    ringtone = mContext.getResources().getString(R.string.silent_alarm_summary);\n                }\n            }\n            itemHolder.ringtone.setText(ringtone);\n            itemHolder.ringtone.setContentDescription(\n                    mContext.getResources().getString(R.string.ringtone_description) + \" \"\n                            + ringtone);\n            itemHolder.ringtone.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchRingTonePicker(alarm);\n                }\n            });\n\n\n            itemHolder.increasingVolume.setVisibility(View.VISIBLE);\n            itemHolder.increasingVolume.setChecked(alarm.increasingVolume);\n            itemHolder.increasingVolume.setTextColor(\n                    alarm.increasingVolume ? mColorLit : mColorDim);\n            itemHolder.increasingVolume.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    final boolean checked = ((CheckBox) v).isChecked();\n                    //When action mode is on - simulate long click\n                    itemHolder.increasingVolume.setTextColor(checked ? mColorLit : mColorDim);\n                    alarm.increasingVolume = checked;\n                    asyncUpdateAlarm(alarm, false);\n                }\n            });\n\n            final String profile = getProfileName(alarm);\n            itemHolder.profile.setText(profile);\n            itemHolder.profile.setVisibility(isProfilesEnabled() ? View.VISIBLE : View.GONE);\n            itemHolder.profile.setContentDescription(\n                    mContext.getResources().getString(R.string.profile_description, profile));\n            itemHolder.profile.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    launchProfilePicker(alarm);\n                }\n            });\n        }\n\n        // Sets the alpha of the item except the on/off switch. This gives a visual effect\n        // for enabled/disabled alarm while leaving the on/off switch more visible\n        private void setItemAlpha(ItemHolder holder, boolean enabled) {\n            float alpha = enabled ? 1f : 0.5f;\n            holder.clock.setAlpha(alpha);\n            holder.summary.setAlpha(alpha);\n            holder.expandArea.setAlpha(alpha);\n            holder.delete.setAlpha(alpha);\n            holder.daysOfWeek.setAlpha(alpha);\n        }\n\n        private void updateDaysOfWeekButtons(ItemHolder holder, DaysOfWeek daysOfWeek) {\n            HashSet\u003cInteger\u003e setDays = daysOfWeek.getSetDays();\n            for (int i = 0; i \u003c 7; i++) {\n                if (setDays.contains(DAY_ORDER[i])) {\n                    turnOnDayOfWeek(holder, i);\n                } else {\n                    turnOffDayOfWeek(holder, i);\n                }\n            }\n        }\n\n        public void toggleSelectState(View v) {\n            // long press could be on the parent view or one of its childs, so find the parent view\n            v = getTopParent(v);\n            if (v != null) {\n                long id = ((ItemHolder)v.getTag()).alarm.id;\n                if (mSelectedAlarms.contains(id)) {\n                    mSelectedAlarms.remove(id);\n                } else {\n                    mSelectedAlarms.add(id);\n                }\n            }\n        }\n\n        private View getTopParent(View v) {\n            while (v != null \u0026\u0026 v.getId() != R.id.alarm_item) {\n                v = (View) v.getParent();\n            }\n            return v;\n        }\n\n        public int getSelectedItemsNum() {\n            return mSelectedAlarms.size();\n        }\n\n        private void turnOffDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(false);\n            holder.dayButtons[dayIndex].setTextColor(mColorDim);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoNormal);\n        }\n\n        private void turnOnDayOfWeek(ItemHolder holder, int dayIndex) {\n            holder.dayButtons[dayIndex].setChecked(true);\n            holder.dayButtons[dayIndex].setTextColor(mColorLit);\n            holder.dayButtons[dayIndex].setTypeface(mRobotoBold);\n        }\n\n\n        /**\n         * Does a read-through cache for ringtone titles.\n         *\n         * @param uri The uri of the ringtone.\n         * @return The ringtone title. {@literal null} if no matching ringtone found.\n         */\n        private String getRingToneTitle(Uri uri) {\n            // Try the cache first\n            String title = mRingtoneTitleCache.getString(uri.toString());\n            if (title == null) {\n                if (uri.equals(MultiPlayer.RANDOM_URI)) {\n                    title = mContext.getResources().getString(R.string.alarm_type_random);\n                } else {\n                    // This is slow because a media player is created during Ringtone object creation.\n                    Ringtone ringTone = RingtoneManager.getRingtone(mContext, uri);\n                    if (ringTone != null) {\n                        title = ringTone.getTitle(mContext);\n                    }\n                }\n                if (title != null) {\n                    mRingtoneTitleCache.putString(uri.toString(), title);\n                }\n            }\n            return title;\n        }\n\n        public void setNewAlarm(long alarmId) {\n            mExpanded.add(alarmId);\n        }\n\n        /**\n         * Expands the alarm for editing.\n         *\n         * @param itemHolder The item holder instance.\n         */\n        private void expandAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.add(itemHolder.alarm.id);\n            bindExpandArea(itemHolder, itemHolder.alarm);\n            // Scroll the view to make sure it is fully viewed\n            mScrollAlarmId = itemHolder.alarm.id;\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to visible so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundColor(mBackgroundColorExpanded);\n            itemHolder.expandArea.setVisibility(View.VISIBLE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(180);\n                // We need to translate the hairline up, so the height of the collapseArea\n                // needs to be measured to know how high to translate it.\n                final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n                observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                    @Override\n                    public boolean onPreDraw() {\n                        // We don't want to continue getting called for every listview drawing.\n                        if (observer.isAlive()) {\n                            observer.removeOnPreDrawListener(this);\n                        }\n                        int hairlineHeight = itemHolder.hairLine.getHeight();\n                        int collapseHeight =\n                                itemHolder.collapseExpandArea.getHeight() - hairlineHeight;\n                        itemHolder.hairLine.setTranslationY(-collapseHeight);\n                        return true;\n                    }\n                });\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to VISIBLE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * the height is set back to the starting point so it can be animated down.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    // We don't want to continue getting called for every listview drawing.\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    final int collapseHeight = itemHolder.collapseExpandArea.getHeight();\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = collapseHeight - hairlineHeight;\n\n                    // Set the height back to the start state of the animation.\n                    itemHolder.alarmItem.getLayoutParams().height = startingHeight;\n                    // To allow the expandArea to glide in with the expansion animation, set a\n                    // negative top margin, which will animate down to a margin of 0 as the height\n                    // is increased.\n                    // Note that we need to maintain the bottom margin as a fixed value (instead of\n                    // just using a listview, to allow for a flatter hierarchy) to fit the bottom\n                    // bar underneath.\n                    FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                            itemHolder.expandArea.getLayoutParams();\n                    expandParams.setMargins(0, -distance, 0, collapseHeight);\n                    itemHolder.alarmItem.requestLayout();\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(EXPAND_DURATION);\n                    animator.setInterpolator(mExpandInterpolator);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) -((1 - value) * distance), 0, collapseHeight);\n                            itemHolder.arrow.setRotation(180 * value);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * value);\n                            itemHolder.summary.setAlpha(1 - value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n                            itemHolder.arrow.setRotation(180);\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance);\n                            itemHolder.summary.setVisibility(View.GONE);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    // Return false so this draw does not occur to prevent the final frame from\n                    // being drawn for the single frame before the animations start.\n                    return false;\n                }\n            });\n        }\n\n        private boolean isAlarmExpanded(Alarm alarm) {\n            return mExpanded.contains(alarm.id);\n        }\n\n        private void collapseAlarm(final ItemHolder itemHolder, boolean animate) {\n            mExpanded.remove(itemHolder.alarm.id);\n\n            // Save the starting height so we can animate from this value.\n            final int startingHeight = itemHolder.alarmItem.getHeight();\n\n            // Set the expand area to gone so we can measure the height to animate to.\n            itemHolder.alarmItem.setBackgroundResource(mBackgroundColor);\n            itemHolder.expandArea.setVisibility(View.GONE);\n\n            if (!animate) {\n                // Set the \"end\" layout and don't do the animation.\n                itemHolder.arrow.setRotation(0);\n                itemHolder.hairLine.setTranslationY(0);\n                return;\n            }\n\n            // Add an onPreDrawListener, which gets called after measurement but before the draw.\n            // This way we can check the height we need to animate to before any drawing.\n            // Note the series of events:\n            //  * expandArea is set to GONE, which causes a layout pass\n            //  * the view is measured, and our onPreDrawListener is called\n            //  * we set up the animation using the start and end values.\n            //  * expandArea is set to VISIBLE again so it can be shown animating.\n            //  * request another layout pass.\n            //  * return false so that onDraw() is not called for the single frame before\n            //    the animations have started.\n            final ViewTreeObserver observer = mAlarmsList.getViewTreeObserver();\n            observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    if (observer.isAlive()) {\n                        observer.removeOnPreDrawListener(this);\n                    }\n\n                    // Calculate some values to help with the animation.\n                    final int endingHeight = itemHolder.alarmItem.getHeight();\n                    final int distance = endingHeight - startingHeight;\n                    int hairlineHeight = itemHolder.hairLine.getHeight();\n                    final int hairlineDistance = mCollapseExpandHeight - hairlineHeight;\n\n                    // Re-set the visibilities for the start state of the animation.\n                    itemHolder.expandArea.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setVisibility(View.VISIBLE);\n                    itemHolder.summary.setAlpha(1);\n\n                    // Set up the animator to animate the expansion.\n                    ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f)\n                            .setDuration(COLLAPSE_DURATION);\n                    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animator) {\n                            Float value = (Float) animator.getAnimatedValue();\n\n                            // For each value from 0 to 1, animate the various parts of the layout.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    (int) (value * distance + startingHeight);\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(\n                                    0, (int) (value * distance), 0, mCollapseExpandHeight);\n                            itemHolder.arrow.setRotation(180 * (1 - value));\n                            itemHolder.hairLine.setTranslationY(-hairlineDistance * (1 - value));\n                            itemHolder.summary.setAlpha(value);\n\n                            itemHolder.alarmItem.requestLayout();\n                        }\n                    });\n                    animator.setInterpolator(mCollapseInterpolator);\n                    // Set everything to their final values when the animation's done.\n                    animator.addListener(new AnimatorListener() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            // Set it back to wrap content since we'd explicitly set the height.\n                            itemHolder.alarmItem.getLayoutParams().height =\n                                    LayoutParams.WRAP_CONTENT;\n\n                            FrameLayout.LayoutParams expandParams = (FrameLayout.LayoutParams)\n                                    itemHolder.expandArea.getLayoutParams();\n                            expandParams.setMargins(0, 0, 0, mCollapseExpandHeight);\n\n                            itemHolder.expandArea.setVisibility(View.GONE);\n                            itemHolder.arrow.setRotation(0);\n                            itemHolder.hairLine.setTranslationY(0);\n                        }\n\n                        @Override\n                        public void onAnimationCancel(Animator animation) {\n                            // TODO we may have to deal with cancelations of the animation.\n                        }\n\n                        @Override\n                        public void onAnimationRepeat(Animator animation) { }\n                        @Override\n                        public void onAnimationStart(Animator animation) { }\n                    });\n                    animator.start();\n\n                    return false;\n                }\n            });\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            return 1;\n        }\n\n        private View getViewById(long id) {\n            for (int i = 0; i \u003c mList.getCount(); i++) {\n                View v = mList.getChildAt(i);\n                if (v != null) {\n                    ItemHolder h = (ItemHolder)(v.getTag());\n                    if (h != null \u0026\u0026 h.alarm.id == id) {\n                        return v;\n                    }\n                }\n            }\n            return null;\n        }\n\n        public long[] getExpandedArray() {\n            int index = 0;\n            long[] ids = new long[mExpanded.size()];\n            for (long id : mExpanded) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getSelectedAlarmsArray() {\n            int index = 0;\n            long[] ids = new long[mSelectedAlarms.size()];\n            for (long id : mSelectedAlarms) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public long[] getRepeatArray() {\n            int index = 0;\n            long[] ids = new long[mRepeatChecked.size()];\n            for (long id : mRepeatChecked) {\n                ids[index] = id;\n                index++;\n            }\n            return ids;\n        }\n\n        public Bundle getPreviousDaysOfWeekMap() {\n            return mPreviousDaysOfWeekMap;\n        }\n\n        private void buildHashSetFromArray(long[] ids, HashSet\u003cLong\u003e set) {\n            for (long id : ids) {\n                set.add(id);\n            }\n        }\n    }\n\n    private void startCreatingAlarm() {\n        // Set the \"selected\" alarm as null, and we'll create the new one when the timepicker\n        // comes back.\n        mSelectedAlarm = null;\n        AlarmUtils.showTimeEditDialog(getChildFragmentManager(),\n                null, AlarmClockFragment.this, DateFormat.is24HourFormat(getActivity()));\n    }\n\n    private static AlarmInstance setupAlarmInstance(Context context, Alarm alarm) {\n        ContentResolver cr = context.getContentResolver();\n        AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());\n        newInstance = AlarmInstance.addInstance(cr, newInstance);\n        // Register instance to state manager\n        AlarmStateManager.registerInstance(context, newInstance, true);\n        return newInstance;\n    }\n\n    private void asyncDeleteAlarm(final Alarm alarm, final View viewToRemove) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, Void\u003e deleteTask = new AsyncTask\u003cVoid, Void, Void\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                if (viewToRemove == null) {\n                    return;\n                }\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                final ListView list = mAlarmsList;\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    if (child != viewToRemove) {\n                        int position = firstVisiblePosition + i;\n                        long itemId = mAdapter.getItemId(position);\n                        mItemIdTopMap.put(itemId, child.getTop());\n                    }\n                }\n            }\n\n            @Override\n            protected Void doInBackground(Void... parameters) {\n                // Activity may be closed at this point , make sure data is still valid\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n                    AlarmStateManager.deleteAllInstances(context, alarm.id);\n                    Alarm.deleteAlarm(cr, alarm.id);\n                }\n                return null;\n            }\n        };\n        mUndoShowing = true;\n        deleteTask.execute();\n    }\n\n    private void asyncAddAlarm(final Alarm alarm) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            public synchronized void onPreExecute() {\n                final ListView list = mAlarmsList;\n                // The alarm list needs to be disabled until the animation finishes to prevent\n                // possible concurrency issues.  It becomes re-enabled after the animations have\n                // completed.\n                mAlarmsList.setEnabled(false);\n\n                // Store all of the current list view item positions in memory for animation.\n                int firstVisiblePosition = list.getFirstVisiblePosition();\n                for (int i=0; i\u003clist.getChildCount(); i++) {\n                    View child = list.getChildAt(i);\n                    int position = firstVisiblePosition + i;\n                    long itemId = mAdapter.getItemId(position);\n                    mItemIdTopMap.put(itemId, child.getTop());\n                }\n            }\n\n            @Override\n            protected AlarmInstance doInBackground(Void... parameters) {\n                if (context != null \u0026\u0026 alarm != null) {\n                    ContentResolver cr = context.getContentResolver();\n\n                    // Add alarm to db\n                    Alarm newAlarm = Alarm.addAlarm(cr, alarm);\n                    mScrollToAlarmId = newAlarm.id;\n\n                    // Create and add instance to db\n                    if (newAlarm.enabled) {\n                        return setupAlarmInstance(context, newAlarm);\n                    }\n                }\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    private void asyncUpdateAlarm(final Alarm alarm, final boolean popToast) {\n        final Context context = AlarmClockFragment.this.getActivity().getApplicationContext();\n        final AsyncTask\u003cVoid, Void, AlarmInstance\u003e updateTask =\n                new AsyncTask\u003cVoid, Void, AlarmInstance\u003e() {\n            @Override\n            protected AlarmInstance doInBackground(Void ... parameters) {\n                ContentResolver cr = context.getContentResolver();\n\n                // Dismiss all old instances\n                AlarmStateManager.deleteAllInstances(context, alarm.id);\n\n                // Update alarm\n                Alarm.updateAlarm(cr, alarm);\n                if (alarm.enabled) {\n                    return setupAlarmInstance(context, alarm);\n                }\n\n                return null;\n            }\n\n            @Override\n            protected void onPostExecute(AlarmInstance instance) {\n                if (popToast \u0026\u0026 instance != null) {\n                    AlarmUtils.popAlarmSetToast(context, instance.getAlarmTime().getTimeInMillis());\n                }\n            }\n        };\n        updateTask.execute();\n    }\n\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        hideUndoBar(true, event);\n        return false;\n    }\n}","comments":[],"name":"src/com/android/deskclock/AlarmClockFragment.java"},"src/com/android/deskclock/widget/ActionableToastBar.java":{"a":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.deskclock.widget;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorInflater;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.android.deskclock.R;\n\n/**\n * A custom {@link View} that exposes an action to the user.\n * \u003cp\u003e\n * This is a copy of packages/apps/UnifiedEmail/src/com/android/mail/ui/ActionableToastBar.java\n * with minor modifications.\n */\npublic class ActionableToastBar extends LinearLayout {\n    private boolean mHidden = false;\n    private Animator mShowAnimation;\n    private Animator mHideAnimation;\n    private final int mBottomMarginSizeInConversation;\n\n    /** Icon for the description. */\n    private ImageView mActionDescriptionIcon;\n    /** The clickable view */\n    private View mActionButton;\n    /** Icon for the action button. */\n    private View mActionIcon;\n    /** The view that contains the description. */\n    private TextView mActionDescriptionView;\n    /** The view that contains the text for the action button. */\n    private TextView mActionText;\n    //private ToastBarOperation mOperation;\n\n    public ActionableToastBar(Context context) {\n        this(context, null);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mBottomMarginSizeInConversation = context.getResources().getDimensionPixelSize(\n                R.dimen.toast_bar_bottom_margin_in_conversation);\n        LayoutInflater.from(context).inflate(R.layout.actionable_toast_row, this, true);\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        mActionDescriptionIcon = (ImageView) findViewById(R.id.description_icon);\n        mActionDescriptionView = (TextView) findViewById(R.id.description_text);\n        mActionButton = findViewById(R.id.action_button);\n        mActionIcon = findViewById(R.id.action_icon);\n        mActionText = (TextView) findViewById(R.id.action_text);\n    }\n\n    /**\n     * Tells the view that it will be appearing in the conversation pane\n     * and should adjust its layout parameters accordingly.\n     * @param isInConversationMode true if the view will be shown in the conversation view\n     */\n    public void setConversationMode(boolean isInConversationMode) {\n        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams();\n        params.bottomMargin = isInConversationMode ? mBottomMarginSizeInConversation : 0;\n        setLayoutParams(params);\n    }\n\n    /**\n     * Displays the toast bar and makes it visible. Allows the setting of\n     * parameters to customize the display.\n     * @param listener performs some action when the action button is clicked\n     * @param descriptionIconResourceId resource ID for the description icon or\n     * 0 if no icon should be shown\n     * @param descriptionText a description text to show in the toast bar\n     * @param showActionIcon if true, the action button icon should be shown\n     * @param actionTextResource resource ID for the text to show in the action button\n     * @param replaceVisibleToast if true, this toast should replace any currently visible toast.\n     * Otherwise, skip showing this toast.\n     */\n    public void show(final ActionClickedListener listener, int descriptionIconResourceId,\n            CharSequence descriptionText, boolean showActionIcon, int actionTextResource,\n            boolean replaceVisibleToast) {\n\n        if (!mHidden \u0026\u0026 !replaceVisibleToast) {\n            return;\n        }\n\n        mActionButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View widget) {\n                if (listener != null) {\n                    listener.onActionClicked();\n                }\n                hide(true);\n            }\n        });\n\n        // Set description icon.\n        if (descriptionIconResourceId == 0) {\n            mActionDescriptionIcon.setVisibility(GONE);\n        } else {\n            mActionDescriptionIcon.setVisibility(VISIBLE);\n            mActionDescriptionIcon.setImageResource(descriptionIconResourceId);\n        }\n\n        mActionDescriptionView.setText(descriptionText);\n        mActionIcon.setVisibility(showActionIcon ? VISIBLE : GONE);\n        mActionText.setText(actionTextResource);\n\n        mHidden = false;\n        getShowAnimation().start();\n    }\n\n    /**\n     * Hides the view and resets the state.\n     */\n    public void hide(boolean animate) {\n        // Prevent multiple call to hide.\n        // Also prevent hiding if show animation is going on.\n        if (!mHidden \u0026\u0026 !getShowAnimation().isRunning()) {\n            mHidden = true;\n            if (getVisibility() == View.VISIBLE) {\n                mActionDescriptionView.setText(\"\");\n                mActionButton.setOnClickListener(null);\n                // Hide view once it's clicked.\n                if (animate) {\n                    getHideAnimation().start();\n                } else {\n                    setAlpha(0);\n                    setVisibility(View.GONE);\n                }\n            }\n        }\n    }\n\n    private Animator getShowAnimation() {\n        if (mShowAnimation == null) {\n            mShowAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_in);\n            mShowAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    // There is a tiny change that and hide animation could have finished right\n                    // before the show animation finished.  In that case, the hide will mark the\n                    // view as GONE.  We need to make sure the last one wins.\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n            });\n            mShowAnimation.setTarget(this);\n        }\n        return mShowAnimation;\n    }\n\n    private Animator getHideAnimation() {\n        if (mHideAnimation == null) {\n            mHideAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_out);\n            mHideAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    setVisibility(View.GONE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n            });\n            mHideAnimation.setTarget(this);\n        }\n        return mHideAnimation;\n    }\n\n    public boolean isEventInToastBar(MotionEvent event) {\n        if (!isShown()) {\n            return false;\n        }\n        int[] xy = new int[2];\n        float x = event.getX();\n        float y = event.getY();\n        getLocationOnScreen(xy);\n        return (x \u003e xy[0] \u0026\u0026 x \u003c (xy[0] + getWidth()) \u0026\u0026 y \u003e xy[1] \u0026\u0026 y \u003c xy[1] + getHeight());\n    }\n\n    /**\n     * Classes that wish to perform some action when the action button is clicked\n     * should implement this interface.\n     */\n    public interface ActionClickedListener {\n        public void onActionClicked();\n    }\n}","b":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.deskclock.widget;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorInflater;\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.FrameLayout;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.android.deskclock.R;\n\n/**\n * A custom {@link View} that exposes an action to the user.\n * \u003cp\u003e\n * This is a copy of packages/apps/UnifiedEmail/src/com/android/mail/ui/ActionableToastBar.java\n * with minor modifications.\n */\npublic class ActionableToastBar extends LinearLayout {\n    private boolean mHidden = false;\n    private Animator mShowAnimation;\n    private Animator mHideAnimation;\n    private final int mBottomMarginSizeInConversation;\n\n    /** Icon for the description. */\n    private ImageView mActionDescriptionIcon;\n    /** The clickable view */\n    private View mActionButton;\n    /** Icon for the action button. */\n    private ImageView mActionIcon;\n    /** The view that contains the description. */\n    private TextView mActionDescriptionView;\n    /** The view that contains the text for the action button. */\n    private TextView mActionText;\n    //private ToastBarOperation mOperation;\n\n    public ActionableToastBar(Context context) {\n        this(context, null);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public ActionableToastBar(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        mBottomMarginSizeInConversation = context.getResources().getDimensionPixelSize(\n                R.dimen.toast_bar_bottom_margin_in_conversation);\n        LayoutInflater.from(context).inflate(R.layout.actionable_toast_row, this, true);\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n\n        mActionDescriptionIcon = (ImageView) findViewById(R.id.description_icon);\n        mActionDescriptionView = (TextView) findViewById(R.id.description_text);\n        mActionButton = findViewById(R.id.action_button);\n        mActionIcon = (ImageView)findViewById(R.id.action_icon);\n        mActionText = (TextView) findViewById(R.id.action_text);\n    }\n\n    /**\n     * Tells the view that it will be appearing in the conversation pane\n     * and should adjust its layout parameters accordingly.\n     * @param isInConversationMode true if the view will be shown in the conversation view\n     */\n    public void setConversationMode(boolean isInConversationMode) {\n        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) getLayoutParams();\n        params.bottomMargin = isInConversationMode ? mBottomMarginSizeInConversation : 0;\n        setLayoutParams(params);\n    }\n\n    /**\n     * Displays the toast bar and makes it visible. Allows the setting of\n     * parameters to customize the display.\n     * @param listener performs some action when the action button is clicked\n     * @param descriptionIconResourceId resource ID for the description icon or\n     * 0 if no icon should be shown\n     * @param descriptionText a description text to show in the toast bar\n     * @param showActionIcon if true, the action button icon should be shown\n     * @param actionTextResource resource ID for the text to show in the action button\n     * @param replaceVisibleToast if true, this toast should replace any currently visible toast.\n     * Otherwise, skip showing this toast.\n     */\n    public void show(final ActionClickedListener listener, int descriptionIconResourceId,\n            CharSequence descriptionText, boolean showActionIcon, int actionIconResourceId,\n            int actionTextResource, boolean replaceVisibleToast) {\n\n        if (!mHidden \u0026\u0026 !replaceVisibleToast) {\n            return;\n        }\n\n        mActionButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View widget) {\n                if (listener != null) {\n                    listener.onActionClicked();\n                }\n                hide(true);\n            }\n        });\n\n        // Set description icon.\n        if (descriptionIconResourceId == 0) {\n            mActionDescriptionIcon.setVisibility(GONE);\n        } else {\n            mActionDescriptionIcon.setVisibility(VISIBLE);\n            mActionDescriptionIcon.setImageResource(descriptionIconResourceId);\n        }\n\n        // Set action icon\n        if (showActionIcon) {\n            mActionIcon.setVisibility(VISIBLE);\n            mActionIcon.setImageResource(actionIconResourceId == 0 ?\n                    R.drawable.ic_menu_revert_holo_dark : actionIconResourceId);\n        } else {\n            mActionIcon.setVisibility(GONE);\n        }\n\n        mActionDescriptionView.setText(descriptionText);\n        if (actionTextResource == 0) {\n            mActionText.setVisibility(GONE);\n        } else {\n            mActionText.setVisibility(VISIBLE);\n            mActionText.setText(actionTextResource);\n        }\n\n        mHidden = false;\n        getShowAnimation().start();\n    }\n\n    /**\n     * Hides the view and resets the state.\n     */\n    public void hide(boolean animate) {\n        // Prevent multiple call to hide.\n        // Also prevent hiding if show animation is going on.\n        if (!mHidden \u0026\u0026 !getShowAnimation().isRunning()) {\n            mHidden = true;\n            if (getVisibility() == View.VISIBLE) {\n                mActionDescriptionView.setText(\"\");\n                mActionButton.setOnClickListener(null);\n                // Hide view once it's clicked.\n                if (animate) {\n                    getHideAnimation().start();\n                } else {\n                    setAlpha(0);\n                    setVisibility(View.GONE);\n                }\n            }\n        }\n    }\n\n    private Animator getShowAnimation() {\n        if (mShowAnimation == null) {\n            mShowAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_in);\n            mShowAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    // There is a tiny change that and hide animation could have finished right\n                    // before the show animation finished.  In that case, the hide will mark the\n                    // view as GONE.  We need to make sure the last one wins.\n                    setVisibility(View.VISIBLE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n            });\n            mShowAnimation.setTarget(this);\n        }\n        return mShowAnimation;\n    }\n\n    private Animator getHideAnimation() {\n        if (mHideAnimation == null) {\n            mHideAnimation = AnimatorInflater.loadAnimator(getContext(),\n                    R.anim.fade_out);\n            mHideAnimation.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n                }\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    setVisibility(View.GONE);\n                }\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                }\n            });\n            mHideAnimation.setTarget(this);\n        }\n        return mHideAnimation;\n    }\n\n    public boolean isEventInToastBar(MotionEvent event) {\n        if (!isShown()) {\n            return false;\n        }\n        int[] xy = new int[2];\n        float x = event.getX();\n        float y = event.getY();\n        getLocationOnScreen(xy);\n        return (x \u003e xy[0] \u0026\u0026 x \u003c (xy[0] + getWidth()) \u0026\u0026 y \u003e xy[1] \u0026\u0026 y \u003c xy[1] + getHeight());\n    }\n\n    /**\n     * Classes that wish to perform some action when the action button is clicked\n     * should implement this interface.\n     */\n    public interface ActionClickedListener {\n        public void onActionClicked();\n    }\n}","comments":[],"name":"src/com/android/deskclock/widget/ActionableToastBar.java"}}}],"comments":[{"author":{"accountId":8048,"email":"str3l0k@gmail.com","name":"Vladimir Vainer","username":"ferreus"},"date":"2014-05-11T15:36:54.000Z","id":"da0c15f0_4895c73e","message":"Uploaded patch set 1.","revisionNumber":1},{"author":{"accountId":8048,"email":"str3l0k@gmail.com","name":"Vladimir Vainer","username":"ferreus"},"date":"2014-05-11T15:42:24.000Z","id":"da0c15f0_28921358","message":"Patch Set 1:\n\nI was late to work, because I've set alarm sound to silent, than forgot about it, and when I went to the app to check my alarms - I wasn't made aware of the silent alarm volume.\n\nWon't happen again :)","revisionNumber":1},{"author":{"accountId":4550,"email":"mikeioannina@gmail.com","name":"Michael Bestas","username":"mikeioannina"},"date":"2014-05-23T22:35:16.000Z","id":"da0c15f0_e1bae8bf","message":"Patch Set 1:\n\nHow can you trigger this warning?","revisionNumber":1},{"author":{"accountId":8048,"email":"str3l0k@gmail.com","name":"Vladimir Vainer","username":"ferreus"},"date":"2014-05-24T17:41:32.000Z","id":"da0c15f0_c106c41f","message":"Patch Set 1:\n\n1. Set Alarm Sound Volume to Silent\n2. Open DesckClock app\n3. Swipe to Alarms tab\n\nThe message is shown on the screen, notifying that the alarm sound is silent.","revisionNumber":1},{"author":{"accountId":4550,"email":"mikeioannina@gmail.com","name":"Michael Bestas","username":"mikeioannina"},"date":"2014-05-24T19:22:23.000Z","id":"da0c15f0_fc4c4f78","message":"Uploaded patch set 2.","revisionNumber":2},{"author":{"accountId":4550,"email":"mikeioannina@gmail.com","name":"Michael Bestas","username":"mikeioannina"},"date":"2014-05-24T19:24:04.000Z","id":"da0c15f0_3c57e703","message":"Patch Set 2:\n\n(1 comment)\n\nJust fixed some code style issues. Please check my inline comment","revisionNumber":2},{"author":{"accountId":8048,"email":"str3l0k@gmail.com","name":"Vladimir Vainer","username":"ferreus"},"date":"2014-05-26T18:35:28.000Z","id":"da0c15f0_f3559dc6","message":"Patch Set 2:\n\nNeed help with git :(\nHow do i use you patch + modify the icon and then upload the change?\n\nI've kinda new to this.\n\nI've tried pulling you change using the gerrit supplied command: git pull http://review.cyanogenmod.org/CyanogenMod/android_packages_apps_DeskClock refs/changes/24/63824/2\n\nThen i fixed the merge conflicts, committed, and now i can't ammend my previous commit.\n\n\nSorry to bother you with this noob stuff.\nCan you help me?\nI'm also totally cool with you making the icon change yourself, but i'd like to know how to work such cases in the future. \nThanks.","revisionNumber":2},{"author":{"accountId":848,"email":"ciwrl@cyanogenmod.com","name":"Abhisek Devkota","username":"Ciwrly"},"date":"2014-05-26T20:14:16.000Z","id":"da0c15f0_33ba75e2","message":"Uploaded patch set 3.","revisionNumber":3},{"author":{"accountId":848,"email":"ciwrl@cyanogenmod.com","name":"Abhisek Devkota","username":"Ciwrly"},"date":"2014-05-26T20:16:11.000Z","id":"da0c15f0_13bf71d1","message":"Patch Set 3: Verified+1 Code-Review+1\n\nVlad, use the 'cherry-pick' option listed in that box instead of pull. Will yield something like the following \n\ngit fetch ssh://Ciwrly@review.cyanogenmod.org:29418/CyanogenMod/android_packages_apps_DeskClock refs/changes/24/63824/2 \u0026\u0026 git cherry-pick FETCH_HEAD\n\nThen, make your change. Once the change is made: 'git add' it as normal, then 'git commit --amend' to tie it back to this commit. Finally, 'repo upload' your adjustments to this commit.","revisionNumber":3},{"author":{"accountId":8048,"email":"str3l0k@gmail.com","name":"Vladimir Vainer","username":"ferreus"},"date":"2014-05-26T20:20:45.000Z","id":"da0c15f0_73b4edf1","message":"Patch Set 3:\n\nCool, Thanks.","revisionNumber":3},{"author":{"accountId":1579,"email":"fuzzzzzzzzzzzzzzzzzz@gmail.com","name":"Taichi Nishimura","username":"fuzz"},"date":"2014-05-28T07:31:27.000Z","id":"da0c15f0_468805e8","message":"Patch Set 3: Code-Review+1\n\nworks as advertised","revisionNumber":3},{"author":{"accountId":4449,"email":"bochenski.piotr@gmail.com","name":"Piotr Bochenski","username":"pit1337"},"date":"2014-05-28T07:45:04.000Z","id":"da0c15f0_a66da134","message":"Patch Set 3: Code-Review+1\n\nCool stuff","revisionNumber":3},{"author":{"accountId":9803,"email":"bengr6@gmail.com","name":"Ben Grynhaus","username":"bengr"},"date":"2014-05-28T07:53:26.000Z","id":"da0c15f0_866a1d19","message":"Patch Set 3: Code-Review+1","revisionNumber":3},{"author":{"accountId":848,"email":"ciwrl@cyanogenmod.com","name":"Abhisek Devkota","username":"Ciwrly"},"date":"2014-05-28T23:51:32.000Z","id":"da0c15f0_a9dbb2ec","message":"Patch Set 3: Code-Review+2","revisionNumber":3},{"author":{"accountId":848,"email":"ciwrl@cyanogenmod.com","name":"Abhisek Devkota","username":"Ciwrly"},"date":"2014-05-28T23:51:33.000Z","id":"da0c15f0_89d86ef1","message":"Change has been successfully merged into the git repository.","revisionNumber":3}]}</script><script type="text/javascript">(function() {
  $(function() {
    React.renderComponent(ChangeView(changeViewProps), document.getElementById('ChangeViewRoot'));
  });

}).call(this);
</script></body></html>
