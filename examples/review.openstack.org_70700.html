<!DOCTYPE html><html><head><title>70700 Add HA support to the l3 agent | review.openstack.org</title><link data-turbolinks-track="true" href="application-1fc39d1097be6574c8b3760190c48582.css" media="all" rel="stylesheet" /><script data-turbolinks-track="true" src="application-0ba414835c483e6765f1f6bcb8bbf814.js"></script><meta content="authenticity_token" name="csrf-param" />
<meta content="07bG4l3GiD+Rf639R80HeqhOc/cMwgKkomo6HeD6szs=" name="csrf-token" /></head><body><div id="ChangeViewRoot"></div><script>var changeViewProps = {"branch":"master","changeId":"I83f2a5d2af42164c42773b385ba7b00872eed54e","createdAt":"2014-02-03T12:12:00.000Z","host":{"baseUrl":"https://review.openstack.org"},"notice":null,"number":70700,"owner":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"project":{"name":"openstack/neutron"},"subject":"Add HA support to the l3 agent","updatedAt":"2014-06-01T07:29:36.799Z","revisions":[{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"ebf62df5efb278b182437f15bb9556adc80892ad","revisionId":1,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     ebf62df5 (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-01-21 16:32:17 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-02-03 13:11:04 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"neutron/agent/l3_agent.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2012 Nicira Networks, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Dan Wendlandt, Nicira, Inc\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.StrOpt('interface_driver',\n                   help=_(\"The driver used to manage the virtual \"\n                          \"interface.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.BoolOpt('use_namespaces', default=True,\n                    help=_(\"Allow overlapping IP.\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n        if self.conf.use_namespaces:\n            self._destroy_router_namespaces(self.conf.router_id)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _destroy_router_namespaces(self, only_router_id=None):\n        \"\"\"Destroy router namespaces on the host to eliminate all stale\n        linux devices, iptables rules, and namespaces.\n\n        If only_router_id is passed, only destroy single namespace, to allow\n        for multiple l3 agents on the same host, without stepping on each\n        other's toes on init.  This only makes sense if only_router_id is set.\n        \"\"\"\n        root_ip = ip_lib.IPWrapper(self.root_helper)\n        for ns in root_ip.get_namespaces(self.root_helper):\n            if ns.startswith(NS_PREFIX):\n                router_id = ns[len(NS_PREFIX):]\n                if only_router_id and not only_router_id == router_id:\n                    continue\n\n                if self.conf.enable_metadata_proxy:\n                    self._destroy_metadata_proxy(router_id, ns)\n\n                try:\n                    self._destroy_router_namespace(ns)\n                except Exception:\n                    LOG.exception(_(\"Failed deleting namespace '%s'\"), ns)\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            if e.exc_type == 'TooManyExternalNetworks':\n                msg = _(\n                    \"The 'gateway_external_network_id' option must be \"\n                    \"configured for this agent as Neutron has more than \"\n                    \"one external network.\")\n                raise Exception(msg)\n            else:\n                raise\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process DNAT rules for floating IPs\n        if ex_gw_port:\n            self.process_router_floating_ips(ri, ex_gw_port)\n\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n        self.routes_updated(ri)\n        ri.iptables_manager.defer_apply_off()\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ips(self, ri, ex_gw_port):\n        \"\"\"Configure the router's floating IPs\n        Configures floating ips in iptables and on the router's gateway device.\n\n        Cleans up floating ips that should not longer be configured.\n        \"\"\"\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                self._send_gratuitous_arp_packet(ri, interface_name, fip_ip)\n\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(ex_gw_port['network_id'],\n                             ex_gw_port['id'], interface_name,\n                             ex_gw_port['mac_address'],\n                             bridge=self.conf.external_network_bridge,\n                             namespace=ri.ns_name(),\n                             prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n            else:\n                utils.execute(cmd, check_exit_code=False,\n                              root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name,\n                               bridge=self.conf.external_network_bridge,\n                               namespace=ri.ns_name(),\n                               prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2012 Nicira Networks, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Dan Wendlandt, Nicira, Inc\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME = 'ha_vrouter'\nHA_VIRTUAL_ROUTER_GROUP = 'ha_group'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path='/tmp'):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        if self.is_ha():\n            self.keepalived_manager = keepalived_manager.KeepalivedManager(\n                router_id,\n                keepalived_manager.KeepalivedConf(),\n                conf_path=ha_confs_path,\n                namespace=self.ns_name(),\n                root_helper=root_helper)\n            self.keepalived_notifiers = (\n                keepalived_manager.KeepalivedNotifyScriptManager(router_id))\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.StrOpt('interface_driver',\n                   help=_(\"The driver used to manage the virtual \"\n                          \"interface.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.BoolOpt('use_namespaces', default=True,\n                    help=_(\"Allow overlapping IP.\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n        if self.conf.use_namespaces:\n            self._destroy_router_namespaces(self.conf.router_id)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _destroy_router_namespaces(self, only_router_id=None):\n        \"\"\"Destroy router namespaces on the host to eliminate all stale\n        linux devices, iptables rules, and namespaces.\n\n        If only_router_id is passed, only destroy single namespace, to allow\n        for multiple l3 agents on the same host, without stepping on each\n        other's toes on init.  This only makes sense if only_router_id is set.\n        \"\"\"\n        root_ip = ip_lib.IPWrapper(self.root_helper)\n        for ns in root_ip.get_namespaces(self.root_helper):\n            if ns.startswith(NS_PREFIX):\n                router_id = ns[len(NS_PREFIX):]\n                if only_router_id and not only_router_id == router_id:\n                    continue\n\n                if self.conf.enable_metadata_proxy:\n                    self._destroy_metadata_proxy(router_id, ns)\n\n                try:\n                    self._destroy_router_namespace(ns)\n                except Exception:\n                    LOG.exception(_(\"Failed deleting namespace '%s'\"), ns)\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            if e.exc_type == 'TooManyExternalNetworks':\n                msg = _(\n                    \"The 'gateway_external_network_id' option must be \"\n                    \"configured for this agent as Neutron has more than \"\n                    \"one external network.\")\n                raise Exception(msg)\n            else:\n                raise\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP)\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd))\n\n            cmd = ['kill', pid_file]\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_config(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_config(self, ri):\n        config = ri.keepalived_manager.config\n        group = keepalived_manager.KeepalivedGroup(HA_VIRTUAL_ROUTER_GROUP)\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived_manager.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME, 'BACKUP', interface_name,\n            ri.router['ha_vr_id'], ri.ha_port['priority'], nopreempt=True)\n        instance.add_track_interface(interface_name)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n\n    def _destroy_keepalived(self, ri):\n        ri.keepalived_manager.kill()\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process DNAT rules for floating IPs\n        if ex_gw_port:\n            self.process_router_floating_ips(ri, ex_gw_port)\n\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        self.routes_updated(ri)\n        ri.iptables_manager.defer_apply_off()\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ips(self, ri, ex_gw_port):\n        \"\"\"Configure the router's floating IPs\n        Configures floating ips in iptables and on the router's gateway device.\n\n        Cleans up floating ips that should not longer be configured.\n        \"\"\"\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                if ri.is_ha():\n                    instance = ri.keepalived_manager.config.get_instance(\n                        HA_VIRTUAL_ROUTER_NAME)\n                    vip_address = keepalived_manager.KeepalivedVipAddress(\n                        ip_cidr, interface_name)\n                    instance.add_vip_address(vip_address)\n                else:\n                    net = netaddr.IPNetwork(ip_cidr)\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                if ri.is_ha():\n                    instance = ri.keepalived_manager.config.get_instance(\n                        HA_VIRTUAL_ROUTER_NAME)\n                    vip_address = keepalived_manager.KeepalivedVipAddress(\n                        ip_cidr, interface_name)\n                    instance.remove_vip_address(vip_address)\n                else:\n                    net = netaddr.IPNetwork(ip_cidr)\n                    device.addr.delete(net.version, ip_cidr)\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(ex_gw_port['network_id'],\n                             ex_gw_port['id'], interface_name,\n                             ex_gw_port['mac_address'],\n                             bridge=self.conf.external_network_bridge,\n                             namespace=ri.ns_name(),\n                             prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            instance = ri.keepalived_manager.config.get_instance(\n                HA_VIRTUAL_ROUTER_NAME)\n            vip_address = keepalived_manager.KeepalivedVipAddress(\n                ex_gw_port['ip_cidr'], interface_name)\n            instance.add_vip_address(vip_address)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME)\n                vroute = keepalived_manager.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.add_virtual_route(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                if self.conf.use_namespaces:\n                    ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                                  namespace=ri.ns_name())\n                    ip_wrapper.netns.execute(cmd, check_exit_code=False)\n                else:\n                    utils.execute(cmd, check_exit_code=False,\n                                  root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME)\n                instance.remove_vip_addresses_by_interface(interface_name)\n\n            self.driver.unplug(interface_name,\n                               bridge=self.conf.external_network_bridge,\n                               namespace=ri.ns_name(),\n                               prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            instance = ri.keepalived_manager.config.get_instance(\n                HA_VIRTUAL_ROUTER_NAME)\n            vip_address = keepalived_manager.KeepalivedVipAddress(\n                ip_address, interface_name)\n            instance.add_vip_address(vip_address)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME)\n                instance.remove_vip_adresses_by_interface(interface_name)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def routers_created(self, context, routers):\n        LOG.debug(_('Got routers created notification :%s'), routers)\n        if routers:\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nicira, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.process_router_floating_ips = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': _uuid(),\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ips.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_add(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remap(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.2')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_namespace(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.mock_ip.get_namespaces.return_value = ['qrouter-foo',\n                                                    'qrouter-bar']\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces()\n\n        self.assertEqual(pm.disable.call_count, 2)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 2)\n\n    def test_destroy_namespace_with_router_id(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.conf.router_id = _uuid()\n\n        namespaces = ['qrouter-foo', 'qrouter-' + self.conf.router_id]\n\n        self.mock_ip.get_namespaces.return_value = namespaces\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces(self.conf.router_id)\n\n        self.assertEqual(pm.disable.call_count, 1)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 1)\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nicira, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha', return_value=False)\n        self.is_ha = self.is_ha_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '172.31.255.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '172.31.255.0/24',\n                            'gateway_ip': '172.31.255.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.process_router_floating_ips = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': _uuid(),\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ips.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['172.31.255.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '172.31.255.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['vrrp_sync_group ha_group {',\n                        '\\tgroup {',\n                        '\\t\\tha_vrouter',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance ha_vrouter {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t35.4.0.4 dev ' + int_iface,\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/tmp/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-f',\n                        '/tmp/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/tmp/ha_confs/' + ri.router_id +\n                        '/keepalived.pid', '-c',\n                        '/tmp/ha_confs/' + ri.router_id +\n                        '/checkers.pid', '-r',\n                        '/tmp/ha_confs/' + ri.router_id +\n                        '/vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_ha_router_added(ri)\n        agent.process_router(ri)\n\n        port_id = _uuid()\n\n        ri.router = router\n\n        self.device_exists.return_value = True\n\n        router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n            port_id=port_id)\n\n        agent.process_router(ri)\n\n        self.mock_driver.unplug.reset_mock()\n\n        del router[l3_constants.HA_INTERFACE_KEY]\n\n        ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n        agent.process_router(ri)\n        agent.process_ha_router_removed(ri)\n\n        expected = [mock.call(ha_iface, prefix='ha-', namespace=ri.ns_name())]\n        self.mock_driver.unplug.assert_has_calls(expected)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_add(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remap(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.2')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_namespace(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.mock_ip.get_namespaces.return_value = ['qrouter-foo',\n                                                    'qrouter-bar']\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces()\n\n        self.assertEqual(pm.disable.call_count, 2)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 2)\n\n    def test_destroy_namespace_with_router_id(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.conf.router_id = _uuid()\n\n        namespaces = ['qrouter-foo', 'qrouter-' + self.conf.router_id]\n\n        self.mock_ip.get_namespaces.return_value = namespaces\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces(self.conf.router_id)\n\n        self.assertEqual(pm.disable.call_count, 1)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 1)\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.makedirs'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  makedirs,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n                self.assertEqual('/tmp/' + router_id + '/notify_master.sh', m)\n                self.assertEqual('/tmp/' + router_id + '/notify_backup.sh', b)\n                self.assertEqual('/tmp/' + router_id + '/notify_fault.sh', f)\n                replace.assert_has_call_with('/tmp/' + ri.router_id +\n                                             '/notify_master.sh',\n                                             mock.ANY)\n                replace.assert_has_call_with('/tmp/' + ri.router_id +\n                                             '/notify_backup.sh',\n                                             mock.ANY)\n                replace.assert_has_call_with('/tmp/' + ri.router_id +\n                                             '/notify_fault.sh',\n                                             mock.ANY)\n        finally:\n            self.external_process_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"8539b1aef24959c440ea35a835e7a27723adabf0","revisionId":2,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     8539b1ae (Add L3 VRRP HA base classes)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-01-21 16:32:17 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-02-03 17:50:45 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"neutron/agent/l3_agent.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2012 Nicira Networks, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Dan Wendlandt, Nicira, Inc\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.StrOpt('interface_driver',\n                   help=_(\"The driver used to manage the virtual \"\n                          \"interface.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.BoolOpt('use_namespaces', default=True,\n                    help=_(\"Allow overlapping IP.\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n        if self.conf.use_namespaces:\n            self._destroy_router_namespaces(self.conf.router_id)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _destroy_router_namespaces(self, only_router_id=None):\n        \"\"\"Destroy router namespaces on the host to eliminate all stale\n        linux devices, iptables rules, and namespaces.\n\n        If only_router_id is passed, only destroy single namespace, to allow\n        for multiple l3 agents on the same host, without stepping on each\n        other's toes on init.  This only makes sense if only_router_id is set.\n        \"\"\"\n        root_ip = ip_lib.IPWrapper(self.root_helper)\n        for ns in root_ip.get_namespaces(self.root_helper):\n            if ns.startswith(NS_PREFIX):\n                router_id = ns[len(NS_PREFIX):]\n                if only_router_id and not only_router_id == router_id:\n                    continue\n\n                if self.conf.enable_metadata_proxy:\n                    self._destroy_metadata_proxy(router_id, ns)\n\n                try:\n                    self._destroy_router_namespace(ns)\n                except Exception:\n                    LOG.exception(_(\"Failed deleting namespace '%s'\"), ns)\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            if e.exc_type == 'TooManyExternalNetworks':\n                msg = _(\n                    \"The 'gateway_external_network_id' option must be \"\n                    \"configured for this agent as Neutron has more than \"\n                    \"one external network.\")\n                raise Exception(msg)\n            else:\n                raise\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process DNAT rules for floating IPs\n        if ex_gw_port:\n            self.process_router_floating_ips(ri, ex_gw_port)\n\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n        self.routes_updated(ri)\n        ri.iptables_manager.defer_apply_off()\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ips(self, ri, ex_gw_port):\n        \"\"\"Configure the router's floating IPs\n        Configures floating ips in iptables and on the router's gateway device.\n\n        Cleans up floating ips that should not longer be configured.\n        \"\"\"\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                self._send_gratuitous_arp_packet(ri, interface_name, fip_ip)\n\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(ex_gw_port['network_id'],\n                             ex_gw_port['id'], interface_name,\n                             ex_gw_port['mac_address'],\n                             bridge=self.conf.external_network_bridge,\n                             namespace=ri.ns_name(),\n                             prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n            else:\n                utils.execute(cmd, check_exit_code=False,\n                              root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name,\n                               bridge=self.conf.external_network_bridge,\n                               namespace=ri.ns_name(),\n                               prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2012 Nicira Networks, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Dan Wendlandt, Nicira, Inc\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME = 'ha_vrouter'\nHA_VIRTUAL_ROUTER_GROUP = 'ha_group'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        if self.is_ha():\n            self.keepalived_manager = keepalived_manager.KeepalivedManager(\n                router_id,\n                keepalived_manager.KeepalivedConf(),\n                conf_path=ha_confs_path,\n                namespace=self.ns_name(),\n                root_helper=root_helper)\n            self.keepalived_notifiers = (\n                keepalived_manager.KeepalivedNotifyScriptManager(router_id))\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.StrOpt('interface_driver',\n                   help=_(\"The driver used to manage the virtual \"\n                          \"interface.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.BoolOpt('use_namespaces', default=True,\n                    help=_(\"Allow overlapping IP.\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n        if self.conf.use_namespaces:\n            self._destroy_router_namespaces(self.conf.router_id)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _destroy_router_namespaces(self, only_router_id=None):\n        \"\"\"Destroy router namespaces on the host to eliminate all stale\n        linux devices, iptables rules, and namespaces.\n\n        If only_router_id is passed, only destroy single namespace, to allow\n        for multiple l3 agents on the same host, without stepping on each\n        other's toes on init.  This only makes sense if only_router_id is set.\n        \"\"\"\n        root_ip = ip_lib.IPWrapper(self.root_helper)\n        for ns in root_ip.get_namespaces(self.root_helper):\n            if ns.startswith(NS_PREFIX):\n                router_id = ns[len(NS_PREFIX):]\n                if only_router_id and not only_router_id == router_id:\n                    continue\n\n                if self.conf.enable_metadata_proxy:\n                    self._destroy_metadata_proxy(router_id, ns)\n\n                try:\n                    self._destroy_router_namespace(ns)\n                except Exception:\n                    LOG.exception(_(\"Failed deleting namespace '%s'\"), ns)\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            if e.exc_type == 'TooManyExternalNetworks':\n                msg = _(\n                    \"The 'gateway_external_network_id' option must be \"\n                    \"configured for this agent as Neutron has more than \"\n                    \"one external network.\")\n                raise Exception(msg)\n            else:\n                raise\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP)\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd))\n\n            cmd = ['kill', pid_file]\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_config(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_config(self, ri):\n        config = ri.keepalived_manager.config\n        group = keepalived_manager.KeepalivedGroup(HA_VIRTUAL_ROUTER_GROUP)\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived_manager.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME, 'BACKUP', interface_name,\n            ri.router['ha_vr_id'], ri.ha_port['priority'], nopreempt=True)\n        instance.add_track_interface(interface_name)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n\n    def _destroy_keepalived(self, ri):\n        ri.keepalived_manager.kill()\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process DNAT rules for floating IPs\n        if ex_gw_port:\n            self.process_router_floating_ips(ri, ex_gw_port)\n\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        self.routes_updated(ri)\n        ri.iptables_manager.defer_apply_off()\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ips(self, ri, ex_gw_port):\n        \"\"\"Configure the router's floating IPs\n        Configures floating ips in iptables and on the router's gateway device.\n\n        Cleans up floating ips that should not longer be configured.\n        \"\"\"\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                if ri.is_ha():\n                    instance = ri.keepalived_manager.config.get_instance(\n                        HA_VIRTUAL_ROUTER_NAME)\n                    vip_address = keepalived_manager.KeepalivedVipAddress(\n                        ip_cidr, interface_name)\n                    instance.add_vip_address(vip_address)\n                else:\n                    net = netaddr.IPNetwork(ip_cidr)\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                if ri.is_ha():\n                    instance = ri.keepalived_manager.config.get_instance(\n                        HA_VIRTUAL_ROUTER_NAME)\n                    vip_address = keepalived_manager.KeepalivedVipAddress(\n                        ip_cidr, interface_name)\n                    instance.remove_vip_address(vip_address)\n                else:\n                    net = netaddr.IPNetwork(ip_cidr)\n                    device.addr.delete(net.version, ip_cidr)\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(ex_gw_port['network_id'],\n                             ex_gw_port['id'], interface_name,\n                             ex_gw_port['mac_address'],\n                             bridge=self.conf.external_network_bridge,\n                             namespace=ri.ns_name(),\n                             prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            instance = ri.keepalived_manager.config.get_instance(\n                HA_VIRTUAL_ROUTER_NAME)\n            vip_address = keepalived_manager.KeepalivedVipAddress(\n                ex_gw_port['ip_cidr'], interface_name)\n            instance.add_vip_address(vip_address)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME)\n                vroute = keepalived_manager.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.add_virtual_route(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                if self.conf.use_namespaces:\n                    ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                                  namespace=ri.ns_name())\n                    ip_wrapper.netns.execute(cmd, check_exit_code=False)\n                else:\n                    utils.execute(cmd, check_exit_code=False,\n                                  root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME)\n                instance.remove_vip_addresses_by_interface(interface_name)\n\n            self.driver.unplug(interface_name,\n                               bridge=self.conf.external_network_bridge,\n                               namespace=ri.ns_name(),\n                               prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            instance = ri.keepalived_manager.config.get_instance(\n                HA_VIRTUAL_ROUTER_NAME)\n            vip_address = keepalived_manager.KeepalivedVipAddress(\n                ip_address, interface_name)\n            instance.add_vip_address(vip_address)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME)\n                instance.remove_vip_adresses_by_interface(interface_name)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nicira, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.process_router_floating_ips = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': _uuid(),\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ips.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_add(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remap(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.2')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_namespace(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.mock_ip.get_namespaces.return_value = ['qrouter-foo',\n                                                    'qrouter-bar']\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces()\n\n        self.assertEqual(pm.disable.call_count, 2)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 2)\n\n    def test_destroy_namespace_with_router_id(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.conf.router_id = _uuid()\n\n        namespaces = ['qrouter-foo', 'qrouter-' + self.conf.router_id]\n\n        self.mock_ip.get_namespaces.return_value = namespaces\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces(self.conf.router_id)\n\n        self.assertEqual(pm.disable.call_count, 1)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 1)\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nicira, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        #self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha', return_value=False)\n        self.is_ha = self.is_ha_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '172.31.255.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '172.31.255.0/24',\n                            'gateway_ip': '172.31.255.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.process_router_floating_ips = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': _uuid(),\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ips.assert_called_with(ri, ex_gw_port)\n        agent.process_router_floating_ips.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ips.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['172.31.255.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '172.31.255.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['vrrp_sync_group ha_group {',\n                        '\\tgroup {',\n                        '\\t\\tha_vrouter',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance ha_vrouter {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t35.4.0.4 dev ' + int_iface,\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.pid', '-c',\n                        '/ha_confs/' + ri.router_id +\n                        '/checkers.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '/vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_add(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_remap(self, IPDevice):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ips(ri, {'id': _uuid()})\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.2')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_namespace(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.mock_ip.get_namespaces.return_value = ['qrouter-foo',\n                                                    'qrouter-bar']\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces()\n\n        self.assertEqual(pm.disable.call_count, 2)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 2)\n\n    def test_destroy_namespace_with_router_id(self):\n\n        class FakeDev(object):\n            def __init__(self, name):\n                self.name = name\n\n        self.conf.router_id = _uuid()\n\n        namespaces = ['qrouter-foo', 'qrouter-' + self.conf.router_id]\n\n        self.mock_ip.get_namespaces.return_value = namespaces\n        self.mock_ip.get_devices.return_value = [FakeDev('qr-aaaa'),\n                                                 FakeDev('qgw-aaaa')]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._destroy_router_namespaces(self.conf.router_id)\n\n        self.assertEqual(pm.disable.call_count, 1)\n\n        self.assertEqual(agent._destroy_router_namespace.call_count, 1)\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.makedirs'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  makedirs,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n                self.assertEqual('/tmp/' + router_id + '/notify_master.sh', m)\n                self.assertEqual('/tmp/' + router_id + '/notify_backup.sh', b)\n                self.assertEqual('/tmp/' + router_id + '/notify_fault.sh', f)\n                replace.assert_has_call_with('/tmp/' + ri.router_id +\n                                             '/notify_master.sh',\n                                             mock.ANY)\n                replace.assert_has_call_with('/tmp/' + ri.router_id +\n                                             '/notify_backup.sh',\n                                             mock.ANY)\n                replace.assert_has_call_with('/tmp/' + ri.router_id +\n                                             '/notify_fault.sh',\n                                             mock.ANY)\n        finally:\n            self.external_process_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"2d26ca30bdf199eafe24ca21029b105ed3aad437","revisionId":3,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     2d26ca30 (Add L3 VRRP HA base classes)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-04 16:15:39 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(ex_gw_port['network_id'],\n                             ex_gw_port['id'], interface_name,\n                             ex_gw_port['mac_address'],\n                             bridge=self.conf.external_network_bridge,\n                             namespace=ri.ns_name(),\n                             prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n            else:\n                utils.execute(cmd, check_exit_code=False,\n                              root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name,\n                               bridge=self.conf.external_network_bridge,\n                               namespace=ri.ns_name(),\n                               prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        if self.is_ha():\n            self.keepalived = keepalived.KeepalivedManager(\n                router_id,\n                keepalived.KeepalivedConf(),\n                conf_path=ha_confs_path,\n                namespace=self.ns_name(),\n                root_helper=root_helper)\n            self.keepalived_notifiers = (\n                keepalived.KeepalivedNotifyScriptManager(\n                    router_id, conf_path=ha_confs_path))\n            self.keepalived_spawned = False\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_config(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_config(self, ri):\n        config = ri.keepalived.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(ex_gw_port['network_id'],\n                             ex_gw_port['id'], interface_name,\n                             ex_gw_port['mac_address'],\n                             bridge=self.conf.external_network_bridge,\n                             namespace=ri.ns_name(),\n                             prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                if self.conf.use_namespaces:\n                    ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                                  namespace=ri.ns_name())\n                    ip_wrapper.netns.execute(cmd, check_exit_code=False)\n                else:\n                    utils.execute(cmd, check_exit_code=False,\n                                  root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, interface=interface_name)\n\n            self.driver.unplug(interface_name,\n                               bridge=self.conf.external_network_bridge,\n                               namespace=ri.ns_name(),\n                               prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '172.31.255.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '172.31.255.0/24',\n                            'gateway_ip': '172.31.255.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['172.31.255.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '172.31.255.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-c',\n                        '/ha_confs/' + ri.router_id +\n                        '-checkers.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"064437ea47a7d33001a54434839328c44ced2d29","revisionId":4,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     064437ea (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-05 19:49:33 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n            else:\n                utils.execute(cmd, check_exit_code=False,\n                              root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent.linux import utils\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        self.keepalived_manager = None\n        self.keepalived_notifiers = None\n        self.keepalived_spawned = False\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        try:\n            return self.plugin_rpc.get_external_network_id(self.context)\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_manager(ri)\n        self._init_keepalived_notifiers(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_notifiers(self, ri):\n        ri.keepalived_notifiers = (\n            keepalived.KeepalivedNotifyScriptManager(\n                ri.router['id'], conf_path=self.conf.ha_confs_path))\n\n    def _init_keepalived_manager(self, ri):\n        ri.keepalived_manager = keepalived.KeepalivedManager(\n            ri.router['id'],\n            keepalived.KeepalivedConf(),\n            conf_path=self.conf.ha_confs_path,\n            namespace=ri.ns_name(),\n            root_helper=self.root_helper)\n\n        config = ri.keepalived_manager.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived_manager.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            if self.conf.use_namespaces:\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n            else:\n                utils.execute(arping_cmd, check_exit_code=True,\n                              root_helper=self.root_helper)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                if self.conf.use_namespaces:\n                    ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                                  namespace=ri.ns_name())\n                    ip_wrapper.netns.execute(cmd, check_exit_code=False)\n                else:\n                    utils.execute(cmd, check_exit_code=False,\n                                  root_helper=self.root_helper)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ri.is_ha():\n            self._remove_keepalived_vip(ri, interface=interface_name)\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived_manager.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        #TODO(nati) move this code to iplib\n        if self.conf.use_namespaces:\n            ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n        else:\n            utils.execute(cmd, check_exit_code=False,\n                          root_helper=self.conf.root_helper)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:28:31.000Z","id":"AAAAVn%2F%2FSuU%3D","line":565,"message":"hi, Sylvain, thanks for clarifing, you are right, one article I saw is wrong which confused me, just now I did an experiment which can prove it will work well in the case of changing both server state as BACKUP, primary having higher priority and with nopreempt, both having the same router ID. below is my configurations:\n\nvrrp_instance master_ins {\n   state BACKUP\n   nopreempt\n   interface wlp3s0\n   virtual_router_id 1\n   priority 250\n   advert_int 2\n   virtual_ipaddress {\n     192.168.99.122/24\n   } \n}\n\n\nvrrp_instance backup_ins {\n   state BACKUP\n   nopreempt\n   interface wlp2s6\n   virtual_router_id 1\n   priority 249\n   advert_int 2\n   virtual_ipaddress {\n     192.168.99.122/24\n   }\n}"},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-06T11:09:10.000Z","id":"AAAAVn%2F%2FZr4%3D","line":565,"message":"After reading the man page :\n\n\"\"\"\n\nVRRP will normally preempt a lower priority\nmachine when a higher priority machine comes\nonline.  \"nopreempt\" allows the lower priority\nmachine to maintain the master role, even when\na higher priority machine comes back online.\nNOTE: For this to work, the initial state of this\nentry must be BACKUP.\n\n\"\"\"\n\nSo I think all nodes should be in BACKUP state with nopreempt as True, No ?"},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T07:04:15.000Z","id":"AAAAVn%2F%2Fa%2Fs%3D","line":565,"message":"I think backup will preempt as master after master is dead, but master shouldn't preemp as master again after it comes again.\nso for master, status=BACKUP + nopreempt=True + high priority; for backup, status=BACKUP + nopreempt=False + low priority\nany idea ?"},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-07T13:21:37.000Z","id":"AAAAVn%2F%2FOpM%3D","line":897,"message":"Not sure to understand, Do you mean that you are wondering if the vrrp traffic going through the ha interface will not be tracked by conntrackd ?"},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T06:24:16.000Z","id":"AAAAVn%2F%2FRFE%3D","line":897,"message":"keepalived has -f parameter (/opt/stack/data/neutron/ha_confs/\u003crouter id\u003e/keepalived.conf ) to support every router namespace to boot one keepalived instance, got it, thanks."},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:49:42.000Z","id":"AAAAVn%2F%2FSaM%3D","line":897,"message":"following the above, just a new question in my mind, maybe I'm wrong, I guess the keepalived will execute a RAW PREROUTING rule after adding route_ha_interface ports into 'interface' configuration item to separate different tcp flows to improve conntrack's performance (just guess, not sure, I don't know how keepalived implement this yet ):\niptables -t raw -A PREROUTING ! I $router_ha_interface_port -j NOTRACK\nso if it's necesseary to add below rules as well ?\niptables t raw A OUTPUT j NOTRACK \niptables -A FORWARD -m state --state UNTRACKED -j ACCEPT"},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:28:31.000Z","id":"AAAAVn%2F%2FShQ%3D","line":897,"message":"Hi Sylvain, are you saying the router_ha_interface ports across different namesapce has been added into 'interface' configuration item of keepalived, if yes, got it.\nInitially, I mistake keeplived itself can pass and specify the ns_name when execting the 'route' command or you plan to use 'mount --bind' to implement similiar usage by yourself.\nthanks for your clarify"},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-06T11:09:10.000Z","id":"AAAAVn%2F%2FZaM%3D","line":897,"message":"Yes since there is a keepalived instance per router and each instance is running into router namespace."},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T07:04:15.000Z","id":"AAAAVn%2F%2Fa4s%3D","line":897,"message":"not sure if the configuration item virtual_routes of keeplived support namespace, does here will work well when enabling use_namespace=True ?"},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T07:04:15.000Z","id":"AAAAVn%2F%2Fa5w%3D","line":960,"message":"I know for HA port it will use 'l3_ha_net_cidr=172.31.255.0/24' use default HA subnet, but for the internal gw port in different l3-agent maybe they will have the same IP. just want to know whether it will cause the problem for this case having the same IP in multiple ports ?"},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T08:59:34.000Z","id":"AAAAVn%2F%2FaLM%3D","line":960,"message":"sorry, just now mistake on this, now I have understood it, thanks."},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:28:31.000Z","id":"AAAAVn%2F%2FSuA%3D","line":1087,"message":"got it, thanks."},{"author":{"accountId":8873,"email":"amuller@redhat.com","name":"Assaf Muller","username":"amuller"},"date":"2014-03-06T11:38:58.000Z","id":"AAAAVn%2F%2FZNg%3D","line":1087,"message":"Here's the conntrackd patch:\n\nhttps://review.openstack.org/#/c/71586/"},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-06T11:09:10.000Z","id":"AAAAVn%2F%2FZZs%3D","line":1087,"message":"I plan to introduce  conntrackd in another patch depending of this one in order to keep this one as simple as possible."},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T07:04:15.000Z","id":"AAAAVn%2F%2Fa%2Bo%3D","line":1087,"message":"I can't search the class ConntrackdManager in the https://review.openstack.org/#/c/71586/5/neutron/agent/linux/conntrackd_manager.py, just want to know where we should use ConntrackdManager ?"}],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","comments":[],"name":"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py"},"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","comments":[],"name":"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        if self.conf.use_namespaces:\n            self.mock_ip.netns.execute.assert_any_call(\n                arping_cmd, check_exit_code=True)\n        else:\n            self.utils_exec.assert_any_call(arping_cmd,\n                                            check_exit_code=True,\n                                            root_helper=self.conf.root_helper)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        if namespace:\n            self.mock_ip.netns.execute.assert_has_calls(\n                [mock.call(call, check_exit_code=False) for call in calls],\n                any_order=True)\n        else:\n            self.utils_exec.assert_has_calls([\n                mock.call(call, root_helper='sudo',\n                          check_exit_code=False) for call in calls],\n                any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '172.31.255.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '172.31.255.0/24',\n                            'gateway_ip': '172.31.255.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['172.31.255.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '172.31.255.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-c',\n                        '/ha_confs/' + ri.router_id +\n                        '-checkers.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'id': router_id, 'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._init_keepalived_notifiers(ri)\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"ad54765eb42a0f841795993b694bc0e4ae3f12cb","revisionId":5,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     ad54765e (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-06 15:44:44 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:49:57.000Z","id":"AAAAVn%2F%2FSgI%3D","line":9,"message":"nit: Partially Implements: blueprint l3-high-availability"}],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        self.keepalived_manager = None\n        self.keepalived_notifiers = None\n        self.keepalived_spawned = False\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n        cfg.IntOpt('ha_garp_master_delay',\n                   help=_('Delay for gratuitous ARP after '\n                          'transition to MASTER')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_manager(ri)\n        self._init_keepalived_notifiers(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_notifiers(self, ri):\n        ri.keepalived_notifiers = (\n            keepalived.KeepalivedNotifyScriptManager(\n                ri.router['id'], conf_path=self.conf.ha_confs_path))\n\n    def _init_keepalived_manager(self, ri):\n        ri.keepalived_manager = keepalived.KeepalivedManager(\n            ri.router['id'],\n            keepalived.KeepalivedConf(),\n            conf_path=self.conf.ha_confs_path,\n            namespace=ri.ns_name(),\n            root_helper=self.root_helper)\n\n        config = ri.keepalived_manager.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int,\n            garp_master_delay=self.conf.ha_garp_master_delay)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived_manager.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ri.is_ha():\n            self._remove_keepalived_vip(ri, interface=interface_name)\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived_manager.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","comments":[],"name":"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py"},"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","comments":[],"name":"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '169.254.0.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '169.254.0.0/24',\n                            'gateway_ip': '169.254.0.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['169.254.0.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '169.254.0.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-P', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'id': router_id, 'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._init_keepalived_notifiers(ri)\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"50abbf0b2b5334602daa0a446e3402f18c4783f9","revisionId":6,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     50abbf0b (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-10 16:27:27 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        self.keepalived_manager = None\n        self.keepalived_notifiers = None\n        self.keepalived_spawned = False\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n        cfg.IntOpt('ha_garp_master_delay',\n                   help=_('Delay for gratuitous ARP after '\n                          'transition to MASTER')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_manager(ri)\n        self._init_keepalived_notifiers(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_notifiers(self, ri):\n        ri.keepalived_notifiers = (\n            keepalived.KeepalivedNotifyScriptManager(\n                ri.router['id'], conf_path=self.conf.ha_confs_path))\n\n    def _init_keepalived_manager(self, ri):\n        ri.keepalived_manager = keepalived.KeepalivedManager(\n            ri.router['id'],\n            keepalived.KeepalivedConf(),\n            conf_path=self.conf.ha_confs_path,\n            namespace=ri.ns_name(),\n            root_helper=self.root_helper)\n\n        config = ri.keepalived_manager.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int,\n            garp_master_delay=self.conf.ha_garp_master_delay)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived_manager.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ri.is_ha():\n            self._remove_keepalived_vip(ri, interface=interface_name)\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived_manager.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-10T17:52:53.000Z","id":"AAAAVn%2F%2FA60%3D","line":414,"message":"Yes because keepalived notifiers are built in the _spawn_metadata_proxy, then add to the group here."},{"author":{"accountId":6788,"email":"rossble@gmail.com","name":"Rossella Sblendido","username":"rossella-o"},"date":"2014-03-10T17:02:09.000Z","id":"AAAAVn%2F%2FBf4%3D","line":414,"message":"Any reason why you added a second 'if' here and didn't put line 415 to 418 under the 'if' of line 408? Do you need the metadata proxy to be spawn before, doesn't seem related from a quick view."},{"author":{"accountId":6788,"email":"rossble@gmail.com","name":"Rossella Sblendido","username":"rossella-o"},"date":"2014-03-10T17:02:09.000Z","id":"AAAAVn%2F%2FBUU%3D","line":602,"message":"nit: remove blank line"},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-10T17:52:53.000Z","id":"AAAAVn%2F%2FA3k%3D","line":756,"message":"We always have to keep only 1 IP in this list which is the first one (sorted) of the merge of the instance.vip_addresses and instance.vip_addresses_excluded. All remaining IPs will be pushed in the instance.vip_addresses_excluded.\n\nThe vip_address \"re-assigned\" couldn't be the same, could has been removed line #746"},{"author":{"accountId":6788,"email":"rossble@gmail.com","name":"Rossella Sblendido","username":"rossella-o"},"date":"2014-03-10T17:02:09.000Z","id":"AAAAVn%2F%2FBSY%3D","line":756,"message":"I am confused, why are you re-assigning the vip to the instance?"}],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","comments":[],"name":"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py"},"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","comments":[],"name":"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '169.254.0.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '169.254.0.0/24',\n                            'gateway_ip': '169.254.0.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['169.254.0.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '169.254.0.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-P', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'id': router_id, 'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._init_keepalived_notifiers(ri)\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"8ffd3b1b4055225a55a294ae58181497fcd11168","revisionId":7,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     8ffd3b1b (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-10 19:04:33 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        self.keepalived_manager = None\n        self.keepalived_notifiers = None\n        self.keepalived_spawned = False\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n        cfg.IntOpt('ha_garp_master_delay',\n                   help=_('Delay for gratuitous ARP after '\n                          'transition to MASTER')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_manager(ri)\n        self._init_keepalived_notifiers(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_notifiers(self, ri):\n        ri.keepalived_notifiers = (\n            keepalived.KeepalivedNotifyScriptManager(\n                ri.router['id'], conf_path=self.conf.ha_confs_path))\n\n    def _init_keepalived_manager(self, ri):\n        ri.keepalived_manager = keepalived.KeepalivedManager(\n            ri.router['id'],\n            keepalived.KeepalivedConf(),\n            conf_path=self.conf.ha_confs_path,\n            namespace=ri.ns_name(),\n            root_helper=self.root_helper)\n\n        config = ri.keepalived_manager.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int,\n            garp_master_delay=self.conf.ha_garp_master_delay)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived_manager.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ri.is_ha():\n            self._remove_keepalived_vip(ri, interface=interface_name)\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived_manager.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","comments":[],"name":"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py"},"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","comments":[],"name":"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '169.254.0.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '169.254.0.0/24',\n                            'gateway_ip': '169.254.0.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['169.254.0.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '169.254.0.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-P', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'id': router_id, 'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._init_keepalived_notifiers(ri)\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"a02c2ad912d614ffc3710a2f5d5ecb84c848be68","revisionId":8,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     a02c2ad9 (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-10 19:22:49 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nStill WIP, have to improve unit tests and\nfunctionnal tests.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        self.keepalived_manager = None\n        self.keepalived_notifiers = None\n        self.keepalived_spawned = False\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n        cfg.IntOpt('ha_garp_master_delay',\n                   help=_('Delay for gratuitous ARP after '\n                          'transition to MASTER')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n        if ri.is_ha():\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_manager(ri)\n        self._init_keepalived_notifiers(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_notifiers(self, ri):\n        ri.keepalived_notifiers = (\n            keepalived.KeepalivedNotifyScriptManager(\n                ri.router['id'], conf_path=self.conf.ha_confs_path))\n\n    def _init_keepalived_manager(self, ri):\n        ri.keepalived_manager = keepalived.KeepalivedManager(\n            ri.router['id'],\n            keepalived.KeepalivedConf(),\n            conf_path=self.conf.ha_confs_path,\n            namespace=ri.ns_name(),\n            root_helper=self.root_helper)\n\n        config = ri.keepalived_manager.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int,\n            garp_master_delay=self.conf.ha_garp_master_delay)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived_manager.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        vip_address = vip_addresses.pop(0)\n        instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ri.is_ha():\n            self._remove_keepalived_vip(ri, interface=interface_name)\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived_manager.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","comments":[],"name":"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py"},"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","comments":[],"name":"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '169.254.0.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '169.254.0.0/24',\n                            'gateway_ip': '169.254.0.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['169.254.0.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '169.254.0.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-P', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'id': router_id, 'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  ip_class):\n                self.agent._init_keepalived_notifiers(ri)\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}},{"author":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","committer":"Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e","message":"Add HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nUnit test will have to be improved.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e\n","parentCommit":"a02c2ad912d614ffc3710a2f5d5ecb84c848be68","revisionId":9,"subject":"Add HA support to the l3 agent","files":{"/COMMIT_MSG":{"a":"","b":"Parent:     a02c2ad9 (Introduces a keepalived manager for HA)\nAuthor:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nAuthorDate: 2014-03-04 13:18:25 +0100\nCommit:     Sylvain Afchain \u003csylvain.afchain@enovance.com\u003e\nCommitDate: 2014-03-11 14:28:03 +0100\n\nAdd HA support to the l3 agent\n\nThis patch is a part of the blueprint l3-high-availability\n\nUnit test will have to be improved.\n\nChange-Id: I83f2a5d2af42164c42773b385ba7b00872eed54e","comments":[],"name":"/COMMIT_MSG"},"etc/l3_agent.ini":{"a":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10","b":"[DEFAULT]\n# Show debugging output in log (sets DEBUG log level output)\n# debug = False\n\n# L3 requires that an interface driver be set. Choose the one that best\n# matches your plugin.\n# interface_driver =\n\n# Example of interface_driver option for OVS based plugins (OVS, Ryu, NEC)\n# that supports L3 agent\n# interface_driver = neutron.agent.linux.interface.OVSInterfaceDriver\n\n# Use veth for an OVS interface or not.\n# Support kernels with limited namespace support\n# (e.g. RHEL 6.5) so long as ovs_use_veth is set to True.\n# ovs_use_veth = False\n\n# Example of interface_driver option for LinuxBridge\n# interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver\n\n# Allow overlapping IP (Must have kernel build with CONFIG_NET_NS=y and\n# iproute2 package that supports namespaces).\n# use_namespaces = True\n\n# If use_namespaces is set as False then the agent can only configure one router.\n\n# This is done by setting the specific router_id.\n# router_id =\n\n# When external_network_bridge is set, each L3 agent can be associated\n# with no more than one external network. This value should be set to the UUID\n# of that external network. To allow L3 agent support multiple external\n# networks, both the external_network_bridge and gateway_external_network_id\n# must be left empty.\n# gateway_external_network_id =\n\n# Indicates that this L3 agent should also handle routers that do not have\n# an external network gateway configured.  This option should be True only\n# for a single agent in a Neutron deployment, and may be False for all agents\n# if all routers must have an external network gateway\n# handle_internal_only_routers = True\n\n# Name of bridge used for external network traffic. This should be set to\n# empty value for the linux bridge. when this parameter is set, each L3 agent\n# can be associated with no more than one external network.\n# external_network_bridge = br-ex\n\n# TCP Port used by Neutron metadata server\n# metadata_port = 9697\n\n# Send this many gratuitous ARPs for HA setup. Set it below or equal to 0\n# to disable this feature.\n# send_arp_for_ha = 0\n\n# seconds between re-sync routers' data if needed\n# periodic_interval = 40\n\n# seconds to start to sync routers' data after\n# starting agent\n# periodic_fuzzy_delay = 5\n\n# enable_metadata_proxy, which is true by default, can be set to False\n# if the Nova metadata server is not available\n# enable_metadata_proxy = True\n\n# Location of Metadata Proxy UNIX domain socket\n# metadata_proxy_socket = $state_path/metadata_proxy\n\n# router_delete_namespaces, which is false by default, can be set to True if\n# namespaces can be deleted cleanly on the host running the L3 agent.\n# Do not enable this until you understand the problem with the Linux iproute\n# utility mentioned in https://bugs.launchpad.net/neutron/+bug/1052535 and\n# you are sure that your version of iproute does not suffer from the problem.\n# If True, namespaces will be deleted when a router is destroyed.\n# router_delete_namespaces = False\n\n# Timeout for ovs-vsctl commands.\n# If the timeout expires, ovs commands will fail with ALARMCLOCK error.\n# ovs_vsctl_timeout = 10\n\n# Location to store keepalived and all HA configurations\n# ha_confs_path = $state_path/ha_confs\n\n# VRRP authentication type AH/PASS\n# ha_vrrp_auth_type = PASS\n\n# VRRP authentication password\n# ha_vrrp_auth_password =\n\n# A list of email accounts that will receive the notification mail\n# when the state changes\n# ha_notification_emails =\n\n# Email to use when processing MAIL FROM: SMTP command\n# ha_notification_from =\n\n# Remote SMTP server to use for sending mail notification\n# ha_smtp_server =\n\n# Timeout for SMTP stream processing\n# ha_smtp_timeout = 10\n\n# The advertisement interval in seconds\n# ha_vrrp_advert_int = 2","comments":[],"name":"etc/l3_agent.ini"},"neutron/agent/l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri.router_id, ri.ns_name())\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, router_id, ns_name):\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                fip_statuses = self.process_router_floating_ip_addresses(\n                    ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr, str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                self._send_gratuitous_arp_packet(\n                    ri, interface_name, fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                            namespace=ri.ns_name(),\n                            preserve_ips=preserve_ips)\n        ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            cmd = ['route', 'add', 'default', 'gw', gw_ip]\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","b":"# Copyright 2012 VMware, Inc.  All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n\nimport os\n\nimport eventlet\nimport netaddr\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config\nfrom neutron.agent.linux import external_process\nfrom neutron.agent.linux import interface\nfrom neutron.agent.linux import ip_lib\nfrom neutron.agent.linux import iptables_manager\nfrom neutron.agent.linux import keepalived\nfrom neutron.agent.linux import ovs_lib  # noqa\nfrom neutron.agent import rpc as agent_rpc\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import legacy\nfrom neutron.common import topics\nfrom neutron.common import utils as common_utils\nfrom neutron import context\nfrom neutron import manager\nfrom neutron.openstack.common import excutils\nfrom neutron.openstack.common import importutils\nfrom neutron.openstack.common import lockutils\nfrom neutron.openstack.common import log as logging\nfrom neutron.openstack.common import loopingcall\nfrom neutron.openstack.common import periodic_task\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common.rpc import common as rpc_common\nfrom neutron.openstack.common.rpc import proxy\nfrom neutron.openstack.common import service\nfrom neutron import service as neutron_service\nfrom neutron.services.firewall.agents.l3reference import firewall_l3_agent\n\nLOG = logging.getLogger(__name__)\nNS_PREFIX = 'qrouter-'\nINTERNAL_DEV_PREFIX = 'qr-'\nEXTERNAL_DEV_PREFIX = 'qg-'\nHA_DEV_PREFIX = 'ha-'\nRPC_LOOP_INTERVAL = 1\nFLOATING_IP_CIDR_SUFFIX = '/32'\nHA_VIRTUAL_ROUTER_NAME_PREFIX = 'VR_'\nHA_VIRTUAL_ROUTER_GROUP_PREFIX = 'VG_'\n\n\nclass L3PluginApi(proxy.RpcProxy):\n    \"\"\"Agent side of the l3 agent RPC API.\n\n    API version history:\n        1.0 - Initial version.\n        1.1 - Floating IP operational status updates\n\n    \"\"\"\n\n    BASE_RPC_API_VERSION = '1.0'\n\n    def __init__(self, topic, host):\n        super(L3PluginApi, self).__init__(\n            topic=topic, default_version=self.BASE_RPC_API_VERSION)\n        self.host = host\n\n    def get_routers(self, context, router_ids=None):\n        \"\"\"Make a remote process call to retrieve the sync data for routers.\"\"\"\n        return self.call(context,\n                         self.make_msg('sync_routers', host=self.host,\n                                       router_ids=router_ids),\n                         topic=self.topic)\n\n    def get_external_network_id(self, context):\n        \"\"\"Make a remote process call to retrieve the external network id.\n\n        @raise common.RemoteError: with TooManyExternalNetworks\n                                   as exc_type if there are\n                                   more than one external network\n        \"\"\"\n        return self.call(context,\n                         self.make_msg('get_external_network_id',\n                                       host=self.host),\n                         topic=self.topic)\n\n    def update_floatingip_statuses(self, context, router_id, fip_statuses):\n        \"\"\"Call the plugin update floating IPs's operational status.\"\"\"\n        return self.call(context,\n                         self.make_msg('update_floatingip_statuses',\n                                       router_id=router_id,\n                                       fip_statuses=fip_statuses),\n                         topic=self.topic,\n                         version='1.1')\n\n\nclass RouterInfo(object):\n\n    def __init__(self, router_id, root_helper, use_namespaces, router,\n                 ha_confs_path=None):\n        self.router_id = router_id\n        self.ex_gw_port = None\n        self._snat_enabled = None\n        self._snat_action = None\n        self.ha_port = None\n        self.internal_ports = []\n        self.floating_ips = set()\n        self.root_helper = root_helper\n        self.use_namespaces = use_namespaces\n        # Invoke the setter for establishing initial SNAT action\n        self.router = router\n        self.iptables_manager = iptables_manager.IptablesManager(\n            root_helper=root_helper,\n            #FIXME(danwent): use_ipv6=True,\n            namespace=self.ns_name())\n        self.keepalived_manager = None\n        self.keepalived_notifiers = None\n        self.keepalived_spawned = False\n        self.routes = []\n\n    @property\n    def router(self):\n        return self._router\n\n    @router.setter\n    def router(self, value):\n        self._router = value\n        if not self._router:\n            return\n        # enable_snat by default if it wasn't specified by plugin\n        self._snat_enabled = self._router.get('enable_snat', True)\n        # Set a SNAT action for the router\n        if self._router.get('gw_port'):\n            self._snat_action = ('add_rules' if self._snat_enabled\n                                 else 'remove_rules')\n        elif self.ex_gw_port:\n            # Gateway port was removed, remove rules\n            self._snat_action = 'remove_rules'\n\n    def ns_name(self):\n        if self.use_namespaces:\n            return NS_PREFIX + self.router_id\n\n    def perform_snat_action(self, snat_callback, *args):\n        # Process SNAT rules for attached subnets\n        if self._snat_action:\n            snat_callback(self, self._router.get('gw_port'),\n                          *args, action=self._snat_action)\n        self._snat_action = None\n\n    def is_ha(self):\n        return ((self.router is not None) and\n                self.router.get('ha_vr_id'))\n\n    @property\n    def ha_vr_id(self):\n        return self.router.get('ha_vr_id')\n\n\nclass L3NATAgent(firewall_l3_agent.FWaaSL3AgentRpcCallback, manager.Manager):\n    \"\"\"Manager for L3NatAgent\n\n        API version history:\n        1.0 initial Version\n        1.1 changed the type of the routers parameter\n            to the routers_updated method.\n            It was previously a list of routers in dict format.\n            It is now a list of router IDs only.\n            Per rpc versioning rules,  it is backwards compatible.\n    \"\"\"\n    RPC_API_VERSION = '1.1'\n\n    OPTS = [\n        cfg.StrOpt('external_network_bridge', default='br-ex',\n                   help=_(\"Name of bridge used for external network \"\n                          \"traffic.\")),\n        cfg.IntOpt('metadata_port',\n                   default=9697,\n                   help=_(\"TCP Port used by Neutron metadata namespace \"\n                          \"proxy.\")),\n        cfg.IntOpt('send_arp_for_ha',\n                   default=0,\n                   help=_(\"Send this many gratuitous ARPs for HA setup, if \"\n                          \"less than or equal to 0, the feature is disabled\")),\n        cfg.StrOpt('router_id', default='',\n                   help=_(\"If namespaces is disabled, the l3 agent can only\"\n                          \" configure a router that has the matching router \"\n                          \"ID.\")),\n        cfg.BoolOpt('handle_internal_only_routers',\n                    default=True,\n                    help=_(\"Agent should implement routers with no gateway\")),\n        cfg.StrOpt('gateway_external_network_id', default='',\n                   help=_(\"UUID of external network for routers implemented \"\n                          \"by the agents.\")),\n        cfg.BoolOpt('enable_metadata_proxy', default=True,\n                    help=_(\"Allow running metadata proxy.\")),\n        cfg.BoolOpt('router_delete_namespaces', default=False,\n                    help=_(\"Delete namespace after removing a router.\")),\n        cfg.StrOpt('metadata_proxy_socket',\n                   default='$state_path/metadata_proxy',\n                   help=_('Location of Metadata Proxy UNIX domain '\n                          'socket')),\n        cfg.StrOpt('ha_confs_path',\n                   default='$state_path/ha_confs',\n                   help=_('Location to store keepalived/conntrackd '\n                          'config files')),\n        cfg.StrOpt('ha_vrrp_auth_type',\n                   default='PASS',\n                   help=_('VRRP authentication type AH/PASS')),\n        cfg.StrOpt('ha_vrrp_auth_password',\n                   help=_('VRRP authentication password')),\n        cfg.ListOpt('ha_notification_emails',\n                    help=_('Email accounts that will receive the '\n                           'notification mail')),\n        cfg.StrOpt('ha_notification_from',\n                   help=_('Email to use when processing '\n                          'MAIL FROM: SMTP command')),\n        cfg.StrOpt('ha_smtp_server',\n                   help=_('Remote SMTP server to use for sending '\n                          'mail notification')),\n        cfg.IntOpt('ha_smtp_timeout',\n                   default=10,\n                   help=_('Timeout for SMTP stream processing')),\n        cfg.IntOpt('ha_vrrp_advert_int',\n                   default=2,\n                   help=_('The advertisement interval in seconds')),\n        cfg.IntOpt('ha_garp_master_delay',\n                   help=_('Delay for gratuitous ARP after '\n                          'transition to MASTER')),\n    ]\n\n    def __init__(self, host, conf=None):\n        if conf:\n            self.conf = conf\n        else:\n            self.conf = cfg.CONF\n        self.root_helper = config.get_root_helper(self.conf)\n        self.router_info = {}\n\n        self._check_config_params()\n\n        try:\n            self.driver = importutils.import_object(\n                self.conf.interface_driver,\n                self.conf\n            )\n        except Exception:\n            msg = _(\"Error importing interface driver \"\n                    \"'%s'\") % self.conf.interface_driver\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        self.context = context.get_admin_context_without_session()\n        self.plugin_rpc = L3PluginApi(topics.L3PLUGIN, host)\n        self.fullsync = True\n        self.updated_routers = set()\n        self.removed_routers = set()\n        self.sync_progress = False\n\n        self._delete_stale_namespaces = (self.conf.use_namespaces and\n                                         self.conf.router_delete_namespaces)\n\n        self._init_ha_conf_path()\n\n        self.rpc_loop = loopingcall.FixedIntervalLoopingCall(\n            self._rpc_loop)\n        self.rpc_loop.start(interval=RPC_LOOP_INTERVAL)\n        super(L3NATAgent, self).__init__(conf=self.conf)\n\n        self.target_ex_net_id = None\n\n    def _init_ha_conf_path(self):\n        ha_full_path = os.path.dirname(\"/%s/\" % self.conf.ha_confs_path)\n        if not os.path.isdir(ha_full_path):\n            os.makedirs(ha_full_path, 0o755)\n\n    def _check_config_params(self):\n        \"\"\"Check items in configuration files.\n\n        Check for required and invalid configuration items.\n        The actual values are not verified for correctness.\n        \"\"\"\n        if not self.conf.interface_driver:\n            msg = _('An interface driver must be specified')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n        if not self.conf.use_namespaces and not self.conf.router_id:\n            msg = _('Router id is required if not using namespaces.')\n            LOG.error(msg)\n            raise SystemExit(msg)\n\n    def _cleanup_namespaces(self, routers):\n        \"\"\"Destroy stale router namespaces on host when L3 agent restarts\n\n        This routine is called when self._delete_stale_namespaces is True.\n\n        The argument routers is the list of routers that are recorded in\n        the database as being hosted on this node.\n        \"\"\"\n        try:\n            root_ip = ip_lib.IPWrapper(self.root_helper)\n\n            host_namespaces = root_ip.get_namespaces(self.root_helper)\n            router_namespaces = set(ns for ns in host_namespaces\n                                    if ns.startswith(NS_PREFIX))\n            ns_to_ignore = set(NS_PREFIX + r['id'] for r in routers)\n            ns_to_destroy = router_namespaces - ns_to_ignore\n        except RuntimeError:\n            LOG.exception(_('RuntimeError in obtaining router list '\n                            'for namespace cleanup.'))\n        else:\n            self._destroy_stale_router_namespaces(ns_to_destroy)\n\n    def _destroy_stale_router_namespaces(self, router_namespaces):\n        \"\"\"Destroys the stale router namespaces\n\n        The argumenet router_namespaces is a list of stale router namespaces\n\n        As some stale router namespaces may not be able to be deleted, only\n        one attempt will be made to delete them.\n        \"\"\"\n        for ns in router_namespaces:\n            if self.conf.enable_metadata_proxy:\n                self._destroy_metadata_proxy(ns[len(NS_PREFIX):], ns)\n\n            try:\n                self._destroy_router_namespace(ns)\n            except RuntimeError:\n                LOG.exception(_('Failed to destroy stale router namespace '\n                                '%s'), ns)\n        self._delete_stale_namespaces = False\n\n    def _destroy_router_namespace(self, namespace):\n        ns_ip = ip_lib.IPWrapper(self.root_helper, namespace=namespace)\n        for d in ns_ip.get_devices(exclude_loopback=True):\n            if d.name.startswith(INTERNAL_DEV_PREFIX):\n                # device is on default bridge\n                self.driver.unplug(d.name, namespace=namespace,\n                                   prefix=INTERNAL_DEV_PREFIX)\n            elif d.name.startswith(EXTERNAL_DEV_PREFIX):\n                self.driver.unplug(d.name,\n                                   bridge=self.conf.external_network_bridge,\n                                   namespace=namespace,\n                                   prefix=EXTERNAL_DEV_PREFIX)\n\n        if self.conf.router_delete_namespaces:\n            try:\n                ns_ip.netns.delete(namespace)\n            except RuntimeError:\n                msg = _('Failed trying to delete namespace: %s')\n                LOG.exception(msg % namespace)\n\n    def _create_router_namespace(self, ri):\n            ip_wrapper_root = ip_lib.IPWrapper(self.root_helper)\n            ip_wrapper = ip_wrapper_root.ensure_namespace(ri.ns_name())\n            ip_wrapper.netns.execute(['sysctl', '-w', 'net.ipv4.ip_forward=1'])\n\n    def _fetch_external_net_id(self, force=False):\n        \"\"\"Find UUID of single external network for this agent.\"\"\"\n        if self.conf.gateway_external_network_id:\n            return self.conf.gateway_external_network_id\n\n        # L3 agent doesn't use external_network_bridge to handle external\n        # networks, so bridge_mappings with provider networks will be used\n        # and the L3 agent is able to handle any external networks.\n        if not self.conf.external_network_bridge:\n            return\n\n        if not force and self.target_ex_net_id:\n            return self.target_ex_net_id\n\n        try:\n            self.target_ex_net_id = self.plugin_rpc.get_external_network_id(\n                self.context)\n            return self.target_ex_net_id\n        except rpc_common.RemoteError as e:\n            with excutils.save_and_reraise_exception():\n                if e.exc_type == 'TooManyExternalNetworks':\n                    msg = _(\n                        \"The 'gateway_external_network_id' option must be \"\n                        \"configured for this agent as Neutron has more than \"\n                        \"one external network.\")\n                    raise Exception(msg)\n\n    def _router_added(self, router_id, router):\n        ri = RouterInfo(router_id, self.root_helper,\n                        self.conf.use_namespaces, router,\n                        self.conf.ha_confs_path)\n        self.router_info[router_id] = ri\n        if self.conf.use_namespaces:\n            self._create_router_namespace(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].add_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].add_rule(c, r)\n        ri.iptables_manager.apply()\n        super(L3NATAgent, self).process_router_add(ri)\n\n        if ri.is_ha():\n            self.process_ha_router_added(ri)\n\n        if self.conf.enable_metadata_proxy:\n            self._spawn_metadata_proxy(ri)\n\n    def _router_removed(self, router_id):\n        ri = self.router_info.get(router_id)\n        if ri is None:\n            LOG.warn(_(\"Info for router %s were not found. \"\n                       \"Skipping router removal\"), router_id)\n            return\n\n        if ri.is_ha():\n            self.process_ha_router_removed(ri)\n\n        ri.router['gw_port'] = None\n        ri.router[l3_constants.INTERFACE_KEY] = []\n        ri.router[l3_constants.FLOATINGIP_KEY] = []\n        self.process_router(ri)\n        for c, r in self.metadata_filter_rules():\n            ri.iptables_manager.ipv4['filter'].remove_rule(c, r)\n        for c, r in self.metadata_nat_rules():\n            ri.iptables_manager.ipv4['nat'].remove_rule(c, r)\n        ri.iptables_manager.apply()\n        if self.conf.enable_metadata_proxy:\n            self._destroy_metadata_proxy(ri.router_id, ri.ns_name())\n        del self.router_info[router_id]\n        self._destroy_router_namespace(ri.ns_name())\n\n    def _spawn_metadata_proxy(self, ri):\n        router_id, ns_name = ri.router_id, ri.ns_name()\n\n        def callback(pid_file):\n            metadata_proxy_socket = cfg.CONF.metadata_proxy_socket\n            proxy_cmd = ['neutron-ns-metadata-proxy',\n                         '--pid_file=%s' % pid_file,\n                         '--metadata_proxy_socket=%s' % metadata_proxy_socket,\n                         '--router_id=%s' % router_id,\n                         '--state_path=%s' % self.conf.state_path,\n                         '--metadata_port=%s' % self.conf.metadata_port]\n            proxy_cmd.extend(config.get_log_args(\n                cfg.CONF, 'neutron-ns-metadata-proxy-%s.log' %\n                router_id))\n            return proxy_cmd\n\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n\n        if ri.is_ha():\n            pid_file = pm.get_pid_file_name(ensure_pids_dir=True)\n            cmd = callback(pid_file)\n\n            ri.keepalived_notifiers.add_notify('master', ' '.join(cmd) + ' \u0026')\n\n            cmd = ['kill', '-9', '$(cat ' + pid_file + ')']\n            ri.keepalived_notifiers.add_notify('backup', ' '.join(cmd))\n            ri.keepalived_notifiers.add_notify('fault', ' '.join(cmd))\n\n            m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n            group = ri.keepalived_manager.config.get_group(\n                HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n            group.set_notifiers(m, b, f)\n        else:\n            pm.enable(callback)\n\n    def _destroy_metadata_proxy(self, router_id, ns_name):\n        pm = external_process.ProcessManager(\n            self.conf,\n            router_id,\n            self.root_helper,\n            ns_name)\n        pm.disable()\n\n    def _set_subnet_info(self, port):\n        ips = port['fixed_ips']\n        if not ips:\n            raise Exception(_(\"Router port %s has no IP address\") % port['id'])\n        if len(ips) \u003e 1:\n            LOG.error(_(\"Ignoring multiple IPs on router port %s\"),\n                      port['id'])\n        prefixlen = netaddr.IPNetwork(port['subnet']['cidr']).prefixlen\n        port['ip_cidr'] = \"%s/%s\" % (ips[0]['ip_address'], prefixlen)\n\n    def get_ha_device_name(self, port_id):\n        return (HA_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def ha_network_added(self, ri, network_id, port_id,\n                         internal_cidr, mac_address,\n                         set_address=False):\n        interface_name = self.get_ha_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=HA_DEV_PREFIX)\n\n        self.driver.init_l3(interface_name, [internal_cidr],\n                            namespace=ri.ns_name())\n        ip_address = internal_cidr.split('/')[0]\n        self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def ha_network_removed(self, ri):\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=HA_DEV_PREFIX)\n\n    def process_ha_router_added(self, ri):\n        ha_ports = ri.router.get(l3_constants.HA_INTERFACE_KEY)\n        if not ha_ports:\n            LOG.warn(_(\"Unable to process HA router without ha port\"))\n            return\n\n        if len(ha_ports) \u003e 1:\n            LOG.warn(_(\"A l3 agent can't handle more than once HA port\"))\n        ha_port = ha_ports[0]\n\n        self._set_subnet_info(ha_port)\n        self.ha_network_added(ri, ha_port['network_id'], ha_port['id'],\n                              ha_port['ip_cidr'], ha_port['mac_address'])\n        ri.ha_port = ha_port\n\n        self._init_keepalived_manager(ri)\n        self._init_keepalived_notifiers(ri)\n\n    def process_ha_router_removed(self, ri):\n        self._destroy_keepalived(ri)\n        self.ha_network_removed(ri)\n        ri.ha_port = None\n\n    def _init_keepalived_notifiers(self, ri):\n        ri.keepalived_notifiers = (\n            keepalived.KeepalivedNotifyScriptManager(\n                ri.router['id'], conf_path=self.conf.ha_confs_path))\n\n    def _init_keepalived_manager(self, ri):\n        ri.keepalived_manager = keepalived.KeepalivedManager(\n            ri.router['id'],\n            keepalived.KeepalivedConf(),\n            conf_path=self.conf.ha_confs_path,\n            namespace=ri.ns_name(),\n            root_helper=self.root_helper)\n\n        config = ri.keepalived_manager.config\n\n        global_defs = keepalived.KeepalivedGlobaldefs()\n        global_defs.set_smtp_server(self.conf.ha_smtp_server,\n                                    self.conf.ha_smtp_timeout)\n        global_defs.set_email_from(self.conf.ha_notification_from)\n        global_defs.notification_emails = self.conf.ha_notification_emails\n        config.set_global_defs(global_defs)\n\n        group = keepalived.KeepalivedGroup(\n            HA_VIRTUAL_ROUTER_GROUP_PREFIX + str(ri.ha_vr_id))\n\n        interface_name = self.get_ha_device_name(ri.ha_port['id'])\n        instance = keepalived.KeepalivedInstance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id),\n            'BACKUP', interface_name, ri.ha_vr_id,\n            ri.ha_port['priority'], nopreempt=True,\n            advert_int=self.conf.ha_vrrp_advert_int,\n            garp_master_delay=self.conf.ha_garp_master_delay)\n        instance.track_interfaces.append(interface_name)\n\n        if self.conf.ha_vrrp_auth_password:\n            # TODO(safchain): use oslo.config types when it will be available\n            # in order to check the validity of ha_vrrp_auth_type\n            instance.set_authentication(self.conf.ha_vrrp_auth_type,\n                                        self.conf.ha_vrrp_auth_password)\n\n        group.add_instance(instance)\n\n        config.add_group(group)\n        config.add_instance(instance)\n\n    def _spawn_keepalived(self, ri):\n        if ri.ha_port:\n            ri.keepalived_manager.spawn_or_restart()\n            ri.keepalived_spawned = True\n\n    def _destroy_keepalived(self, ri):\n        if ri.keepalived_spawned:\n            ri.keepalived_manager.disable()\n            ri.keepalived_spawned = False\n\n    def process_router(self, ri):\n        ri.iptables_manager.defer_apply_on()\n        ex_gw_port = self._get_ex_gw_port(ri)\n        internal_ports = ri.router.get(l3_constants.INTERFACE_KEY, [])\n        existing_port_ids = set([p['id'] for p in ri.internal_ports])\n        current_port_ids = set([p['id'] for p in internal_ports\n                                if p['admin_state_up']])\n        new_ports = [p for p in internal_ports if\n                     p['id'] in current_port_ids and\n                     p['id'] not in existing_port_ids]\n        old_ports = [p for p in ri.internal_ports if\n                     p['id'] not in current_port_ids]\n        for p in new_ports:\n            self._set_subnet_info(p)\n            self.internal_network_added(ri, p['network_id'], p['id'],\n                                        p['ip_cidr'], p['mac_address'])\n            ri.internal_ports.append(p)\n\n        for p in old_ports:\n            self.internal_network_removed(ri, p['id'], p['ip_cidr'])\n            ri.internal_ports.remove(p)\n\n        internal_cidrs = [p['ip_cidr'] for p in ri.internal_ports]\n        # TODO(salv-orlando): RouterInfo would be a better place for\n        # this logic too\n        ex_gw_port_id = (ex_gw_port and ex_gw_port['id'] or\n                         ri.ex_gw_port and ri.ex_gw_port['id'])\n\n        interface_name = None\n        if ex_gw_port_id:\n            interface_name = self.get_external_device_name(ex_gw_port_id)\n        if ex_gw_port and not ri.ex_gw_port:\n            self._set_subnet_info(ex_gw_port)\n            self.external_gateway_added(ri, ex_gw_port,\n                                        interface_name, internal_cidrs)\n        elif not ex_gw_port and ri.ex_gw_port:\n            self.external_gateway_removed(ri, ri.ex_gw_port,\n                                          interface_name, internal_cidrs)\n\n        # Process static routes for router\n        self.routes_updated(ri)\n        # Process SNAT rules for external gateway\n        ri.perform_snat_action(self._handle_router_snat_rules,\n                               internal_cidrs, interface_name)\n\n        # Process SNAT/DNAT rules for floating IPs\n        fip_statuses = {}\n        try:\n            if ex_gw_port:\n                existing_floating_ips = ri.floating_ips\n                self.process_router_floating_ip_nat_rules(ri)\n                ri.iptables_manager.defer_apply_off()\n                # Once NAT rules for floating IPs are safely in place\n                # configure their addresses on the external gateway port\n                if ri.is_ha():\n                    fip_statuses = (\n                        self.process_ha_router_floating_ip_addresses(\n                            ri, ex_gw_port))\n                else:\n                    fip_statuses = self.process_router_floating_ip_addresses(\n                        ri, ex_gw_port)\n        except Exception:\n            # TODO(salv-orlando): Less broad catching\n            # All floating IPs must be put in error state\n            for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n                fip_statuses[fip] = l3_constants.FLOATINGIP_STATUS_ERROR\n\n        if ex_gw_port:\n            # Identify floating IPs which were disabled\n            ri.floating_ips = set(fip_statuses.keys())\n            for fip_id in existing_floating_ips - ri.floating_ips:\n                fip_statuses[fip_id] = l3_constants.FLOATINGIP_STATUS_DOWN\n            # Update floating IP status on the neutron server\n            self.plugin_rpc.update_floatingip_statuses(\n                self.context, ri.router_id, fip_statuses)\n\n        # Update ex_gw_port and enable_snat on the router info cache\n        ri.ex_gw_port = ex_gw_port\n        ri.enable_snat = ri.router.get('enable_snat')\n\n        if ri.is_ha():\n            self._spawn_keepalived(ri)\n\n    def _handle_router_snat_rules(self, ri, ex_gw_port, internal_cidrs,\n                                  interface_name, action):\n        # Remove all the rules\n        # This is safe because if use_namespaces is set as False\n        # then the agent can only configure one router, otherwise\n        # each router's SNAT rules will be in their own namespace\n        ri.iptables_manager.ipv4['nat'].empty_chain('POSTROUTING')\n        ri.iptables_manager.ipv4['nat'].empty_chain('snat')\n\n        # Add back the jump to float-snat\n        ri.iptables_manager.ipv4['nat'].add_rule('snat', '-j $float-snat')\n\n        # And add them back if the action if add_rules\n        if action == 'add_rules' and ex_gw_port:\n            # ex_gw_port should not be None in this case\n            ex_gw_ip = ex_gw_port['fixed_ips'][0]['ip_address']\n            for rule in self.external_gateway_nat_rules(ex_gw_ip,\n                                                        internal_cidrs,\n                                                        interface_name):\n                ri.iptables_manager.ipv4['nat'].add_rule(*rule)\n        ri.iptables_manager.apply()\n\n    def process_router_floating_ip_nat_rules(self, ri):\n        \"\"\"Configure NAT rules for the router's floating IPs.\n\n        Configures iptables rules for the floating ips of the given router\n        \"\"\"\n        # Clear out all iptables rules for floating ips\n        ri.iptables_manager.ipv4['nat'].clear_rules_by_tag('floating_ip')\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            # Rebuild iptables rules for the floating ip.\n            fixed = fip['fixed_ip_address']\n            fip_ip = fip['floating_ip_address']\n            for chain, rule in self.floating_forward_rules(fip_ip, fixed):\n                ri.iptables_manager.ipv4['nat'].add_rule(chain, rule,\n                                                         tag='floating_ip')\n\n        ri.iptables_manager.apply()\n\n    def _add_keepalived_vip(self, ri, ip_cidr, interface):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        vip_address = keepalived.KeepalivedVipAddress(ip_cidr, interface)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        vip_addresses.append(vip_address)\n        vip_addresses.sort(key=lambda vip: vip.ip_address)\n\n        # number of vip is limited to 20, so the first one will be used\n        # and the others will be not included in the protocol.\n        vip_address = vip_addresses.pop(0)\n        if vip_address:\n            instance.vip_addresses = [vip_address]\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n\n    def _remove_keepalived_vip(self, ri, ip_cidr=None, interface=None):\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        if interface:\n            instance.remove_vips_vroutes_by_interface(interface)\n        else:\n            instance.remove_vip_by_ip_address(ip_cidr)\n\n        vip_addresses = (instance.vip_addresses +\n                         instance.vip_addresses_excluded)\n        if vip_addresses:\n            vip_addresses.sort(key=lambda vip: vip.ip_address)\n            instance.vip_addresses = [vip_addresses.pop(0)]\n        else:\n            instance.vip_addresses = []\n\n        if vip_addresses:\n            instance.vip_addresses_excluded = vip_addresses\n        else:\n            instance.vip_addresses_excluded = []\n\n    def process_ha_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Add floating IP as VIP in the keepalived configuration.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n\n        instance = ri.keepalived_manager.config.get_instance(\n            HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n        existing_cidrs = set([vip.ip_address\n                              for vip in instance.vip_addresses])\n        new_cidrs = set()\n\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                self._add_keepalived_vip(ri, ip_cidr, interface_name)\n\n            # Floating IPs are managed by keepalived so should be active\n            # on one node\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                self._remove_keepalived_vip(ri, ip_cidr=ip_cidr)\n        return fip_statuses\n\n    def process_router_floating_ip_addresses(self, ri, ex_gw_port):\n        \"\"\"Configure IP addresses on router's external gateway interface.\n\n        Ensures addresses for existing floating IPs and cleans up\n        those that should not longer be configured.\n        \"\"\"\n        fip_statuses = {}\n        interface_name = self.get_external_device_name(ex_gw_port['id'])\n        device = ip_lib.IPDevice(interface_name, self.root_helper,\n                                 namespace=ri.ns_name())\n        existing_cidrs = set([addr['cidr'] for addr in device.addr.list()])\n        new_cidrs = set()\n\n        # Loop once to ensure that floating ips are configured.\n        for fip in ri.router.get(l3_constants.FLOATINGIP_KEY, []):\n            fip_ip = fip['floating_ip_address']\n            ip_cidr = str(fip_ip) + FLOATING_IP_CIDR_SUFFIX\n\n            new_cidrs.add(ip_cidr)\n\n            if ip_cidr not in existing_cidrs:\n                net = netaddr.IPNetwork(ip_cidr)\n                try:\n                    device.addr.add(net.version, ip_cidr,\n                                    str(net.broadcast))\n                except (processutils.UnknownArgumentError,\n                        processutils.ProcessExecutionError):\n                    # any exception occurred here should cause the floating IP\n                    # to be set in error state\n                    fip_statuses[fip['id']] = (\n                        l3_constants.FLOATINGIP_STATUS_ERROR)\n                    LOG.warn(_(\"Unable to configure IP address for \"\n                               \"floating IP: %s\"), fip['id'])\n                    continue\n                # As GARP is processed in a distinct thread the call below\n                # won't raise an exception to be handled.\n                if not ri.is_ha():\n                    self._send_gratuitous_arp_packet(ri, interface_name,\n                                                     fip_ip)\n            fip_statuses[fip['id']] = (\n                l3_constants.FLOATINGIP_STATUS_ACTIVE)\n\n        # Clean up addresses that no longer belong on the gateway interface.\n        for ip_cidr in existing_cidrs - new_cidrs:\n            if ip_cidr.endswith(FLOATING_IP_CIDR_SUFFIX):\n                net = netaddr.IPNetwork(ip_cidr)\n                device.addr.delete(net.version, ip_cidr)\n        return fip_statuses\n\n    def _get_ex_gw_port(self, ri):\n        return ri.router.get('gw_port')\n\n    def _arping(self, ri, interface_name, ip_address):\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      ip_address]\n        try:\n            ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                          namespace=ri.ns_name())\n            ip_wrapper.netns.execute(arping_cmd, check_exit_code=True)\n        except Exception as e:\n            LOG.error(_(\"Failed sending gratuitous ARP: %s\"), str(e))\n\n    def _send_gratuitous_arp_packet(self, ri, interface_name, ip_address):\n        if self.conf.send_arp_for_ha \u003e 0:\n            eventlet.spawn_n(self._arping, ri, interface_name, ip_address)\n\n    def get_internal_device_name(self, port_id):\n        return (INTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def get_external_device_name(self, port_id):\n        return (EXTERNAL_DEV_PREFIX + port_id)[:self.driver.DEV_NAME_LEN]\n\n    def external_gateway_added(self, ri, ex_gw_port,\n                               interface_name, internal_cidrs):\n\n        self.driver.plug(ex_gw_port['network_id'],\n                         ex_gw_port['id'], interface_name,\n                         ex_gw_port['mac_address'],\n                         bridge=self.conf.external_network_bridge,\n                         namespace=ri.ns_name(),\n                         prefix=EXTERNAL_DEV_PREFIX)\n\n        # Compute a list of addresses this router is supposed to have.\n        # This avoids unnecessarily removing those addresses and\n        # causing a momentarily network outage.\n        floating_ips = ri.router.get(l3_constants.FLOATINGIP_KEY, [])\n        preserve_ips = [ip['floating_ip_address'] + FLOATING_IP_CIDR_SUFFIX\n                        for ip in floating_ips]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, ex_gw_port['ip_cidr'],\n                                     interface_name)\n        else:\n            self.driver.init_l3(interface_name, [ex_gw_port['ip_cidr']],\n                                namespace=ri.ns_name(),\n                                preserve_ips=preserve_ips)\n            ip_address = ex_gw_port['ip_cidr'].split('/')[0]\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n        gw_ip = ex_gw_port['subnet']['gateway_ip']\n        if ex_gw_port['subnet']['gateway_ip']:\n            if ri.is_ha():\n                instance = ri.keepalived_manager.config.get_instance(\n                    HA_VIRTUAL_ROUTER_NAME_PREFIX + str(ri.ha_vr_id))\n                vroute = keepalived.KeepalivedVirtualRoute(\n                    '0.0.0.0/0', gw_ip, interface_name)\n                instance.virtual_routes.append(vroute)\n            else:\n                cmd = ['route', 'add', 'default', 'gw', gw_ip]\n                ip_wrapper = ip_lib.IPWrapper(self.root_helper,\n                                              namespace=ri.ns_name())\n                ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def external_gateway_removed(self, ri, ex_gw_port,\n                                 interface_name, internal_cidrs):\n\n        if ri.is_ha():\n            self._remove_keepalived_vip(ri, interface=interface_name)\n\n        self.driver.unplug(interface_name,\n                           bridge=self.conf.external_network_bridge,\n                           namespace=ri.ns_name(),\n                           prefix=EXTERNAL_DEV_PREFIX)\n\n    def metadata_filter_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                          '-p tcp -m tcp --dport %s '\n                          '-j ACCEPT' % self.conf.metadata_port))\n        return rules\n\n    def metadata_nat_rules(self):\n        rules = []\n        if self.conf.enable_metadata_proxy:\n            rules.append(('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                          '-p tcp -m tcp --dport 80 -j REDIRECT '\n                          '--to-port %s' % self.conf.metadata_port))\n        return rules\n\n    def external_gateway_nat_rules(self, ex_gw_ip, internal_cidrs,\n                                   interface_name):\n        rules = [('POSTROUTING', '! -i %(interface_name)s '\n                  '! -o %(interface_name)s -m conntrack ! '\n                  '--ctstate DNAT -j ACCEPT' %\n                  {'interface_name': interface_name})]\n        for cidr in internal_cidrs:\n            rules.extend(self.internal_network_nat_rules(ex_gw_ip, cidr))\n        return rules\n\n    def internal_network_added(self, ri, network_id, port_id,\n                               internal_cidr, mac_address):\n        interface_name = self.get_internal_device_name(port_id)\n        if not ip_lib.device_exists(interface_name,\n                                    root_helper=self.root_helper,\n                                    namespace=ri.ns_name()):\n            self.driver.plug(network_id, port_id, interface_name, mac_address,\n                             namespace=ri.ns_name(),\n                             prefix=INTERNAL_DEV_PREFIX)\n\n        ip_address = internal_cidr.split('/')[0]\n\n        if ri.is_ha():\n            self._add_keepalived_vip(ri, internal_cidr, interface_name)\n        else:\n            self.driver.init_l3(interface_name, [internal_cidr],\n                                namespace=ri.ns_name())\n            self._send_gratuitous_arp_packet(ri, interface_name, ip_address)\n\n    def internal_network_removed(self, ri, port_id, internal_cidr):\n        interface_name = self.get_internal_device_name(port_id)\n        if ip_lib.device_exists(interface_name,\n                                root_helper=self.root_helper,\n                                namespace=ri.ns_name()):\n            if ri.is_ha():\n                self._remove_keepalived_vip(ri, ip_cidr=internal_cidr)\n\n            self.driver.unplug(interface_name, namespace=ri.ns_name(),\n                               prefix=INTERNAL_DEV_PREFIX)\n\n    def internal_network_nat_rules(self, ex_gw_ip, internal_cidr):\n        rules = [('snat', '-s %s -j SNAT --to-source %s' %\n                 (internal_cidr, ex_gw_ip))]\n        return rules\n\n    def floating_forward_rules(self, floating_ip, fixed_ip):\n        return [('PREROUTING', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('OUTPUT', '-d %s -j DNAT --to %s' %\n                 (floating_ip, fixed_ip)),\n                ('float-snat', '-s %s -j SNAT --to %s' %\n                 (fixed_ip, floating_ip))]\n\n    def router_deleted(self, context, router_id):\n        \"\"\"Deal with router deletion RPC message.\"\"\"\n        LOG.debug(_('Got router deleted notification for %s'), router_id)\n        self.removed_routers.add(router_id)\n\n    def routers_updated(self, context, routers):\n        \"\"\"Deal with routers modification and creation RPC message.\"\"\"\n        LOG.debug(_('Got routers updated notification :%s'), routers)\n        if routers:\n            # This is needed for backward compatibility\n            if isinstance(routers[0], dict):\n                routers = [router['id'] for router in routers]\n            self.updated_routers.update(routers)\n\n    def router_removed_from_agent(self, context, payload):\n        LOG.debug(_('Got router removed from agent :%r'), payload)\n        self.removed_routers.add(payload['router_id'])\n\n    def router_added_to_agent(self, context, payload):\n        LOG.debug(_('Got router added to agent :%r'), payload)\n        self.routers_updated(context, payload)\n\n    def _process_routers(self, routers, all_routers=False):\n        pool = eventlet.GreenPool()\n        if (self.conf.external_network_bridge and\n            not ip_lib.device_exists(self.conf.external_network_bridge)):\n            LOG.error(_(\"The external network bridge '%s' does not exist\"),\n                      self.conf.external_network_bridge)\n            return\n\n        target_ex_net_id = self._fetch_external_net_id()\n        # if routers are all the routers we have (They are from router sync on\n        # starting or when error occurs during running), we seek the\n        # routers which should be removed.\n        # If routers are from server side notification, we seek them\n        # from subset of incoming routers and ones we have now.\n        if all_routers:\n            prev_router_ids = set(self.router_info)\n        else:\n            prev_router_ids = set(self.router_info) \u0026 set(\n                [router['id'] for router in routers])\n        cur_router_ids = set()\n        for r in routers:\n            if not r['admin_state_up']:\n                continue\n\n            # If namespaces are disabled, only process the router associated\n            # with the configured agent id.\n            if (not self.conf.use_namespaces and\n                r['id'] != self.conf.router_id):\n                continue\n            ex_net_id = (r['external_gateway_info'] or {}).get('network_id')\n            if not ex_net_id and not self.conf.handle_internal_only_routers:\n                continue\n            if (target_ex_net_id and ex_net_id and\n                ex_net_id != target_ex_net_id):\n                # Double check that our single external_net_id has not changed\n                # by forcing a check by RPC.\n                if (ex_net_id != self._fetch_external_net_id(force=True)):\n                    continue\n            cur_router_ids.add(r['id'])\n            if r['id'] not in self.router_info:\n                self._router_added(r['id'], r)\n            ri = self.router_info[r['id']]\n            ri.router = r\n            pool.spawn_n(self.process_router, ri)\n        # identify and remove routers that no longer exist\n        for router_id in prev_router_ids - cur_router_ids:\n            pool.spawn_n(self._router_removed, router_id)\n        pool.waitall()\n\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _rpc_loop(self):\n        # _rpc_loop and _sync_routers_task will not be\n        # executed in the same time because of lock.\n        # so we can clear the value of updated_routers\n        # and removed_routers\n        try:\n            LOG.debug(_(\"Starting RPC loop for %d updated routers\"),\n                      len(self.updated_routers))\n            if self.updated_routers:\n                router_ids = list(self.updated_routers)\n                self.updated_routers.clear()\n                routers = self.plugin_rpc.get_routers(\n                    self.context, router_ids)\n                self._process_routers(routers)\n            self._process_router_delete()\n            LOG.debug(_(\"RPC loop successfully completed\"))\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n    def _process_router_delete(self):\n        current_removed_routers = list(self.removed_routers)\n        for router_id in current_removed_routers:\n            self._router_removed(router_id)\n            self.removed_routers.remove(router_id)\n\n    def _router_ids(self):\n        if not self.conf.use_namespaces:\n            return [self.conf.router_id]\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _check_keepalived_alive(self, context):\n        router_infos = self.router_info.values()\n        for ri in router_infos:\n            if ri.ha_port:\n                if not ri.keepalived_spawned:\n                    continue\n\n                if not ri.keepalived_manager.pm.active:\n                    LOG.warn(_('Keepalived instance for %s seems to be dead, '\n                               'tryng restart it'), ri.router['id'])\n                    self._spawn_keepalived(ri)\n\n    @periodic_task.periodic_task\n    @lockutils.synchronized('l3-agent', 'neutron-')\n    def _sync_routers_task(self, context):\n        if self.services_sync:\n            super(L3NATAgent, self).process_services_sync(context)\n        LOG.debug(_(\"Starting _sync_routers_task - fullsync:%s\"),\n                  self.fullsync)\n        if not self.fullsync:\n            return\n        try:\n            router_ids = self._router_ids()\n            self.updated_routers.clear()\n            self.removed_routers.clear()\n            routers = self.plugin_rpc.get_routers(\n                context, router_ids)\n\n            LOG.debug(_('Processing :%r'), routers)\n            self._process_routers(routers, all_routers=True)\n            self.fullsync = False\n            LOG.debug(_(\"_sync_routers_task successfully completed\"))\n        except rpc_common.RPCException:\n            LOG.exception(_(\"Failed synchronizing routers due to RPC error\"))\n            self.fullsync = True\n            return\n        except Exception:\n            LOG.exception(_(\"Failed synchronizing routers\"))\n            self.fullsync = True\n\n        # Resync is not necessary for the cleanup of stale\n        # namespaces.\n        if self._delete_stale_namespaces:\n            self._cleanup_namespaces(routers)\n\n    def after_start(self):\n        LOG.info(_(\"L3 agent started\"))\n\n    def _update_routing_table(self, ri, operation, route):\n        cmd = ['ip', 'route', operation, 'to', route['destination'],\n               'via', route['nexthop']]\n        ip_wrapper = ip_lib.IPWrapper(self.conf.root_helper,\n                                      namespace=ri.ns_name())\n        ip_wrapper.netns.execute(cmd, check_exit_code=False)\n\n    def routes_updated(self, ri):\n        new_routes = ri.router['routes']\n        old_routes = ri.routes\n        adds, removes = common_utils.diff_list_of_dict(old_routes,\n                                                       new_routes)\n        for route in adds:\n            LOG.debug(_(\"Added route entry is '%s'\"), route)\n            # remove replaced route from deleted route\n            for del_route in removes:\n                if route['destination'] == del_route['destination']:\n                    removes.remove(del_route)\n            #replace success even if there is no existing route\n            self._update_routing_table(ri, 'replace', route)\n        for route in removes:\n            LOG.debug(_(\"Removed route entry is '%s'\"), route)\n            self._update_routing_table(ri, 'delete', route)\n        ri.routes = new_routes\n\n\nclass L3NATAgentWithStateReport(L3NATAgent):\n\n    def __init__(self, host, conf=None):\n        super(L3NATAgentWithStateReport, self).__init__(host=host, conf=conf)\n        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)\n        self.agent_state = {\n            'binary': 'neutron-l3-agent',\n            'host': host,\n            'topic': topics.L3_AGENT,\n            'configurations': {\n                'use_namespaces': self.conf.use_namespaces,\n                'router_id': self.conf.router_id,\n                'handle_internal_only_routers':\n                self.conf.handle_internal_only_routers,\n                'gateway_external_network_id':\n                self.conf.gateway_external_network_id,\n                'interface_driver': self.conf.interface_driver},\n            'start_flag': True,\n            'agent_type': l3_constants.AGENT_TYPE_L3}\n        report_interval = cfg.CONF.AGENT.report_interval\n        self.use_call = True\n        if report_interval:\n            self.heartbeat = loopingcall.FixedIntervalLoopingCall(\n                self._report_state)\n            self.heartbeat.start(interval=report_interval)\n\n    def _report_state(self):\n        LOG.debug(_(\"Report state task started\"))\n        num_ex_gw_ports = 0\n        num_interfaces = 0\n        num_floating_ips = 0\n        router_infos = self.router_info.values()\n        num_routers = len(router_infos)\n        for ri in router_infos:\n            ex_gw_port = self._get_ex_gw_port(ri)\n            if ex_gw_port:\n                num_ex_gw_ports += 1\n            num_interfaces += len(ri.router.get(l3_constants.INTERFACE_KEY,\n                                                []))\n            num_floating_ips += len(ri.router.get(l3_constants.FLOATINGIP_KEY,\n                                                  []))\n        configurations = self.agent_state['configurations']\n        configurations['routers'] = num_routers\n        configurations['ex_gw_ports'] = num_ex_gw_ports\n        configurations['interfaces'] = num_interfaces\n        configurations['floating_ips'] = num_floating_ips\n        try:\n            self.state_rpc.report_state(self.context, self.agent_state,\n                                        self.use_call)\n            self.agent_state.pop('start_flag', None)\n            self.use_call = False\n            LOG.debug(_(\"Report state task successfully completed\"))\n        except AttributeError:\n            # This means the server does not support report_state\n            LOG.warn(_(\"Neutron server does not support state report.\"\n                       \" State report for this agent will be disabled.\"))\n            self.heartbeat.stop()\n            return\n        except Exception:\n            LOG.exception(_(\"Failed reporting state!\"))\n\n    def agent_updated(self, context, payload):\n        \"\"\"Handle the agent_updated notification event.\"\"\"\n        self.fullsync = True\n        LOG.info(_(\"agent_updated by server side %s!\"), payload)\n\n\ndef main(manager='neutron.agent.l3_agent.L3NATAgentWithStateReport'):\n    eventlet.monkey_patch()\n    conf = cfg.CONF\n    conf.register_opts(L3NATAgent.OPTS)\n    config.register_interface_driver_opts_helper(conf)\n    config.register_use_namespaces_opts_helper(conf)\n    config.register_agent_state_opts_helper(conf)\n    config.register_root_helper(conf)\n    conf.register_opts(interface.OPTS)\n    conf.register_opts(external_process.OPTS)\n    conf(project='neutron')\n    config.setup_logging(conf)\n    legacy.modernize_quantum_config(conf)\n    server = neutron_service.Service.create(\n        binary='neutron-l3-agent',\n        topic=topics.L3_AGENT,\n        report_interval=cfg.CONF.AGENT.report_interval,\n        manager=manager)\n    service.launch(server).wait()","comments":[{"author":{"accountId":2874,"email":"gongysh@unitedstack.com","name":"gongysh","username":"gongysh"},"date":"2014-04-09T08:29:05.000Z","id":"AAAAW3%2F%2F9ek%3D","line":7,"message":"I think we can separate the ha related stuff into one mixin class in another file."},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-04-10T16:11:49.000Z","id":"AAAAW3%2F%2FwU0%3D","line":7,"message":"I agree with you"},{"author":{"accountId":2874,"email":"gongysh@unitedstack.com","name":"gongysh","username":"gongysh"},"date":"2014-04-09T08:29:05.000Z","id":"AAAAW3%2F%2F9e0%3D","line":823,"message":"no point of making format change"},{"author":{"accountId":2874,"email":"gongysh@unitedstack.com","name":"gongysh","username":"gongysh"},"date":"2014-04-09T08:29:05.000Z","id":"AAAAW3%2F%2F9e4%3D","line":836,"message":"no need to do this branch since we have a guard at line 654"},{"author":{"accountId":2874,"email":"gongysh@unitedstack.com","name":"gongysh","username":"gongysh"},"date":"2014-04-09T08:29:05.000Z","id":"AAAAW3%2F%2F9iQ%3D","line":977,"message":"why don't remove by interface just like the gateway interface?"}],"name":"neutron/agent/l3_agent.py"},"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestVarmourRouter(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestVarmourRouter, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def test_agent_add_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        self._add_internal_ports(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_internal_network(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        self._add_internal_ports(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_internal_ports(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_internal_ports(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_add_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        self._add_floating_ips(ri.router, port_count=1)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._add_floating_ips(ri.router, port_count=2)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_remove_floating_ips(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=2)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_dnat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 2, 'prefix %s' % prefix)\n\n        self._del_floating_ips(ri.router, 0)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        self._del_all_floating_ips(ri.router)\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_external_gateway(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_ZONE\n        prefix = varmour_utils.get_untrusted_zone_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        del ri.router['gw_port']\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 1, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n    def test_agent_snat_enable(self):\n        router = self._create_router()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        router._router_added(ri.router['id'], ri.router)\n\n        url = varmour_utils.REST_URL_CONF_NAT_RULE\n        prefix = varmour_utils.get_snat_rule_name(ri)\n\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        ri.router['enable_snat'] = False\n        router.process_router(ri)\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)\n\n        router._router_removed(ri.router['id'])\n        n = router.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0, 'prefix %s' % prefix)","comments":[],"name":"neutron/tests/unit/services/firewall/agents/varmour/test_varmour_router.py"},"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py":{"a":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\nfrom oslo.config import cfg\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","b":"# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright 2013 vArmour Networks Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n#\n# @author: Gary Duan, vArmour Networks Inc.\n#\n\n\nimport mock\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.openstack.common import uuidutils\nfrom neutron.services.firewall.agents.varmour import varmour_router\nfrom neutron.services.firewall.agents.varmour import varmour_utils\nfrom neutron.services.firewall.drivers.varmour import varmour_fwaas\nfrom neutron.tests import base\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_DIRECTOR = '1.1.1.1'\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(varmour_router.vArmourL3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def _create_router(self):\n        router = varmour_router.vArmourL3NATAgent(HOSTNAME, self.conf)\n        router.rest.server = FAKE_DIRECTOR\n        router.rest.user = 'varmour'\n        router.rest.passwd = 'varmour'\n        return router\n\n    def _create_fwaas(self):\n        fwaas = varmour_fwaas.vArmourFwaasDriver()\n        fwaas.rest.server = FAKE_DIRECTOR\n        fwaas.rest.user = 'varmour'\n        fwaas.rest.passwd = 'varmour'\n        return fwaas\n\n    def _del_all_internal_ports(self, router):\n        router[l3_constants.INTERFACE_KEY] = []\n\n    def _del_internal_ports(self, router, port_idx):\n        del router[l3_constants.INTERFACE_KEY][port_idx]\n\n    def _add_internal_ports(self, router, port_count=1):\n        self._del_all_internal_ports(router)\n        for i in range(port_count):\n            port = {'id': _uuid(),\n                    'network_id': _uuid(),\n                    'admin_state_up': True,\n                    'fixed_ips': [{'ip_address': '10.0.%s.4' % i,\n                                   'subnet_id': _uuid()}],\n                    'mac_address': 'ca:fe:de:ad:be:ef',\n                    'subnet': {'cidr': '10.0.%s.0/24' % i,\n                               'gateway_ip': '10.0.%s.1' % i}}\n            router[l3_constants.INTERFACE_KEY].append(port)\n\n    def _del_all_floating_ips(self, router):\n        router[l3_constants.FLOATINGIP_KEY] = []\n\n    def _del_floating_ips(self, router, port_idx):\n        del router[l3_constants.FLOATINGIP_KEY][port_idx]\n\n    def _add_floating_ips(self, router, port_count=1):\n        self._del_all_floating_ips(router)\n        for i in range(port_count):\n            fip = {'id': _uuid(),\n                   'port_id': router['gw_port']['id'],\n                   'floating_ip_address': '172.24.4.%s' % (100 + i),\n                   'fixed_ip_address': '10.0.0.%s' % (100 + i)}\n            router[l3_constants.FLOATINGIP_KEY].append(fip)\n\n    def _prepare_router_data(self, enable_snat=None):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '172.24.4.2',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '172.24.4.0/24',\n                                 'gateway_ip': '172.24.4.1'},\n                      'ip_cidr': '172.24.4.226/28'}\n        int_ports = []\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        return ri\n\n    def _add_firewall_rules(self, fw, rule_count=1):\n        rules = []\n        for i in range(rule_count):\n            rule = {'id': _uuid(),\n                    'enabled': True,\n                    'action': 'deny' if (i % 2 == 0) else 'allow',\n                    'ip_version': 4,\n                    'protocol': 'tcp',\n                    'source_ip_address': '10.0.0.%s/24' % (100 + i),\n                    'destination_port': '%s' % (100 + i)}\n            rules.append(rule)\n        fw['firewall_rule_list'] = rules\n\n    def _prepare_firewall_data(self):\n        fw = {'id': _uuid(),\n              'admin_state_up': True,\n              'firewall_rule_list': []}\n        return fw\n\n    def test_firewall_without_rule(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        fwaas.create_firewall(rl, fw)\n\n        url = varmour_utils.REST_URL_CONF_POLICY\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_with_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])\n\n    def test_firewall_add_remove_rules(self):\n        router = self._create_router()\n        fwaas = self._create_fwaas()\n        try:\n            router.rest.auth()\n        except Exception:\n            # skip the test, firewall is not deployed\n            return\n\n        ri = self._prepare_router_data(enable_snat=True)\n        self._add_internal_ports(ri.router, port_count=1)\n        self._add_floating_ips(ri.router, port_count=1)\n        router._router_added(ri.router['id'], ri.router)\n\n        rl = [ri]\n\n        fw = self._prepare_firewall_data()\n        self._add_firewall_rules(fw, 2)\n        fwaas.create_firewall(rl, fw)\n\n        prefix = varmour_utils.get_firewall_object_prefix(ri, fw)\n        pol_url = varmour_utils.REST_URL_CONF_POLICY\n        serv_url = varmour_utils.REST_URL_CONF_SERVICE\n        addr_url = varmour_utils.REST_URL_CONF_ADDR\n\n        # 3x number of policies\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 6)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 2)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 2)\n\n        self._add_firewall_rules(fw, 1)\n        fwaas.create_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 3)\n        n = fwaas.rest.count_cfg_objs(addr_url, prefix)\n        self.assertEqual(n, 1)\n        n = fwaas.rest.count_cfg_objs(serv_url, prefix)\n        self.assertEqual(n, 1)\n\n        fwaas.delete_firewall(rl, fw)\n        n = fwaas.rest.count_cfg_objs(pol_url, prefix)\n        self.assertEqual(n, 0)\n\n        router._router_removed(ri.router['id'])","comments":[],"name":"neutron/tests/unit/services/firewall/drivers/varmour/test_varmour_fwaas.py"},"neutron/tests/unit/test_l3_agent.py":{"a":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = cfg.ConfigOpts()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ns = 'qrouter-' + router_id\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(router_id, ns)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ns),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()","b":"# Copyright 2012 VMware, Inc.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport contextlib\nimport copy\n\nimport mock\nfrom oslo.config import cfg\nfrom testtools import matchers\n\nfrom neutron.agent.common import config as agent_config\nfrom neutron.agent import l3_agent\nfrom neutron.agent.linux import interface\nfrom neutron.common import config as base_config\nfrom neutron.common import constants as l3_constants\nfrom neutron.common import exceptions as n_exc\nfrom neutron.openstack.common import processutils\nfrom neutron.openstack.common import uuidutils\nfrom neutron.tests import base\n\n\n_uuid = uuidutils.generate_uuid\nHOSTNAME = 'myhost'\nFAKE_ID = _uuid()\n\n\nclass TestBasicRouterOperations(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestBasicRouterOperations, self).setUp()\n        self.conf = agent_config.setup_conf()\n        self.conf.register_opts(base_config.core_opts)\n        self.conf.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(self.conf)\n        agent_config.register_use_namespaces_opts_helper(self.conf)\n        agent_config.register_root_helper(self.conf)\n        self.conf.register_opts(interface.OPTS)\n        self.conf.set_override('router_id', 'fake_id')\n        self.conf.set_override('interface_driver',\n                               'neutron.agent.linux.interface.NullDriver')\n        self.conf.set_override('send_arp_for_ha', 1)\n        self.conf.set_override('state_path', '')\n        self.conf.root_helper = 'sudo'\n\n        self.device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        self.device_exists = self.device_exists_p.start()\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        self.utils_exec = self.utils_exec_p.start()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager')\n        self.external_process = self.external_process_p.start()\n\n        self.send_arp_p = mock.patch(\n            'neutron.agent.l3_agent.L3NATAgent._send_gratuitous_arp_packet')\n        self.send_arp = self.send_arp_p.start()\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        self.dvr_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = self.dvr_cls_p.start()\n        self.mock_driver = mock.MagicMock()\n        self.mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = self.mock_driver\n\n        self.ip_cls_p = mock.patch('neutron.agent.linux.ip_lib.IPWrapper')\n        ip_cls = self.ip_cls_p.start()\n        self.mock_ip = mock.MagicMock()\n        ip_cls.return_value = self.mock_ip\n\n        self.l3pluginApi_cls_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3pluginApi_cls = self.l3pluginApi_cls_p.start()\n        self.plugin_api = mock.Mock()\n        l3pluginApi_cls.return_value = self.plugin_api\n\n        self.looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        self.looping_call_p.start()\n\n        self.addCleanup(mock.patch.stopall)\n\n    def test_router_info_create(self):\n        id = _uuid()\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n\n        self.assertTrue(ri.ns_name().endswith(id))\n\n    def test_router_info_create_with_router(self):\n        id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        ri = l3_agent.RouterInfo(id, self.conf.root_helper,\n                                 self.conf.use_namespaces, router)\n        self.assertTrue(ri.ns_name().endswith(id))\n        self.assertEqual(ri.router, router)\n\n    def test_agent_create(self):\n        l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n    def _test_internal_network_action(self, action):\n        port_id = _uuid()\n        router_id = _uuid()\n        network_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        cidr = '99.0.1.9/24'\n        mac = 'ca:fe:de:ad:be:ef'\n        interface_name = agent.get_internal_device_name(port_id)\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            agent.internal_network_added(ri, network_id,\n                                         port_id, cidr, mac)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '99.0.1.9')\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.internal_network_removed(ri, port_id, cidr)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_internal_network(self):\n        self._test_internal_network_action('add')\n\n    def test_agent_remove_internal_network(self):\n        self._test_internal_network_action('remove')\n\n    def _test_external_gateway_action(self, action):\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        internal_cidrs = ['100.0.1.0/24', '200.74.0.0/16']\n        ex_gw_port = {'fixed_ips': [{'ip_address': '20.0.0.30',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'gateway_ip': '20.0.0.1'},\n                      'id': _uuid(),\n                      'network_id': _uuid(),\n                      'mac_address': 'ca:fe:de:ad:be:ef',\n                      'ip_cidr': '20.0.0.30/24'}\n        interface_name = agent.get_external_device_name(ex_gw_port['id'])\n\n        if action == 'add':\n            self.device_exists.return_value = False\n            ri.router = mock.Mock()\n            ri.router.get.return_value = [{'floating_ip_address':\n                                           '192.168.1.34'}]\n            agent.external_gateway_added(ri, ex_gw_port,\n                                         interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.plug.call_count, 1)\n            self.assertEqual(self.mock_driver.init_l3.call_count, 1)\n            self.send_arp.assert_called_once_with(ri, interface_name,\n                                                  '20.0.0.30')\n            kwargs = {'preserve_ips': ['192.168.1.34/32'],\n                      'namespace': 'qrouter-' + router_id}\n            self.mock_driver.init_l3.assert_called_with(interface_name,\n                                                        ['20.0.0.30/24'],\n                                                        **kwargs)\n\n        elif action == 'remove':\n            self.device_exists.return_value = True\n            agent.external_gateway_removed(ri, ex_gw_port,\n                                           interface_name, internal_cidrs)\n            self.assertEqual(self.mock_driver.unplug.call_count, 1)\n        else:\n            raise Exception(\"Invalid action %s\" % action)\n\n    def test_agent_add_external_gateway(self):\n        self._test_external_gateway_action('add')\n\n    def _test_arping(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        floating_ip = '20.0.0.101'\n        interface_name = agent.get_external_device_name(router_id)\n        agent._arping(ri, interface_name, floating_ip)\n\n        arping_cmd = ['arping', '-A',\n                      '-I', interface_name,\n                      '-c', self.conf.send_arp_for_ha,\n                      floating_ip]\n        self.mock_ip.netns.execute.assert_any_call(\n            arping_cmd, check_exit_code=True)\n\n    def test_arping_namespace(self):\n        self._test_arping(namespace=True)\n\n    def test_arping_no_namespace(self):\n        self._test_arping(namespace=False)\n\n    def test_agent_remove_external_gateway(self):\n        self._test_external_gateway_action('remove')\n\n    def _check_agent_method_called(self, agent, calls, namespace):\n        self.mock_ip.netns.execute.assert_has_calls(\n            [mock.call(call, check_exit_code=False) for call in calls],\n            any_order=True)\n\n    def _test_routing_table_update(self, namespace):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n\n        router_id = _uuid()\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fake_route1 = {'destination': '135.207.0.0/16',\n                       'nexthop': '1.2.3.4'}\n        fake_route2 = {'destination': '135.207.111.111/32',\n                       'nexthop': '1.2.3.4'}\n\n        agent._update_routing_table(ri, 'replace', fake_route1)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route1)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.0.0/16',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'replace', fake_route2)\n        expected = [['ip', 'route', 'replace', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n        agent._update_routing_table(ri, 'delete', fake_route2)\n        expected = [['ip', 'route', 'delete', 'to', '135.207.111.111/32',\n                     'via', '1.2.3.4']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def test_agent_routing_table_updated(self):\n        self._test_routing_table_update(namespace=True)\n\n    def test_agent_routing_table_updated_no_namespace(self):\n        self._test_routing_table_update(namespace=False)\n\n    def test_routes_updated(self):\n        self._test_routes_updated(namespace=True)\n\n    def test_routes_updated_no_namespace(self):\n        self._test_routes_updated(namespace=False)\n\n    def _test_routes_updated(self, namespace=True):\n        if not namespace:\n            self.conf.set_override('use_namespaces', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n\n        ri = l3_agent.RouterInfo(router_id, self.conf.root_helper,\n                                 self.conf.use_namespaces,\n                                 None)\n        ri.router = {}\n\n        fake_old_routes = []\n        fake_new_routes = [{'destination': \"110.100.31.0/24\",\n                            'nexthop': \"10.100.10.30\"},\n                           {'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.routes = fake_old_routes\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'replace', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30'],\n                    ['ip', 'route', 'replace', 'to', '110.100.31.0/24',\n                     'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n\n        fake_new_routes = [{'destination': \"110.100.30.0/24\",\n                            'nexthop': \"10.100.10.30\"}]\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n        expected = [['ip', 'route', 'delete', 'to', '110.100.31.0/24',\n                    'via', '10.100.10.30']]\n\n        self._check_agent_method_called(agent, expected, namespace)\n        fake_new_routes = []\n        ri.router['routes'] = fake_new_routes\n        agent.routes_updated(ri)\n\n        expected = [['ip', 'route', 'delete', 'to', '110.100.30.0/24',\n                    'via', '10.100.10.30']]\n        self._check_agent_method_called(agent, expected, namespace)\n\n    def _verify_snat_rules(self, rules, router, negate=False):\n        interfaces = router[l3_constants.INTERFACE_KEY]\n        source_cidrs = []\n        for interface in interfaces:\n            prefix = interface['subnet']['cidr'].split('/')[1]\n            source_cidr = \"%s/%s\" % (interface['fixed_ips'][0]['ip_address'],\n                                     prefix)\n            source_cidrs.append(source_cidr)\n        source_nat_ip = router['gw_port']['fixed_ips'][0]['ip_address']\n        interface_name = ('qg-%s' % router['gw_port']['id'])[:14]\n        expected_rules = [\n            '! -i %s ! -o %s -m conntrack ! --ctstate DNAT -j ACCEPT' %\n            (interface_name, interface_name)]\n        for source_cidr in source_cidrs:\n            value_dict = {'source_cidr': source_cidr,\n                          'source_nat_ip': source_nat_ip}\n            expected_rules.append('-s %(source_cidr)s -j SNAT --to-source '\n                                  '%(source_nat_ip)s' % value_dict)\n        for r in rules:\n            if negate:\n                self.assertNotIn(r.rule, expected_rules)\n            else:\n                self.assertIn(r.rule, expected_rules)\n\n    def _get_ha_interfaces(self, port_id=_uuid()):\n        return [{'admin_sta[e_up': True,\n                 'device_id': _uuid(),\n                 'device_owner': 'network:router_ha_interface',\n                 'fixed_ips': [{'ip_address': '169.254.0.2',\n                                'subnet_id': _uuid()}],\n                 'id': port_id,\n                 'mac_address': '12:34:56:78:2b:5d',\n                 'name': u'L3 HA Admin port 0',\n                 'network_id': _uuid(),\n                 'status': u'ACTIVE',\n                 'subnet': {'cidr': '169.254.0.0/24',\n                            'gateway_ip': '169.254.0.1',\n                            'id': _uuid()},\n                 'tenant_id': '',\n                 'agent_id': _uuid(),\n                 'agent_host': 'aaa',\n                 'priority': 1}]\n\n    def _prepare_router_data(self, enable_snat=None, num_internal_ports=1,\n                             enable_ha=False):\n        router_id = _uuid()\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'mac_address': '62:46:c1:3e:30:d0',\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        int_ports = []\n        for i in range(num_internal_ports):\n            int_ports.append({'id': _uuid(),\n                              'network_id': _uuid(),\n                              'admin_state_up': True,\n                              'fixed_ips': [{'ip_address': '35.4.%s.4' % i,\n                                             'subnet_id': _uuid()}],\n                              'mac_address': 'ca:fe:de:ad:be:ef',\n                              'subnet': {'cidr': '35.4.%s.0/24' % i,\n                                         'gateway_ip': '35.4.%s.1' % i}})\n\n        router = {\n            'id': router_id,\n            l3_constants.INTERFACE_KEY: int_ports,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        if enable_snat is not None:\n            router['enable_snat'] = enable_snat\n\n        if enable_ha:\n            router['ha_vr_id'] = 1\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces()\n\n        return router\n\n    def test_process_router(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        fake_fip_id = 'fake_fip_id'\n        agent.process_router_floating_ip_addresses = mock.Mock()\n        agent.process_router_floating_ip_nat_rules = mock.Mock()\n        agent.process_router_floating_ip_addresses.return_value = {\n            fake_fip_id: 'ACTIVE'}\n        agent.external_gateway_added = mock.Mock()\n        router = self._prepare_router_data()\n        fake_floatingips1 = {'floatingips': [\n            {'id': fake_fip_id,\n             'floating_ip_address': '8.8.8.8',\n             'fixed_ip_address': '7.7.7.7',\n             'port_id': _uuid()}]}\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remap floating IP to a new fixed ip\n        fake_floatingips2 = copy.deepcopy(fake_floatingips1)\n        fake_floatingips2['floatingips'][0]['fixed_ip_address'] = '7.7.7.8'\n\n        router[l3_constants.FLOATINGIP_KEY] = fake_floatingips2['floatingips']\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # remove just the floating ips\n        del router[l3_constants.FLOATINGIP_KEY]\n        agent.process_router(ri)\n        ex_gw_port = agent._get_ex_gw_port(ri)\n        agent.process_router_floating_ip_addresses.assert_called_with(\n            ri, ex_gw_port)\n        agent.process_router_floating_ip_addresses.reset_mock()\n        agent.process_router_floating_ip_nat_rules.assert_called_with(ri)\n        agent.process_router_floating_ip_nat_rules.reset_mock()\n\n        # now no ports so state is torn down\n        del router[l3_constants.INTERFACE_KEY]\n        del router['gw_port']\n        agent.process_router(ri)\n        self.send_arp.assert_called_once()\n        self.assertFalse(agent.process_router_floating_ip_addresses.called)\n        self.assertFalse(agent.process_router_floating_ip_nat_rules.called)\n\n    def test_process_ha_router(self):\n        self.is_ha_p.stop()\n        self.external_process_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router,\n                                 self.conf.ha_confs_path)\n        ri.router = router\n\n        self.device_exists.return_value = False\n\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.execute')) as (spawn,\n                                                                replace,\n                                                                execute):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            ex_iface = agent.get_external_device_name(\n                ri.ex_gw_port['id'])\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            int_iface = agent.get_internal_device_name(\n                ri.internal_ports[0]['id'])\n\n            expected_plug_call = [mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='ha-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, prefix='qr-',\n                                            namespace=mock.ANY),\n                                  mock.call(mock.ANY, mock.ANY, mock.ANY,\n                                            mock.ANY, bridge='br-ex',\n                                            prefix='qg-',\n                                            namespace=mock.ANY)]\n\n            expected_init_l3_call = [mock.call(mock.ANY,\n                                               ['169.254.0.2/24'],\n                                               namespace=mock.ANY)]\n            expected_send_arp_call = [mock.call(ri, mock.ANY, '169.254.0.2')]\n\n            self.mock_driver.plug.assert_has_calls(expected_plug_call)\n            self.mock_driver.init_l3.assert_has_calls(expected_init_l3_call)\n            self.send_arp.assert_has_calls(expected_send_arp_call)\n\n            expected = ['global_defs {',\n                        '}',\n                        'vrrp_sync_group VG_1 {',\n                        '\\tgroup {',\n                        '\\t\\tVR_1',\n                        '\\t}',\n                        '}',\n                        'vrrp_instance VR_1 {',\n                        '\\tstate BACKUP',\n                        '\\tinterface ' + ha_iface,\n                        '\\tvirtual_router_id 1',\n                        '\\tpriority 1',\n                        '\\tnopreempt',\n                        '\\tadvert_int 2',\n                        '\\ttrack_interface {',\n                        '\\t\\t' + ha_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress {',\n                        '\\t\\t19.4.4.4/24 dev ' + ex_iface,\n                        '\\t}',\n                        '\\tvirtual_ipaddress_excluded {',\n                        '\\t\\t35.4.0.4/24 dev ' + int_iface,\n                        '\\t}',\n                        '\\tvirtual_routes {',\n                        '\\t\\t0.0.0.0/0 via 19.4.4.1 dev ' + ex_iface,\n                        '\\t}',\n                        '}']\n\n            replace.assert_called_once_with('/ha_confs/' + ri.router_id +\n                                            '/keepalived.conf',\n                                            '\\n'.join(expected))\n\n            expected = ['keepalived', '-P', '-f',\n                        '/ha_confs/' + ri.router_id +\n                        '/keepalived.conf', '-p',\n                        '/ha_confs/' + ri.router_id +\n                        '.pid', '-r',\n                        '/ha_confs/' + ri.router_id +\n                        '-vrrp.pid']\n\n            self.mock_ip.netns.execute.assert_called_once_with(expected)\n            self.external_process_p.start()\n            self.is_ha_p.start()\n\n    def test_process_ha_router_removed(self):\n        self.is_ha_p.stop()\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_ha=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router,\n                                 ha_confs_path=self.conf.ha_confs_path)\n        with contextlib.nested(mock.patch.object(agent,\n                                                 '_spawn_metadata_proxy'),\n                               mock.patch('neutron.agent.linux.'\n                                          'utils.replace_file')) as (spawn,\n                                                                     replace):\n            agent.process_ha_router_added(ri)\n            agent.process_router(ri)\n\n            port_id = _uuid()\n\n            ri.router = router\n\n            self.device_exists.return_value = True\n\n            router[l3_constants.HA_INTERFACE_KEY] = self._get_ha_interfaces(\n                port_id=port_id)\n\n            agent.process_router(ri)\n\n            self.mock_driver.unplug.reset_mock()\n\n            del router[l3_constants.HA_INTERFACE_KEY]\n\n            ha_iface = agent.get_ha_device_name(ri.ha_port['id'])\n            agent.process_router(ri)\n            agent.process_ha_router_removed(ri)\n\n            expected = [mock.call(ha_iface, prefix='ha-',\n                                  namespace=ri.ns_name())]\n            self.mock_driver.unplug.assert_has_calls(expected)\n\n        self.is_ha_p.start()\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_add(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = []\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n        device.addr.add.assert_called_once_with(4, '15.1.2.3/32', '15.1.2.3')\n\n    def test_process_router_floating_ip_nat_rules_add(self):\n        fip = {\n            'id': _uuid(), 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.1'\n        }\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n        rules = agent.floating_forward_rules('15.1.2.3', '192.168.0.1')\n        for chain, rule in rules:\n            nat.add_rule.assert_any_call(chain, rule, tag='floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remove(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({}, fip_statuses)\n        device.addr.delete.assert_called_once_with(4, '15.1.2.3/32')\n\n    def test_process_router_floating_ip_nat_rules_remove(self):\n        ri = mock.MagicMock()\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        agent.process_router_floating_ip_nat_rules(ri)\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat = ri.iptables_manager.ipv4['nat`']\n        nat.clear_rules_by_tag.assert_called_once_with('floating_ip')\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_addresses_remap(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.list.return_value = [{'cidr': '15.1.2.3/32'}]\n        ri = mock.MagicMock()\n\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE},\n                         fip_statuses)\n\n        self.assertFalse(device.addr.add.called)\n        self.assertFalse(device.addr.delete.called)\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_with_disabled_floating_ip(self, IPDevice):\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n\n        ri = mock.MagicMock()\n        ri.floating_ips = [fip]\n        ri.router.get.return_value = []\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertIsNone(fip_statuses.get(fip_id))\n\n    @mock.patch('neutron.agent.linux.ip_lib.IPDevice')\n    def test_process_router_floating_ip_with_device_add_error(self, IPDevice):\n        IPDevice.return_value = device = mock.Mock()\n        device.addr.add.side_effect = processutils.ProcessExecutionError\n        device.addr.list.return_value = []\n        fip_id = _uuid()\n        fip = {\n            'id': fip_id, 'port_id': _uuid(),\n            'floating_ip_address': '15.1.2.3',\n            'fixed_ip_address': '192.168.0.2'\n        }\n        ri = mock.MagicMock()\n        ri.router.get.return_value = [fip]\n        ri.is_ha.return_value = False\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        fip_statuses = agent.process_router_floating_ip_addresses(\n            ri, {'id': _uuid()})\n\n        self.assertEqual({fip_id: l3_constants.FLOATINGIP_STATUS_ERROR},\n                         fip_statuses)\n\n    def test_process_router_snat_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=True)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess without NAT\n        router['enable_snat'] = False\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_snat_enabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(enable_snat=False)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process without NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Reprocess with NAT\n        router['enable_snat'] = True\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 2)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_added(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        router[l3_constants.INTERFACE_KEY].append(\n            {'id': _uuid(),\n             'network_id': _uuid(),\n             'admin_state_up': True,\n             'fixed_ips': [{'ip_address': '35.4.1.4',\n                            'subnet_id': _uuid()}],\n             'mac_address': 'ca:fe:de:ad:be:ef',\n             'subnet': {'cidr': '35.4.1.0/24',\n                        'gateway_ip': '35.4.1.1'}})\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in ri.iptables_manager.ipv4['nat'].rules\n                           if r not in orig_nat_rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_interface_removed(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data(num_internal_ports=2)\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # Process with NAT\n        agent.process_router(ri)\n        orig_nat_rules = ri.iptables_manager.ipv4['nat'].rules[:]\n        # Add an interface and reprocess\n        del router[l3_constants.INTERFACE_KEY][1]\n        # Reassign the router object to RouterInfo\n        ri.router = router\n        agent.process_router(ri)\n        # For some reason set logic does not work well with\n        # IpTablesRule instances\n        nat_rules_delta = [r for r in orig_nat_rules\n                           if r not in ri.iptables_manager.ipv4['nat'].rules]\n        self.assertEqual(len(nat_rules_delta), 1)\n        self._verify_snat_rules(nat_rules_delta, router, negate=True)\n        self.send_arp.assert_called_once()\n\n    def test_process_router_internal_network_added_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_added') as internal_network_added:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_network_added.side_effect = RuntimeError\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_network_added.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to add the port to ri.internal_ports\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_internal_network_removed_unexpected_error(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router = self._prepare_router_data()\n        ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                 self.conf.use_namespaces, router=router)\n        agent.external_gateway_added = mock.Mock()\n        # add an internal port\n        agent.process_router(ri)\n\n        with mock.patch.object(\n                l3_agent.L3NATAgent,\n                'internal_network_removed') as internal_net_removed:\n            # raise RuntimeError to simulate that an unexpected exception\n            # occurrs\n            internal_net_removed.side_effect = RuntimeError\n            ri.internal_ports[0]['admin_state_up'] = False\n            # The above port is set to down state, remove it.\n            self.assertRaises(RuntimeError, agent.process_router, ri)\n            self.assertIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n            # The unexpected exception has been fixed manually\n            internal_net_removed.side_effect = None\n\n            # _sync_routers_task finds out that _rpc_loop failed to process the\n            # router last time, it will retry in the next run.\n            agent.process_router(ri)\n            # We were able to remove the port from ri.internal_ports\n            self.assertNotIn(\n                router[l3_constants.INTERFACE_KEY][0], ri.internal_ports)\n\n    def test_process_router_floatingip_disabled(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        with mock.patch.object(\n            agent.plugin_rpc,\n            'update_floatingip_statuses') as mock_update_fip_status:\n            fip_id = _uuid()\n            router = self._prepare_router_data(num_internal_ports=1)\n            router[l3_constants.FLOATINGIP_KEY] = [\n                {'id': fip_id,\n                 'floating_ip_address': '8.8.8.8',\n                 'fixed_ip_address': '7.7.7.7',\n                 'port_id': router[l3_constants.INTERFACE_KEY][0]['id']}]\n\n            ri = l3_agent.RouterInfo(router['id'], self.conf.root_helper,\n                                     self.conf.use_namespaces, router=router)\n            agent.external_gateway_added = mock.Mock()\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_ACTIVE})\n            mock_update_fip_status.reset_mock()\n            # Process the router again, this time without floating IPs\n            router[l3_constants.FLOATINGIP_KEY] = []\n            ri.router = router\n            agent.process_router(ri)\n            # Assess the call for putting the floating IP up was performed\n            mock_update_fip_status.assert_called_once_with(\n                mock.ANY, ri.router_id,\n                {fip_id: l3_constants.FLOATINGIP_STATUS_DOWN})\n\n    def test_handle_router_snat_rules_add_back_jump(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = mock.MagicMock()\n        port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n\n        agent._handle_router_snat_rules(ri, port, [], \"iface\", \"add_rules\")\n\n        nat = ri.iptables_manager.ipv4['nat']\n        nat.empty_chain.assert_any_call('snat')\n        nat.add_rule.assert_any_call('snat', '-j $float-snat')\n        for call in nat.mock_calls:\n            name, args, kwargs = call\n            if name == 'add_rule':\n                self.assertEqual(args, ('snat', '-j $float-snat'))\n                self.assertEqual(kwargs, {})\n                break\n\n    def test_handle_router_snat_rules_add_rules(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ri = l3_agent.RouterInfo(_uuid(), self.conf.root_helper,\n                                 self.conf.use_namespaces, None)\n        ex_gw_port = {'fixed_ips': [{'ip_address': '192.168.1.4'}]}\n        internal_cidrs = ['10.0.0.0/24']\n        agent._handle_router_snat_rules(ri, ex_gw_port, internal_cidrs,\n                                        \"iface\", \"add_rules\")\n\n        nat_rules = map(str, ri.iptables_manager.ipv4['nat'].rules)\n        wrap_name = ri.iptables_manager.wrap_name\n\n        jump_float_rule = \"-A %s-snat -j %s-float-snat\" % (wrap_name,\n                                                           wrap_name)\n        internal_net_rule = (\"-A %s-snat -s %s -j SNAT --to-source %s\") % (\n            wrap_name, internal_cidrs[0],\n            ex_gw_port['fixed_ips'][0]['ip_address'])\n\n        self.assertIn(jump_float_rule, nat_rules)\n\n        self.assertIn(internal_net_rule, nat_rules)\n        self.assertThat(nat_rules.index(jump_float_rule),\n                        matchers.LessThan(nat_rules.index(internal_net_rule)))\n\n    def test_routers_with_admin_state_down(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = None\n\n        routers = [\n            {'id': _uuid(),\n             'admin_state_up': False,\n             'external_gateway_info': {}}]\n        agent._process_routers(routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_router_deleted(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_deleted(None, FAKE_ID)\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_routers_updated(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.routers_updated(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_removed_from_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_removed_from_agent(None, {'router_id': FAKE_ID})\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.removed_routers)\n\n    def test_added_to_agent(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent.router_added_to_agent(None, [FAKE_ID])\n        # verify that will set fullsync\n        self.assertIn(FAKE_ID, agent.updated_routers)\n\n    def test_process_router_delete(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        ex_gw_port = {'id': _uuid(),\n                      'network_id': _uuid(),\n                      'fixed_ips': [{'ip_address': '19.4.4.4',\n                                     'subnet_id': _uuid()}],\n                      'subnet': {'cidr': '19.4.4.0/24',\n                                 'gateway_ip': '19.4.4.1'}}\n        router = {\n            'id': _uuid(),\n            'enable_snat': True,\n            'routes': [],\n            'gw_port': ex_gw_port}\n        agent._router_added(router['id'], router)\n        agent.router_deleted(None, router['id'])\n        agent._process_router_delete()\n        self.assertFalse(list(agent.removed_routers))\n\n    def test_destroy_router_namespace_skips_ns_removal(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.assertEqual(self.mock_ip.netns.delete.call_count, 0)\n\n    def test_destroy_router_namespace_removes_ns(self):\n        self.conf.set_override('router_delete_namespaces', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        agent._destroy_router_namespace(\"fakens\")\n        self.mock_ip.netns.delete.assert_called_once_with(\"fakens\")\n\n    def _configure_metadata_proxy(self, enableflag=True):\n        if not enableflag:\n            self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        router_id = _uuid()\n        router = {'id': _uuid(),\n                  'external_gateway_info': {},\n                  'routes': []}\n        with mock.patch.object(\n            agent, '_destroy_metadata_proxy') as destroy_proxy:\n            with mock.patch.object(\n                agent, '_spawn_metadata_proxy') as spawn_proxy:\n                agent._router_added(router_id, router)\n                if enableflag:\n                    spawn_proxy.assert_called_with(mock.ANY)\n                else:\n                    self.assertFalse(spawn_proxy.call_count)\n                agent._router_removed(router_id)\n                if enableflag:\n                    destroy_proxy.assert_called_with(mock.ANY, mock.ANY)\n                else:\n                    self.assertFalse(destroy_proxy.call_count)\n\n    def test_enable_metadata_proxy(self):\n        self._configure_metadata_proxy()\n\n    def test_disable_metadata_proxy_spawn(self):\n        self._configure_metadata_proxy(enableflag=False)\n\n    def test_metadata_nat_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_nat_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('PREROUTING', '-s 0.0.0.0/0 -d 169.254.169.254/32 '\n                 '-p tcp -m tcp --dport 80 -j REDIRECT --to-port 8775')\n        self.assertEqual([rules], agent.metadata_nat_rules())\n\n    def test_router_id_specified_in_conf(self):\n        self.conf.set_override('use_namespaces', False)\n        self.conf.set_override('router_id', '')\n        self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                          HOSTNAME, self.conf)\n\n        self.conf.set_override('router_id', '1234')\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual(['1234'], agent._router_ids())\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_process_routers_with_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertFalse(self.plugin_api.get_external_network_id.called)\n\n    def test_process_routers_with_stale_cached_ext_net(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n        agent.target_ex_net_id = 'bbb'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.plugin_api.get_external_network_id.assert_called_with(\n            agent.context)\n\n    def test_process_routers_with_no_ext_net_in_conf_and_two_net_plugin(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}}]\n\n        agent.router_info = {}\n        self.plugin_api.get_external_network_id.side_effect = (\n            n_exc.TooManyExternalNetworks())\n        self.assertRaises(n_exc.TooManyExternalNetworks,\n                          agent._process_routers,\n                          routers)\n        self.assertNotIn(routers[0]['id'], agent.router_info)\n\n    def test_process_routers_with_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('gateway_external_network_id', 'aaa')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertNotIn(routers[1]['id'], agent.router_info)\n\n    def test_process_routers_with_no_bridge_no_ext_net_in_conf(self):\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.plugin_api.get_external_network_id.return_value = 'aaa'\n\n        routers = [\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'aaa'}},\n            {'id': _uuid(),\n             'routes': [],\n             'admin_state_up': True,\n             'external_gateway_info': {'network_id': 'bbb'}}]\n\n        agent.router_info = {}\n        self.conf.set_override('external_network_bridge', '')\n        agent._process_routers(routers)\n        self.assertIn(routers[0]['id'], agent.router_info)\n        self.assertIn(routers[1]['id'], agent.router_info)\n\n    def test_nonexistent_interface_driver(self):\n        self.conf.set_override('interface_driver', None)\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = 'An interface driver must be specified'\n            log.error.assert_called_once_with(msg)\n\n        self.conf.set_override('interface_driver', 'wrong_driver')\n        with mock.patch.object(l3_agent, 'LOG') as log:\n            self.assertRaises(SystemExit, l3_agent.L3NATAgent,\n                              HOSTNAME, self.conf)\n            msg = \"Error importing interface driver 'wrong_driver'\"\n            log.error.assert_called_once_with(msg)\n\n    def test_metadata_filter_rules(self):\n        self.conf.set_override('enable_metadata_proxy', False)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        self.assertEqual([], agent.metadata_filter_rules())\n\n        self.conf.set_override('metadata_port', '8775')\n        self.conf.set_override('enable_metadata_proxy', True)\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n        rules = ('INPUT', '-s 0.0.0.0/0 -d 127.0.0.1 '\n                 '-p tcp -m tcp --dport 8775 -j ACCEPT')\n        self.assertEqual([rules], agent.metadata_filter_rules())\n\n    def _cleanup_namespace_test(self,\n                                stale_namespace_list,\n                                router_list,\n                                other_namespaces):\n        self.conf.set_override('router_delete_namespaces', True)\n\n        good_namespace_list = [l3_agent.NS_PREFIX + r['id']\n                               for r in router_list]\n        self.mock_ip.get_namespaces.return_value = (stale_namespace_list +\n                                                    good_namespace_list +\n                                                    other_namespaces)\n\n        agent = l3_agent.L3NATAgent(HOSTNAME, self.conf)\n\n        self.assertTrue(agent._delete_stale_namespaces)\n\n        pm = self.external_process.return_value\n        pm.reset_mock()\n\n        agent._destroy_router_namespace = mock.MagicMock()\n        agent._cleanup_namespaces(router_list)\n\n        self.assertEqual(pm.disable.call_count, len(stale_namespace_list))\n        self.assertEqual(agent._destroy_router_namespace.call_count,\n                         len(stale_namespace_list))\n        expected_args = [mock.call(ns) for ns in stale_namespace_list]\n        agent._destroy_router_namespace.assert_has_calls(expected_args,\n                                                         any_order=True)\n        self.assertFalse(agent._delete_stale_namespaces)\n\n    def test_cleanup_namespace(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'foo',\n                            l3_agent.NS_PREFIX + 'bar']\n        other_namespaces = ['unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     [],\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_registered_router_ids(self):\n        self.conf.set_override('router_id', None)\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee']\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n    def test_cleanup_namespace_with_conf_router_id(self):\n        self.conf.set_override('router_id', 'bbbbb')\n        stale_namespaces = [l3_agent.NS_PREFIX + 'cccc',\n                            l3_agent.NS_PREFIX + 'eeeee',\n                            l3_agent.NS_PREFIX + self.conf.router_id]\n        router_list = [{'id': 'foo'}, {'id': 'aaaa'}]\n        other_namespaces = ['qdhcp-aabbcc', 'unknown']\n\n        self._cleanup_namespace_test(stale_namespaces,\n                                     router_list,\n                                     other_namespaces)\n\n\nclass TestL3AgentEventHandler(base.BaseTestCase):\n\n    def setUp(self):\n        super(TestL3AgentEventHandler, self).setUp()\n        cfg.CONF.register_opts(l3_agent.L3NATAgent.OPTS)\n        agent_config.register_interface_driver_opts_helper(cfg.CONF)\n        agent_config.register_use_namespaces_opts_helper(cfg.CONF)\n        cfg.CONF.set_override(\n            'interface_driver', 'neutron.agent.linux.interface.NullDriver'\n        )\n        cfg.CONF.set_override('use_namespaces', True)\n        agent_config.register_root_helper(cfg.CONF)\n\n        device_exists_p = mock.patch(\n            'neutron.agent.linux.ip_lib.device_exists')\n        device_exists_p.start()\n\n        utils_exec_p = mock.patch(\n            'neutron.agent.linux.utils.execute')\n        utils_exec_p.start()\n\n        drv_cls_p = mock.patch('neutron.agent.linux.interface.NullDriver')\n        driver_cls = drv_cls_p.start()\n        mock_driver = mock.MagicMock()\n        mock_driver.DEV_NAME_LEN = (\n            interface.LinuxInterfaceDriver.DEV_NAME_LEN)\n        driver_cls.return_value = mock_driver\n\n        self.is_ha_p = mock.patch(\n            'neutron.agent.l3_agent.RouterInfo.is_ha')\n        self.is_ha = self.is_ha_p.start()\n        self.is_ha.return_value = False\n\n        self.makedirs_p = mock.patch('os.makedirs')\n        self.makedirs = self.makedirs_p.start()\n\n        l3_plugin_p = mock.patch(\n            'neutron.agent.l3_agent.L3PluginApi')\n        l3_plugin_cls = l3_plugin_p.start()\n        l3_plugin_cls.return_value = mock.Mock()\n\n        self.external_process_p = mock.patch(\n            'neutron.agent.linux.external_process.ProcessManager'\n        )\n        self.external_process_p.start()\n        looping_call_p = mock.patch(\n            'neutron.openstack.common.loopingcall.FixedIntervalLoopingCall')\n        looping_call_p.start()\n        self.agent = l3_agent.L3NATAgent(HOSTNAME)\n        self.addCleanup(mock.patch.stopall)\n\n    def test_spawn_metadata_proxy(self):\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        ri = l3_agent.RouterInfo(router_id, None, True, None)\n        try:\n            with mock.patch(ip_class_path) as ip_mock:\n                self.agent._spawn_metadata_proxy(ri)\n                ip_mock.assert_has_calls([\n                    mock.call('sudo', ri.ns_name()),\n                    mock.call().netns.execute([\n                        'neutron-ns-metadata-proxy',\n                        mock.ANY,\n                        mock.ANY,\n                        '--router_id=%s' % router_id,\n                        mock.ANY,\n                        '--metadata_port=%s' % metadata_port,\n                        '--debug',\n                        '--log-file=neutron-ns-metadata-proxy-%s.log' %\n                        router_id\n                    ])\n                ])\n        finally:\n            self.external_process_p.start()\n\n    def test_spawn_metadata_proxy_with_ha(self):\n        self.is_ha_p.stop()\n\n        router_id = _uuid()\n        metadata_port = 8080\n        ip_class_path = 'neutron.agent.linux.ip_lib.IPWrapper'\n\n        cfg.CONF.set_override('ha_confs_path', '/tmp')\n        cfg.CONF.set_override('metadata_port', metadata_port)\n        cfg.CONF.set_override('log_file', 'test.log')\n        cfg.CONF.set_override('debug', True)\n\n        self.external_process_p.stop()\n        router = {'id': router_id, 'ha_vr_id': 1}\n        ri = l3_agent.RouterInfo(router_id, None, True, router,\n                                 cfg.CONF.ha_confs_path)\n        try:\n            with contextlib.nested(mock.patch('os.stat'),\n                                   mock.patch('os.chmod'),\n                                   mock.patch('neutron.agent.linux.'\n                                              'utils.replace_file'),\n                                   mock.patch.object(ri, 'keepalived_manager'),\n                                   mock.patch(ip_class_path)) as (stat,\n                                                                  chmod,\n                                                                  replace,\n                                                                  keep_man,\n                                                                  ip_class):\n                self.agent._init_keepalived_notifiers(ri)\n                self.agent._spawn_metadata_proxy(ri)\n                m, b, f = ri.keepalived_notifiers.get_notifiers_path()\n\n                notify_master = ('/tmp/' + router_id + '/notify_master.sh')\n                notify_fault = ('/tmp/' + router_id + '/notify_fault.sh')\n                notify_backup = ('/tmp/' + router_id + '/notify_backup.sh')\n                self.assertEqual(notify_master, m)\n                self.assertEqual(notify_backup, b)\n                self.assertEqual(notify_fault, f)\n                replace.assert_has_call_with(notify_master, mock.ANY)\n                replace.assert_has_call_with(notify_fault, mock.ANY)\n                replace.assert_has_call_with(notify_backup, mock.ANY)\n        finally:\n            self.external_process_p.start()\n            self.is_ha_p.start()","comments":[],"name":"neutron/tests/unit/test_l3_agent.py"}}}],"comments":[{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-02-03T12:12:50.000Z","id":"AAAAUH/919s=","message":"Patch Set 1: Works for me\n\n https://arista.box.com/s/3x06jf5ofa9928903500 \t PASSED\t tempest.api.network.test_networks\n\n For any questions please email at arista-openstack-test@aristanetworks.com","revisionNumber":1},{"author":{"accountId":9925,"email":"lucas@midokura.com","name":"Midokura CI Bot","username":"midokura"},"date":"2014-02-03T12:14:14.000Z","id":"AAAAUH/918o=","message":"Patch Set 1: Works for me\n\nhttp://119.15.112.118/results/test_networks2014-02-03-12-12.html","revisionNumber":1},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-02-03T12:18:33.000Z","id":"AAAAUH/917I=","message":"Patch Set 1:\n\nDoesn't seem to work.\n\n- BSN_PLUGIN http://openstack-ci-gw.bigswitch.com/logs/2014-02-03_12-12-05/BSN_PLUGIN/ : FAILURE\n- BSN_ML2 http://openstack-ci-gw.bigswitch.com/logs/2014-02-03_12-12-05/BSN_ML2/ : (skipped)\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/2014-02-03_12-12-05\n\nContact: openstack-ci@bigswitch.com\n","revisionNumber":1},{"author":{"accountId":9681,"email":"ryu-openstack-review@lists.sourceforge.net","name":"Neutron Ryu","username":"neutronryu"},"date":"2014-02-03T12:31:41.000Z","id":"AAAAUH/913k=","message":"Patch Set 1: Works for me\n\nBuild Successful \n\nhttp://180.37.183.32/jenkins/job/neutron/626/artifact/logs/ : SUCCESS","revisionNumber":1},{"author":{"accountId":10117,"email":"plumgrid-ci-os@plumgrid.com","name":"PLUMgrid CI","username":"plumgrid-ci"},"date":"2014-02-03T12:38:12.000Z","id":"AAAAUH/912Y=","message":"Patch Set 1: Works for me\n\nBuild Successful \n\nhttp://10.1.2.41:8080/job/plumgrid-ci/282/ : SUCCESS","revisionNumber":1},{"author":{"accountId":10153,"email":"oc-neutron-test@oneconvergence.com","name":"One Convergence CI","username":"oneconvergence"},"date":"2014-02-03T12:47:52.000Z","id":"AAAAUH/91z4=","message":"Patch Set 1:\n\nBuild Successful \n\nhttp://192.168.6.100:8080/job/openstack/404/ : logs: ${ENV,var=\"LINK\"}","revisionNumber":1},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-02-03T12:56:20.000Z","id":"AAAAUH/91vo=","message":"Patch Set 1: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/1/check/gate-neutron-pep8/667783b : FAILURE in 2m 59s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/1/check/gate-neutron-docs/e037ec2/doc/build/html/ : SUCCESS in 1m 59s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/1/check/gate-neutron-python26/17d3836 : FAILURE in 44m 12s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/1/check/gate-neutron-python27/093871d : FAILURE in 26m 19s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/1/check/check-tempest-dsvm-neutron/71e57f8 : FAILURE in 28m 04s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/1/check/check-tempest-dsvm-neutron-pg/bf9c0b9 : FAILURE in 7m 56s\n- check-tempest-dsvm-neutron-isolated http://logs.openstack.org/00/70700/1/check/check-tempest-dsvm-neutron-isolated/caf9dfc : FAILURE in 28m 08s\n- check-tempest-dsvm-neutron-pg-isolated http://logs.openstack.org/00/70700/1/check/check-tempest-dsvm-neutron-pg-isolated/1e6c66d : FAILURE in 10m 24s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/1/check/gate-tempest-dsvm-neutron-large-ops/71c54d0 : SUCCESS in 20m 49s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/1/check/check-grenade-dsvm-neutron/4bae438 : FAILURE in 20m 30s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/1/check/check-devstack-dsvm-neutron/e0e7fff : FAILURE in 16m 46s (non-voting)\n","revisionNumber":1},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-02-03T12:57:25.000Z","id":"AAAAUH/91vQ=","message":"Patch Set 1: Works for me\n\nBuild Successful \n\nhttp://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/849 : SUCCESS","revisionNumber":1},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-02-03T16:53:49.000Z","id":"AAAAUH/90Yg=","message":"Uploaded patch set 2.","revisionNumber":2},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-02-03T16:54:42.000Z","id":"AAAAUH/90Xs=","message":"Patch Set 2: Works for me\n\n https://arista.box.com/s/u3v91vke1qoal9i2kaf5 \t PASSED\t tempest.api.network.test_networks\n\n For any questions please email at arista-openstack-test@aristanetworks.com","revisionNumber":2},{"author":{"accountId":9925,"email":"lucas@midokura.com","name":"Midokura CI Bot","username":"midokura"},"date":"2014-02-03T16:55:49.000Z","id":"AAAAUH/90XE=","message":"Patch Set 2: Works for me\n\nhttp://119.15.112.118/results/test_networks2014-02-03-16-53.html","revisionNumber":2},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-02-03T17:00:10.000Z","id":"AAAAUH/90Us=","message":"Patch Set 2:\n\nDoesn't seem to work.\n\n- BSN_PLUGIN http://openstack-ci-gw.bigswitch.com/logs/2014-02-03_16-53-55/BSN_PLUGIN/ : FAILURE\n- BSN_ML2 http://openstack-ci-gw.bigswitch.com/logs/2014-02-03_16-53-55/BSN_ML2/ : (skipped)\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/2014-02-03_16-53-55\n\nContact: openstack-ci@bigswitch.com\n","revisionNumber":2},{"author":{"accountId":10117,"email":"plumgrid-ci-os@plumgrid.com","name":"PLUMgrid CI","username":"plumgrid-ci"},"date":"2014-02-03T17:11:08.000Z","id":"AAAAUH/90QE=","message":"Patch Set 2: Works for me\n\nBuild Successful \n\nhttp://10.1.2.41:8080/job/plumgrid-ci/295/ : SUCCESS","revisionNumber":2},{"author":{"accountId":9681,"email":"ryu-openstack-review@lists.sourceforge.net","name":"Neutron Ryu","username":"neutronryu"},"date":"2014-02-03T17:17:19.000Z","id":"AAAAUH/90O4=","message":"Patch Set 2: Works for me\n\nBuild Successful \n\nhttp://180.37.183.32/jenkins/job/neutron/637/artifact/logs/ : SUCCESS","revisionNumber":2},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-02-03T17:19:29.000Z","id":"AAAAUH/90OI=","message":"Patch Set 2: Works for me\n\nBuild Successful \n\nhttp://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/862 : SUCCESS","revisionNumber":2},{"author":{"accountId":10153,"email":"oc-neutron-test@oneconvergence.com","name":"One Convergence CI","username":"oneconvergence"},"date":"2014-02-03T17:30:39.000Z","id":"AAAAUH/90ME=","message":"Patch Set 2:\n\nBuild Successful \n\nhttp://192.168.6.100:8080/job/openstack/423/ : logs:\u003c$BUILD_LOGS\u003e","revisionNumber":2},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-02-03T17:36:27.000Z","id":"AAAAUH/90Kc=","message":"Patch Set 2: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/2/check/gate-neutron-pep8/18d30e4 : SUCCESS in 2m 15s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/2/check/gate-neutron-docs/e84576b/doc/build/html/ : SUCCESS in 1m 55s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/2/check/gate-neutron-python26/9366159 : FAILURE in 42m 30s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/2/check/gate-neutron-python27/b5744aa : FAILURE in 27m 42s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/2/check/check-tempest-dsvm-neutron/0931425 : FAILURE in 27m 02s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/2/check/check-tempest-dsvm-neutron-pg/6d0c26f : FAILURE in 9m 39s\n- check-tempest-dsvm-neutron-isolated http://logs.openstack.org/00/70700/2/check/check-tempest-dsvm-neutron-isolated/5756381 : FAILURE in 29m 17s\n- check-tempest-dsvm-neutron-pg-isolated http://logs.openstack.org/00/70700/2/check/check-tempest-dsvm-neutron-pg-isolated/7f413f4 : FAILURE in 8m 07s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/2/check/gate-tempest-dsvm-neutron-large-ops/b810024 : SUCCESS in 14m 20s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/2/check/check-grenade-dsvm-neutron/44d70e1 : FAILURE in 17m 51s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/2/check/check-devstack-dsvm-neutron/7865207 : FAILURE in 17m 47s (non-voting)\n","revisionNumber":2},{"author":{"accountId":9,"email":"","name":"LaunchpadSync","username":"launchpadsync"},"date":"2014-02-11T06:03:13.000Z","id":"AAAAUX//vB0=","message":"Patch Set 2:\n\ncode review expired after 1 week of no activity after a negative review, it can be restored using the `Restore Change` button under the Patch Set on the web interface","revisionNumber":2},{"author":{"accountId":9,"email":"","name":"LaunchpadSync","username":"launchpadsync"},"date":"2014-02-11T06:03:13.000Z","id":"AAAAUX//vBw=","message":"Patch Set 2: Abandoned\n\ncode review expired after 1 week of no activity after a negative review, it can be restored using the `Restore Change` button under the Patch Set on the web interface","revisionNumber":2},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-02-11T10:31:27.000Z","id":"AAAAUX//tQM=","message":"Patch Set 2: Restored","revisionNumber":2},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-02-11T10:31:28.000Z","id":"AAAAUX//tQI=","message":"Patch Set 2: No score\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":2},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-02-11T10:31:34.000Z","id":"AAAAUX//tQE=","message":"Patch Set 2: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":2},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-02-11T10:31:35.000Z","id":"AAAAUX//tQA=","message":"Patch Set 2:\n\nBuild succeeded.\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":2},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-02-11T10:31:48.000Z","id":"AAAAUX//tP0=","message":"Patch Set 2: No score\n\nBuild failed.\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":2},{"author":{"accountId":9,"email":"","name":"LaunchpadSync","username":"launchpadsync"},"date":"2014-02-19T06:03:37.000Z","id":"AAAAUX/+xi8=","message":"Patch Set 2: Abandoned\n\ncode review expired after 1 week of no activity after a negative review, it can be restored using the `Restore Change` button under the Patch Set on the web interface","revisionNumber":2},{"author":{"accountId":9,"email":"","name":"LaunchpadSync","username":"launchpadsync"},"date":"2014-02-19T06:03:37.000Z","id":"AAAAUX/+xjA=","message":"Patch Set 2:\n\ncode review expired after 1 week of no activity after a negative review, it can be restored using the `Restore Change` button under the Patch Set on the web interface","revisionNumber":2},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-03T12:12:47.000Z","id":"AAAAVn//7AE=","message":"Patch Set 2: Restored","revisionNumber":2},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-03T12:12:50.000Z","id":"AAAAVn//6/8=","message":"Patch Set 2: No score\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":2},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-03T12:12:53.000Z","id":"AAAAVn//6/4=","message":"Patch Set 2: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":2},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-03-03T12:13:22.000Z","id":"AAAAVn//6/w=","message":"Patch Set 2:\n\nBuild failed. Leave a comment with 'recheck-nec' to rerun a check. ('recheck' will be ignored.)\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":2},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-04T15:16:37.000Z","id":"AAAAVn//tQk=","message":"Uploaded patch set 3.","revisionNumber":3},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-04T15:16:39.000Z","id":"AAAAVn//tQY=","message":"Patch Set 3:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":3},{"author":{"accountId":10294,"email":"openstack_gerrit@brocade.com","name":"Brocade CI","username":"bci"},"date":"2014-03-04T15:23:24.000Z","id":"AAAAVn//tMQ=","message":"Patch Set 3:\n\nBrocade ML2: SUCCESS http://50.56.236.34/tempest2/70700/5e89352a7096035f839db8d78156b37d10ead5f2/ml2","revisionNumber":3},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-04T15:24:03.000Z","id":"AAAAVn//tME=","message":"Patch Set 3:\n\n Arista third party testing FAILED [ https://arista.box.com/s/yqs97346uk213du7ns0a ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":3},{"author":{"accountId":10192,"email":"cisco-openstack-neutron-ci@cisco.com","name":"Cisco Neutron CI","username":"cisco_neutron_ci"},"date":"2014-03-04T15:31:05.000Z","id":"AAAAVn//tG8=","message":"Patch Set 3:\n\nBuild Successful \n\nhttp://128.107.233.28:8080/job/neutron/1294/ : SUCCESS","revisionNumber":3},{"author":{"accountId":10184,"email":"nuage-ci@nuagenetworks.net","name":"Nuage CI","username":"nuage-ci"},"date":"2014-03-04T15:32:39.000Z","id":"AAAAVn//tFw=","message":"Patch Set 3:\n\nhttp://208.113.169.228/nuage-ci/00_70700_3 - SUCCESS - non voting","revisionNumber":3},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-03-04T15:33:00.000Z","id":"AAAAVn//tFk=","message":"Patch Set 3: Works for me\n\nBuild successful.\n\n- Neutron_Gate http://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/3025 : SUCCESS in 15m 59s\n","revisionNumber":3},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-03-04T15:43:50.000Z","id":"AAAAVn//s/4=","message":"Patch Set 3:\n\nBuild succeeded.\n\n- http://64.119.130.115/70700/3/ : Looks good to me in 27m 00s\n","revisionNumber":3},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-03-04T15:46:30.000Z","id":"AAAAVn//s+Y=","message":"Patch Set 3:\n\nDoesn't seem to work.\n\n- BigSwitch-Plugin http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-3/BSN_PLUGIN/ : FAILURE\n- BigSwitch-ML2-Driver http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-3/BSN_ML2/ : FAILURE\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-3\n\nContact: openstack-ci@bigswitch.com\n\nLeave a comment with 'recheck-bigswitch' to cause a recheck. \n","revisionNumber":3},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-04T15:56:16.000Z","id":"AAAAVn//s3M=","message":"Patch Set 3: Works for me\n\n Build Successful LOGS: http://144.76.193.39/logs/70700/3 ","revisionNumber":3},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-04T16:16:06.000Z","id":"AAAAVn//sm4=","message":"Patch Set 3: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/3/check/gate-neutron-pep8/ff01ed7 : SUCCESS in 2m 54s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/3/check/gate-neutron-docs/ed2af68/doc/build/html/ : SUCCESS in 2m 14s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/3/check/gate-neutron-python26/a22fc70 : FAILURE in 19m 26s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/3/check/gate-neutron-python27/085b38f : FAILURE in 25m 28s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/3/check/check-tempest-dsvm-neutron/d198c1b : SUCCESS in 35m 37s\n- check-tempest-dsvm-neutron-full http://logs.openstack.org/00/70700/3/check/check-tempest-dsvm-neutron-full/700a2b4 : SUCCESS in 42m 48s (non-voting)\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/3/check/check-tempest-dsvm-neutron-pg/1c7a5af : SUCCESS in 40m 57s\n- check-tempest-dsvm-neutron-isolated http://logs.openstack.org/00/70700/3/check/check-tempest-dsvm-neutron-isolated/5131857 : SUCCESS in 31m 29s\n- check-tempest-dsvm-neutron-pg-isolated http://logs.openstack.org/00/70700/3/check/check-tempest-dsvm-neutron-pg-isolated/ffe2df4 : SUCCESS in 33m 28s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/3/check/gate-tempest-dsvm-neutron-large-ops/f97d1c9 : SUCCESS in 17m 19s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/3/check/check-grenade-dsvm-neutron/1a4f163 : FAILURE in 26m 23s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/3/check/check-devstack-dsvm-neutron/5b1f662 : FAILURE in 18m 51s (non-voting)\n","revisionNumber":3},{"author":{"accountId":9681,"email":"ryu-openstack-review@lists.sourceforge.net","name":"Neutron Ryu","username":"neutronryu"},"date":"2014-03-05T18:40:49.000Z","id":"AAAAVn//gCs=","message":"Patch Set 3:\n\nBuild Failed \n\nOFAgent http://180.37.183.32/jenkins/job/ofagent-tempest/217/artifact/logs/ : FAILURE\n\nRyu Plugin http://180.37.183.32/jenkins/job/ryuplugin-tempest/185/artifact/logs/ : FAILURE","revisionNumber":3},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-05T18:50:17.000Z","id":"AAAAVn//f9s=","message":"Uploaded patch set 4.","revisionNumber":4},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-05T18:50:21.000Z","id":"AAAAVn//f9k=","message":"Patch Set 4:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":4},{"author":{"accountId":10387,"email":"trinath.somanchi@freescale.com","name":"Freescale CI","username":"freescale-ci"},"date":"2014-03-05T18:50:53.000Z","id":"AAAAVn//f9A=","message":"Patch Set 4:\n\nStarting check jobs.\nhttp://127.0.0.1/zuul/status","revisionNumber":4},{"author":{"accountId":10387,"email":"trinath.somanchi@freescale.com","name":"Freescale CI","username":"freescale-ci"},"date":"2014-03-05T18:52:26.000Z","id":"AAAAVn//f8I=","message":"Patch Set 4:\n\nBuild failed (NON VOTING).\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":4},{"author":{"accountId":10294,"email":"openstack_gerrit@brocade.com","name":"Brocade CI","username":"bci"},"date":"2014-03-05T18:57:10.000Z","id":"AAAAVn//f44=","message":"Patch Set 4:\n\nBrocade ML2: SUCCESS http://50.56.236.34/tempest2/70700/caedee128f7232efc339153f8611405a47aa3fb1/ml2","revisionNumber":4},{"author":{"accountId":10153,"email":"oc-neutron-test@oneconvergence.com","name":"One Convergence CI","username":"oneconvergence"},"date":"2014-03-05T19:01:57.000Z","id":"AAAAVn//f2U=","message":"Patch Set 4:\n\nOne Convergence Third Party Tests Passed. LOGS LINK ---\u003e\n\nhttps://www.dropbox.com/sh/uyaddw4qsf9z6lr/GpoNv6ddg1\n\nFor any question mail us at: oc-neutron-test@oneconvergence.com\n\n","revisionNumber":4},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-05T19:02:20.000Z","id":"AAAAVn//f18=","message":"Patch Set 4: Works for me\n\n Build Successful LOGS: http://144.76.193.39/logs/70700/4 ","revisionNumber":4},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-05T19:05:19.000Z","id":"AAAAVn//f0U=","message":"Patch Set 4: Works for me\n\n Arista third party testing PASSED [ https://arista.box.com/s/sk9x40et0f0tlv5dz561 ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":4},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-03-05T19:13:14.000Z","id":"AAAAVn//fvE=","message":"Patch Set 4: Works for me\n\nTests succeeded.\n\n- BigSwitch-Plugin http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-4/BSN_PLUGIN/ : SUCCESS\n- BigSwitch-ML2-Driver http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-4/BSN_ML2/ : SUCCESS\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-4\n\nContact: openstack-ci@bigswitch.com\n\nLeave a comment with 'recheck-bigswitch' to cause a recheck. \n","revisionNumber":4},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-03-05T19:14:33.000Z","id":"AAAAVn//fuY=","message":"Patch Set 4:\n\nBuild succeeded.\n\n- http://64.119.130.115/70700/4/ : Looks good to me in 24m 05s\n","revisionNumber":4},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-05T19:36:59.000Z","id":"AAAAVn//fX8=","message":"Patch Set 4:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":4},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-05T19:38:31.000Z","id":"AAAAVn//fSw=","message":"Patch Set 4: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":4},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T07:04:15.000Z","id":"AAAAVn//a4Y=","message":"Patch Set 4: I would prefer that you didn't merge this\n\n(4 inline comments)\n\n","revisionNumber":4},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-06T08:59:34.000Z","id":"AAAAVn//aKc=","message":"Patch Set 4: (1 inline comment)\n\n","revisionNumber":4},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-06T11:09:10.000Z","id":"AAAAVn//ZZg=","message":"Patch Set 4: (3 inline comments)\n\n","revisionNumber":4},{"author":{"accountId":8873,"email":"amuller@redhat.com","name":"Assaf Muller","username":"amuller"},"date":"2014-03-06T11:38:58.000Z","id":"AAAAVn//ZNc=","message":"Patch Set 4: (1 inline comment)\n\n","revisionNumber":4},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-06T14:45:37.000Z","id":"AAAAVn//YAs=","message":"Uploaded patch set 5.","revisionNumber":5},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-06T14:45:40.000Z","id":"AAAAVn//YAg=","message":"Patch Set 5:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":5},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-06T14:55:34.000Z","id":"AAAAVn//X7g=","message":"Patch Set 5:\n\n Build Failure LOGS: http://144.76.193.39/logs/70700/5 ","revisionNumber":5},{"author":{"accountId":10117,"email":"plumgrid-ci-os@plumgrid.com","name":"PLUMgrid CI","username":"plumgrid-ci"},"date":"2014-03-06T14:55:46.000Z","id":"AAAAVn//X7U=","message":"Patch Set 5: Works for me\n\nBuild Successful \n\nhttp://10.1.2.41:8080/job/plumgrid-ci/1973/ : SUCCESS","revisionNumber":5},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-03-06T14:55:59.000Z","id":"AAAAVn//X7Q=","message":"Patch Set 5:\n\nBuild failed. Leave a comment with 'recheck-nec' to rerun a check. ('recheck' will be ignored.)\n\n- Neutron_Gate http://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/3169 : FAILURE in 10m 00s\n","revisionNumber":5},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-06T15:30:05.000Z","id":"AAAAVn//Xn8=","message":"Patch Set 5:\n\n Build Failure LOGS: http://144.76.193.39/logs/70700/5 ","revisionNumber":5},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-03-06T16:06:33.000Z","id":"AAAAVn//XRk=","message":"Patch Set 5: Works for me\n\nTests succeeded.\n\n- BigSwitch-Plugin http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-5/BSN_PLUGIN/ : SUCCESS\n- BigSwitch-ML2-Driver http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-5/BSN_ML2/ : SUCCESS\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-5\n\nContact: openstack-ci@bigswitch.com\n\nLeave a comment with 'recheck-bigswitch' to cause a recheck. \n","revisionNumber":5},{"author":{"accountId":10387,"email":"trinath.somanchi@freescale.com","name":"Freescale CI","username":"freescale-ci"},"date":"2014-03-06T16:39:28.000Z","id":"AAAAVn//W+g=","message":"Patch Set 5:\n\nBuild failed (NON VOTING).\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":5},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-06T16:43:46.000Z","id":"AAAAVn//W8I=","message":"Patch Set 5: Works for me\n\n Build Successful LOGS: http://144.76.193.39/logs/70700/5 ","revisionNumber":5},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-06T17:00:21.000Z","id":"AAAAVn//Wxk=","message":"Patch Set 5: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/5/check/gate-neutron-pep8/05702c5 : SUCCESS in 2m 45s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/5/check/gate-neutron-docs/66eab57/doc/build/html/ : SUCCESS in 2m 13s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/5/check/gate-neutron-python26/8e4d267 : SUCCESS in 17m 12s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/5/check/gate-neutron-python27/61ff737 : SUCCESS in 13m 22s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron/1e55be0 : FAILURE in 11m 36s\n- check-tempest-dsvm-neutron-full http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron-full/265d945 : FAILURE in 12m 50s (non-voting)\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron-pg/3370e6a : FAILURE in 11m 36s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron/1e55be0 : FAILURE in 11m 36s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron-pg/3370e6a : FAILURE in 11m 36s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/5/check/gate-tempest-dsvm-neutron-large-ops/b6ff335 : FAILURE in 11m 16s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-grenade-dsvm-neutron/32d9e79 : FAILURE in 24m 16s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-devstack-dsvm-neutron/75685c2 : FAILURE in 9m 05s (non-voting)\n","revisionNumber":5},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-06T17:00:27.000Z","id":"AAAAVn//Wxc=","message":"Patch Set 5: Works for me\n\n Arista third party testing PASSED [ https://arista.box.com/s/o0wvop17yruzd3hiqb7t ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":5},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-06T17:36:29.000Z","id":"AAAAVn//WX4=","message":"Patch Set 5:\n\nrecheck no bug","revisionNumber":5},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-06T17:39:13.000Z","id":"AAAAVn//WU4=","message":"Patch Set 5: No score\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":5},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-06T18:49:43.000Z","id":"AAAAVn//Vn0=","message":"Patch Set 5:\n\n Arista third party testing PASSED [ https://arista.box.com/s/o0wvop17yruzd3hiqb7t ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":5},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-06T18:54:28.000Z","id":"AAAAVn//Vko=","message":"Patch Set 5: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/5/check/gate-neutron-pep8/1237255 : SUCCESS in 2m 19s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/5/check/gate-neutron-docs/7ce943f/doc/build/html/ : SUCCESS in 2m 35s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/5/check/gate-neutron-python26/8f3081c : SUCCESS in 26m 14s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/5/check/gate-neutron-python27/6e4b10e : SUCCESS in 14m 53s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron/3a10f7f : FAILURE in 10m 33s\n- check-tempest-dsvm-neutron-full http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron-full/3ea92bd : FAILURE in 11m 55s (non-voting)\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron-pg/e476b3e : FAILURE in 14m 39s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron/3a10f7f : FAILURE in 10m 33s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/5/check/check-tempest-dsvm-neutron-pg/e476b3e : FAILURE in 14m 39s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/5/check/gate-tempest-dsvm-neutron-large-ops/b545f34 : FAILURE in 10m 30s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-grenade-dsvm-neutron/01914cc : FAILURE in 27m 38s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/5/check/check-devstack-dsvm-neutron/75ccc0c : FAILURE in 10m 11s (non-voting)\n","revisionNumber":5},{"author":{"accountId":10387,"email":"trinath.somanchi@freescale.com","name":"Freescale CI","username":"freescale-ci"},"date":"2014-03-06T19:52:16.000Z","id":"AAAAVn//VAc=","message":"Patch Set 5:\n\nBuild failed (NON VOTING).\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":5},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:28:31.000Z","id":"AAAAVn//ShM=","message":"Patch Set 4: (3 inline comments)\n\n","revisionNumber":4},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:49:42.000Z","id":"AAAAVn//SZ0=","message":"Patch Set 4: (1 inline comment)\n\n","revisionNumber":4},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T01:49:57.000Z","id":"AAAAVn//SZs=","message":"Patch Set 5: (1 inline comment)\n\n","revisionNumber":5},{"author":{"accountId":2711,"email":"veryhua2006@gmail.com","name":"Zhang Hua","username":"zhhuabj"},"date":"2014-03-07T06:24:16.000Z","id":"AAAAVn//RFA=","message":"Patch Set 4: (1 inline comment)\n\n","revisionNumber":4},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-07T13:21:37.000Z","id":"AAAAVn//OpA=","message":"Patch Set 4: (1 inline comment)\n\n","revisionNumber":4},{"author":{"accountId":9681,"email":"ryu-openstack-review@lists.sourceforge.net","name":"Neutron Ryu","username":"neutronryu"},"date":"2014-03-08T00:20:26.000Z","id":"AAAAVn//KJ4=","message":"Patch Set 5:\n\nBuild Failed \n\nOFAgent http://180.37.183.32/jenkins/job/ofagent-tempest/351/artifact/logs/ : FAILURE\n\nRyu Plugin http://180.37.183.32/jenkins/job/ryuplugin-tempest/301/artifact/logs/ : SUCCESS","revisionNumber":5},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-10T15:51:39.000Z","id":"AAAAVn//Buo=","message":"Uploaded patch set 6.","revisionNumber":6},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-10T15:51:42.000Z","id":"AAAAVn//Buk=","message":"Patch Set 6:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":6},{"author":{"accountId":10294,"email":"openstack_gerrit@brocade.com","name":"Brocade CI","username":"bci"},"date":"2014-03-10T15:54:27.000Z","id":"AAAAVn//Bs4=","message":"Patch Set 6:\n\nBrocade ML2: FAIL http://50.56.236.34/tempest2/70700/5fa07dbe323b31e678babe007e043c88425d2e93/ml2","revisionNumber":6},{"author":{"accountId":10184,"email":"nuage-ci@nuagenetworks.net","name":"Nuage CI","username":"nuage-ci"},"date":"2014-03-10T16:00:40.000Z","id":"AAAAVn//Bp8=","message":"Patch Set 6:\n\nhttp://208.113.169.228/nuage-ci/00_70700_6 - SUCCESS - non voting","revisionNumber":6},{"author":{"accountId":10117,"email":"plumgrid-ci-os@plumgrid.com","name":"PLUMgrid CI","username":"plumgrid-ci"},"date":"2014-03-10T16:01:47.000Z","id":"AAAAVn//Bp0=","message":"Patch Set 6: Works for me\n\nBuild Successful \n\nhttp://10.1.2.41:8080/job/plumgrid-ci/2134/ : SUCCESS","revisionNumber":6},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-10T16:03:22.000Z","id":"AAAAVn//Bow=","message":"Patch Set 6:\n\n Build Failure LOGS: http://144.76.193.39/logs/70700/6 ","revisionNumber":6},{"author":{"accountId":10153,"email":"oc-neutron-test@oneconvergence.com","name":"One Convergence CI","username":"oneconvergence"},"date":"2014-03-10T16:05:39.000Z","id":"AAAAVn//BoQ=","message":"Patch Set 6:\n\nOne Convergence Third Party Tests Passed. LOGS LINK ---\u003e\n\nhttps://www.dropbox.com/sh/rqfx7of454u48em/UB_CuglCUL\n\nFor any questions mail us at: oc-neutron-test@oneconvergence.com\n\n","revisionNumber":6},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-03-10T16:07:09.000Z","id":"AAAAVn//Bns=","message":"Patch Set 6: Works for me\n\nBuild successful.\n\n- Neutron_Gate http://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/3331 : SUCCESS in 15m 11s\n","revisionNumber":6},{"author":{"accountId":9925,"email":"lucas@midokura.com","name":"Midokura CI Bot","username":"midokura"},"date":"2014-03-10T16:07:11.000Z","id":"AAAAVn//Bno=","message":"Patch Set 6: Works for me\n\nhttp://119.15.112.118/results/midostack_logs_2014-03-10-155146.tar.gz","revisionNumber":6},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-03-10T16:10:15.000Z","id":"AAAAVn//BmM=","message":"Patch Set 6: Works for me\n\nTests succeeded.\n\n- BigSwitch-Plugin http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-6/BSN_PLUGIN/ : SUCCESS\n- BigSwitch-ML2-Driver http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-6/BSN_ML2/ : SUCCESS\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-6\n\nContact: openstack-ci@bigswitch.com\n\nLeave a comment with 'recheck-bigswitch' to cause a recheck. \n","revisionNumber":6},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-10T16:11:24.000Z","id":"AAAAVn//Bl8=","message":"Patch Set 6: Works for me\n\n Arista third party testing PASSED [ https://arista.box.com/s/kmncyqrekem1wc8jccv3 ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":6},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-03-10T16:22:43.000Z","id":"AAAAVn//BhQ=","message":"Patch Set 6:\n\nBuild succeeded.\n\n- http://64.119.130.115/70700/6/ : Looks good to me in 30m 52s\n","revisionNumber":6},{"author":{"accountId":10119,"email":"openstack-ci-test@varmour.com","name":"vArmour CI Test","username":"varmourci"},"date":"2014-03-10T16:26:18.000Z","id":"AAAAVn//Bfg=","message":"Patch Set 6: Works for me\n\nBuild Successful \n\nhttp://10.150.250.176:8080/job/vArmour-Neutron-CI/562/ : SUCCESS","revisionNumber":6},{"author":{"accountId":6788,"email":"rossble@gmail.com","name":"Rossella Sblendido","username":"rossella-o"},"date":"2014-03-10T17:02:09.000Z","id":"AAAAVn//BPA=","message":"Patch Set 6: (3 inline comments)\n\nSome questions and minor comments","revisionNumber":6},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-10T17:03:07.000Z","id":"AAAAVn//BOk=","message":"Patch Set 6: Doesn't seem to work\n\nBuild failed.  For information on how to proceed, see https://wiki.openstack.org/wiki/GerritJenkinsGit#Test_Failures\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/6/check/gate-neutron-pep8/b636df4 : SUCCESS in 3m 08s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/6/check/gate-neutron-docs/683ed0f/doc/build/html/ : SUCCESS in 2m 07s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/6/check/gate-neutron-python26/5c9ac4d : SUCCESS in 42m 58s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/6/check/gate-neutron-python27/e4fce0b : SUCCESS in 26m 47s\n- check-grenade-dsvm http://logs.openstack.org/00/70700/6/check/check-grenade-dsvm/127d3b2 : SUCCESS in 29m 57s\n- check-tempest-dsvm-full http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-full/48597dc : FAILURE in 57m 24s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-neutron/116221f : SUCCESS in 35m 59s\n- check-tempest-dsvm-neutron-heat-slow http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-neutron-heat-slow/7e369ae : SUCCESS in 26m 26s\n- check-tempest-dsvm-neutron-full http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-neutron-full/abc84fd : SUCCESS in 1h 02m 54s (non-voting)\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-neutron/116221f : SUCCESS in 35m 59s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-neutron-pg/cd7dc76 : SUCCESS in 38m 33s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/6/check/check-tempest-dsvm-neutron-pg/cd7dc76 : SUCCESS in 38m 33s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/6/check/gate-tempest-dsvm-neutron-large-ops/ffd4f3e : SUCCESS in 13m 44s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/6/check/check-grenade-dsvm-neutron/ec04d62 : FAILURE in 23m 49s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/6/check/check-devstack-dsvm-neutron/35d066c : FAILURE in 15m 05s (non-voting)\n","revisionNumber":6},{"author":{"accountId":8871,"email":"","name":"Elastic Recheck","username":"elasticrecheck"},"date":"2014-03-10T17:04:08.000Z","id":"AAAAVn//BOI=","message":"Patch Set 6:\n\nI noticed jenkins failed, I think you hit bug(s):\n\n- check-grenade-dsvm-neutron: https://bugs.launchpad.net/bugs/1280464\n- check-devstack-dsvm-neutron: unrecognized error\n- check-tempest-dsvm-full: https://bugs.launchpad.net/bugs/1254872\n\nYou have some unrecognized errors.\nFor bug details see: http://status.openstack.org/elastic-recheck/","revisionNumber":6},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-10T17:12:06.000Z","id":"AAAAVn//BJ8=","message":"Patch Set 6: Works for me\n\n Build Successful LOGS: http://144.76.193.39/logs/70700/6 ","revisionNumber":6},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-10T17:52:53.000Z","id":"AAAAVn//A3M=","message":"Patch Set 6: (2 inline comments)\n\n","revisionNumber":6},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-10T18:09:16.000Z","id":"AAAAVn//Ass=","message":"Uploaded patch set 7.","revisionNumber":7},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-10T18:09:17.000Z","id":"AAAAVn//Aso=","message":"Patch Set 7:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":7},{"author":{"accountId":10294,"email":"openstack_gerrit@brocade.com","name":"Brocade CI","username":"bci"},"date":"2014-03-10T18:12:01.000Z","id":"AAAAVn//ArM=","message":"Patch Set 7:\n\nBrocade ML2: FAIL http://50.56.236.34/tempest2/70700/ee3688e8395eb8872768e415fecae43bbdfb175a/ml2","revisionNumber":7},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-10T18:23:14.000Z","id":"AAAAVn//Akk=","message":"Uploaded patch set 8.","revisionNumber":8},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-10T18:23:18.000Z","id":"AAAAVn//Akg=","message":"Patch Set 8:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":8},{"author":{"accountId":10294,"email":"openstack_gerrit@brocade.com","name":"Brocade CI","username":"bci"},"date":"2014-03-10T18:27:44.000Z","id":"AAAAVn//Ahg=","message":"Patch Set 8:\n\nBrocade ML2: FAIL http://50.56.236.34/tempest2/70700/b3bf7db689ecb4bbf48facd16409e88863fb7e07/ml2","revisionNumber":8},{"author":{"accountId":9925,"email":"lucas@midokura.com","name":"Midokura CI Bot","username":"midokura"},"date":"2014-03-10T18:36:59.000Z","id":"AAAAVn//Acw=","message":"Patch Set 8: Works for me\n\nhttp://119.15.112.118/results/midostack_logs_2014-03-10-183511.tar.gz","revisionNumber":8},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-03-10T18:41:35.000Z","id":"AAAAVn//AZU=","message":"Patch Set 8: Works for me\n\nBuild successful.\n\n- Neutron_Gate http://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/3340 : SUCCESS in 18m 00s\n","revisionNumber":8},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-10T18:41:52.000Z","id":"AAAAVn//AY4=","message":"Patch Set 8: Works for me\n\n Arista third party testing PASSED [ https://arista.box.com/s/57y7i9mpxrpq1jbnd9ll ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":8},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-10T18:41:54.000Z","id":"AAAAVn//AY0=","message":"Patch Set 8: Works for me\n\n Build Successful LOGS: http://144.76.193.39/logs/70700/8 ","revisionNumber":8},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-03-10T18:48:53.000Z","id":"AAAAVn//AUo=","message":"Patch Set 8:\n\nBuild failed. For rechecking only on the Hyper-V CI, add a review comment with recheck hyper-v\n\n- http://64.119.130.115/70700/8/ : Test run failed in 25m 27s\n","revisionNumber":8},{"author":{"accountId":10184,"email":"nuage-ci@nuagenetworks.net","name":"Nuage CI","username":"nuage-ci"},"date":"2014-03-10T18:56:46.000Z","id":"AAAAVn//APk=","message":"Patch Set 8:\n\nhttp://208.113.169.228/nuage-ci/00_70700_8 - SUCCESS - non voting","revisionNumber":8},{"author":{"accountId":10117,"email":"plumgrid-ci-os@plumgrid.com","name":"PLUMgrid CI","username":"plumgrid-ci"},"date":"2014-03-10T19:00:19.000Z","id":"AAAAVn//ANw=","message":"Patch Set 8: Works for me\n\nBuild Successful \n\nhttp://10.1.2.41:8080/job/plumgrid-ci/2143/ : SUCCESS","revisionNumber":8},{"author":{"accountId":10119,"email":"openstack-ci-test@varmour.com","name":"vArmour CI Test","username":"varmourci"},"date":"2014-03-10T19:21:00.000Z","id":"AAAAVn//ACk=","message":"Patch Set 8: Works for me\n\nBuild Successful \n\nhttp://10.150.250.176:8080/job/vArmour-Neutron-CI/571/ : SUCCESS","revisionNumber":8},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-10T20:02:39.000Z","id":"AAAAVn/+/vI=","message":"Patch Set 8: Works for me\n\nBuild succeeded.\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/8/check/gate-neutron-pep8/52351eb : SUCCESS in 2m 58s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/8/check/gate-neutron-docs/9715865/doc/build/html/ : SUCCESS in 2m 17s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/8/check/gate-neutron-python26/b1c3b77 : SUCCESS in 17m 55s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/8/check/gate-neutron-python27/112231b : SUCCESS in 25m 37s\n- check-grenade-dsvm http://logs.openstack.org/00/70700/8/check/check-grenade-dsvm/2a040d5 : SUCCESS in 38m 47s\n- check-tempest-dsvm-full http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-full/52fcab4 : SUCCESS in 59m 28s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-neutron/afab1e0 : SUCCESS in 35m 58s\n- check-tempest-dsvm-neutron-heat-slow http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-neutron-heat-slow/e7ae5e3 : SUCCESS in 21m 20s\n- check-tempest-dsvm-neutron-full http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-neutron-full/8198ded : FAILURE in 1h 06m 52s (non-voting)\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-neutron/afab1e0 : SUCCESS in 35m 58s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-neutron-pg/9b1d096 : SUCCESS in 38m 06s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/8/check/check-tempest-dsvm-neutron-pg/9b1d096 : SUCCESS in 38m 06s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/8/check/gate-tempest-dsvm-neutron-large-ops/554d266 : SUCCESS in 15m 22s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/8/check/check-grenade-dsvm-neutron/e7aacc2 : FAILURE in 22m 30s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/8/check/check-devstack-dsvm-neutron/d4852a9 : FAILURE in 14m 39s (non-voting)\n","revisionNumber":8},{"author":{"accountId":10153,"email":"oc-neutron-test@oneconvergence.com","name":"One Convergence CI","username":"oneconvergence"},"date":"2014-03-10T21:24:37.000Z","id":"AAAAVn/+/Bw=","message":"Patch Set 8:\n\nOne Convergence Third Party Tests Passed. LOGS LINK ---\u003e\n\nhttps://www.dropbox.com/sh/tg6rhni45n5n5wj/znHPy0fSgI\n\nFor any questions mail us at: oc-neutron-test@oneconvergence.com\n\n","revisionNumber":8},{"author":{"accountId":9681,"email":"ryu-openstack-review@lists.sourceforge.net","name":"Neutron Ryu","username":"neutronryu"},"date":"2014-03-10T23:38:27.000Z","id":"AAAAVn/++Is=","message":"Patch Set 8: Works for me\n\nBuild Successful \n\nOFAgent http://180.37.183.32/jenkins/job/ofagent-tempest/474/artifact/logs/ : SUCCESS\n\nRyu Plugin http://180.37.183.32/jenkins/job/ryuplugin-tempest/412/artifact/logs/ : SUCCESS","revisionNumber":8},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-03-11T13:38:59.000Z","id":"AAAAVn/+5Tk=","message":"Uploaded patch set 9.","revisionNumber":9},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-11T13:39:03.000Z","id":"AAAAVn/+5Tg=","message":"Patch Set 9:\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":9},{"author":{"accountId":10184,"email":"nuage-ci@nuagenetworks.net","name":"Nuage CI","username":"nuage-ci"},"date":"2014-03-11T13:52:21.000Z","id":"AAAAVn/+5NY=","message":"Patch Set 9:\n\nhttp://208.113.169.228/nuage-ci/00_70700_9 - SUCCESS - non voting","revisionNumber":9},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-03-11T13:53:17.000Z","id":"AAAAVn/+5M0=","message":"Patch Set 9: Works for me\n\nBuild successful.\n\n- Neutron_Gate http://133.242.19.163:8000/neutron-ci-logs/Neutron_Gate/3406 : SUCCESS in 13m 45s\n","revisionNumber":9},{"author":{"accountId":9925,"email":"lucas@midokura.com","name":"Midokura CI Bot","username":"midokura"},"date":"2014-03-11T13:55:26.000Z","id":"AAAAVn/+5LU=","message":"Patch Set 9: Works for me\n\nhttp://119.15.112.118/results/midostack_logs_2014-03-11-133905.tar.gz","revisionNumber":9},{"author":{"accountId":10117,"email":"plumgrid-ci-os@plumgrid.com","name":"PLUMgrid CI","username":"plumgrid-ci"},"date":"2014-03-11T13:56:44.000Z","id":"AAAAVn/+5Kw=","message":"Patch Set 9: Works for me\n\nBuild Successful \n\nhttp://10.1.2.41:8080/job/plumgrid-ci/2203/ : SUCCESS","revisionNumber":9},{"author":{"accountId":9845,"email":"arista-openstack-test@aristanetworks.com","name":"Arista Testing","username":"arista-test"},"date":"2014-03-11T13:57:29.000Z","id":"AAAAVn/+5Ko=","message":"Patch Set 9: Works for me\n\n Arista third party testing PASSED [ https://arista.box.com/s/j2ctyyc5l1ikzsyrqlo6 ]\n\n For testing details or any questions please check https://wiki.openstack.org/wiki/Arista-third-party-testing ","revisionNumber":9},{"author":{"accountId":9732,"email":"mlnx-openstack-ci@dev.mellanox.co.il","name":"Mellanox External Testing","username":"mellanox"},"date":"2014-03-11T14:03:19.000Z","id":"AAAAVn/+5Ic=","message":"Patch Set 9:\n\n Build Failure LOGS: http://144.76.193.39/logs/70700/9 ","revisionNumber":9},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-03-11T14:04:58.000Z","id":"AAAAVn/+5H4=","message":"Patch Set 9:\n\nBuild succeeded.\n\n- http://64.119.130.115/70700/9/ : Looks good to me in 25m 44s\n","revisionNumber":9},{"author":{"accountId":9787,"email":"openstack-ci@bigswitch.com","name":"Big Switch CI","username":"bsn"},"date":"2014-03-11T14:08:35.000Z","id":"AAAAVn/+5FU=","message":"Patch Set 9: Works for me\n\nTests succeeded.\n\n- BigSwitch-Plugin http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-9/BSN_PLUGIN/ : SUCCESS\n- BigSwitch-ML2-Driver http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-9/BSN_ML2/ : SUCCESS\n\nAll Logs: http://openstack-ci-gw.bigswitch.com/logs/refs-changes-00-70700-9\n\nContact: openstack-ci@bigswitch.com\n\nLeave a comment with 'recheck-bigswitch' to cause a recheck. \n","revisionNumber":9},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-03-11T14:39:10.000Z","id":"AAAAVn/+42A=","message":"Patch Set 9: Works for me\n\nBuild succeeded.\n\n- gate-neutron-pep8 http://logs.openstack.org/00/70700/9/check/gate-neutron-pep8/e95e90c : SUCCESS in 2m 45s\n- gate-neutron-docs http://docs-draft.openstack.org/00/70700/9/check/gate-neutron-docs/05c315c/doc/build/html/ : SUCCESS in 2m 16s\n- gate-neutron-python26 http://logs.openstack.org/00/70700/9/check/gate-neutron-python26/a752fda : SUCCESS in 54m 39s\n- gate-neutron-python27 http://logs.openstack.org/00/70700/9/check/gate-neutron-python27/a55aede : SUCCESS in 16m 59s\n- check-grenade-dsvm http://logs.openstack.org/00/70700/9/check/check-grenade-dsvm/0398571 : SUCCESS in 36m 22s\n- check-tempest-dsvm-full http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-full/b287990 : SUCCESS in 45m 54s\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-neutron/df3a426 : SUCCESS in 38m 23s\n- check-tempest-dsvm-neutron-heat-slow http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-neutron-heat-slow/521358c : SUCCESS in 24m 56s\n- check-tempest-dsvm-neutron-full http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-neutron-full/c9cc326 : SUCCESS in 47m 22s (non-voting)\n- check-tempest-dsvm-neutron http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-neutron/df3a426 : SUCCESS in 38m 23s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-neutron-pg/dd62bb6 : SUCCESS in 46m 06s\n- check-tempest-dsvm-neutron-pg http://logs.openstack.org/00/70700/9/check/check-tempest-dsvm-neutron-pg/dd62bb6 : SUCCESS in 46m 06s\n- gate-tempest-dsvm-neutron-large-ops http://logs.openstack.org/00/70700/9/check/gate-tempest-dsvm-neutron-large-ops/45f98db : SUCCESS in 18m 43s\n- check-grenade-dsvm-neutron http://logs.openstack.org/00/70700/9/check/check-grenade-dsvm-neutron/af93366 : FAILURE in 22m 01s (non-voting)\n- check-devstack-dsvm-neutron http://logs.openstack.org/00/70700/9/check/check-devstack-dsvm-neutron/c276077 : FAILURE in 16m 48s (non-voting)\n","revisionNumber":9},{"author":{"accountId":10153,"email":"oc-neutron-test@oneconvergence.com","name":"One Convergence CI","username":"oneconvergence"},"date":"2014-03-11T15:08:52.000Z","id":"AAAAVn/+4fE=","message":"Patch Set 9:\n\nOne Convergence Third Party Tests Passed. LOGS LINK ---\u003e\n\nhttps://www.dropbox.com/sh/63ueat6mcwl05p8/AkMr7nMnB1\n\nFor any questions mail us at: oc-neutron-test@oneconvergence.com\n\n","revisionNumber":9},{"author":{"accountId":9681,"email":"ryu-openstack-review@lists.sourceforge.net","name":"Neutron Ryu","username":"neutronryu"},"date":"2014-03-11T21:53:53.000Z","id":"AAAAVn/+1Fg=","message":"Patch Set 9:\n\nBuild Failed \n\nOFAgent http://180.37.183.32/jenkins/job/ofagent-tempest/518/artifact/logs/ : FAILURE\n\nRyu Plugin http://180.37.183.32/jenkins/job/ryuplugin-tempest/451/artifact/logs/ : FAILURE","revisionNumber":9},{"author":{"accountId":2874,"email":"gongysh@unitedstack.com","name":"gongysh","username":"gongysh"},"date":"2014-04-09T08:29:05.000Z","id":"AAAAW3//9eg=","message":"Patch Set 9: I would prefer that you didn't merge this\n\n(4 inline comments)\n\n","revisionNumber":9},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-04-09T08:29:09.000Z","id":"AAAAW3//9ec=","message":"Patch Set 9: No score\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":9},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-04-09T08:29:13.000Z","id":"AAAAW3//9eY=","message":"Patch Set 9: Doesn't seem to work\n\nMerge Failed.\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":9},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-04-10T16:11:49.000Z","id":"AAAAW3//wLY=","message":"Patch Set 9: (1 inline comment)\n\ngongysh\tthanks for the reviews, I'll work with the DVR team to see if there is any overlap with this implementation before submitting another patch","revisionNumber":9},{"author":{"accountId":9,"email":"","name":"LaunchpadSync","username":"launchpadsync"},"date":"2014-04-18T06:03:17.000Z","id":"AAAAXH//spI=","message":"Patch Set 9: Abandoned\n\ncode review expired after 1 week of no activity after a negative review, it can be restored using the `Restore Change` button under the Patch Set on the web interface","revisionNumber":9},{"author":{"accountId":9,"email":"","name":"LaunchpadSync","username":"launchpadsync"},"date":"2014-04-18T06:03:17.000Z","id":"AAAAXH//spM=","message":"Patch Set 9:\n\ncode review expired after 1 week of no activity after a negative review, it can be restored using the `Restore Change` button under the Patch Set on the web interface","revisionNumber":9},{"author":{"accountId":7141,"email":"sylvain.afchain@enovance.com","name":"Sylvain Afchain","username":"sylvainA"},"date":"2014-04-22T08:29:25.000Z","id":"AAAAXH//YB8=","message":"Patch Set 9: Restored","revisionNumber":9},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-04-22T08:29:28.000Z","id":"AAAAXH//YB0=","message":"Patch Set 9: No score\n\nStarting check jobs.\nhttp://status.openstack.org/zuul/","revisionNumber":9},{"author":{"accountId":3,"email":"","name":"Jenkins","username":"jenkins"},"date":"2014-04-22T08:29:37.000Z","id":"AAAAXH//YBk=","message":"Patch Set 9: Doesn't seem to work\n\nMerge Failed.\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":9},{"author":{"accountId":5170,"email":"hyper-v_ci@microsoft.com","name":"Hyper-V CI","username":"hyper-v-ci"},"date":"2014-04-22T08:29:38.000Z","id":"AAAAXH//YBg=","message":"Patch Set 9:\n\nBuild failed. For rechecking only on the Hyper-V CI, add a review comment with recheck hyper-v\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":9},{"author":{"accountId":10116,"email":"nec-openstack-ci@iaas.jp.nec.com","name":"NEC OpenStack CI","username":"nec-openstack-ci"},"date":"2014-04-22T08:29:58.000Z","id":"AAAAXH//YBQ=","message":"Patch Set 9: No score\n\nBuild failed. Leave a comment with 'recheck-nec' to rerun a check. ('recheck' will be ignored.)\n\nThis change was unable to be automatically merged with the current state of the repository. Please rebase your change and upload a new patchset.","revisionNumber":9}]}</script><script type="text/javascript">(function() {
  $(function() {
    React.renderComponent(ChangeView(changeViewProps), document.getElementById('ChangeViewRoot'));
  });

}).call(this);
</script></body></html>
